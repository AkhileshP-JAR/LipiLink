{
  "version": 3,
  "sources": ["../../base64-js/index.js", "../../@langchain/groq/src/profiles.ts", "../../@langchain/core/src/prompt_values.ts", "../../@langchain/core/src/utils/js-sha256/hash.ts", "../../@langchain/core/dist/utils/hash.js", "../../@langchain/core/src/caches/index.ts", "../../js-tiktoken/dist/chunk-VL2OQCWN.js", "../../@langchain/core/src/utils/tiktoken.ts", "../../@langchain/core/src/language_models/base.ts", "../../@langchain/core/src/runnables/passthrough.ts", "../../@langchain/core/src/language_models/utils.ts", "../../@langchain/core/src/language_models/chat_models.ts", "../../@langchain/core/dist/utils/types/index.js", "../../groq-sdk/src/version.ts", "../../groq-sdk/src/_shims/registry.ts", "../../groq-sdk/src/_shims/MultipartBody.ts", "../../groq-sdk/src/_shims/web-runtime.ts", "../../groq-sdk/_shims/index.mjs", "../../groq-sdk/src/error.ts", "../../groq-sdk/src/lib/streaming.ts", "../../groq-sdk/src/uploads.ts", "../../groq-sdk/src/core.ts", "../../groq-sdk/src/resource.ts", "../../groq-sdk/src/resources/audio/speech.ts", "../../groq-sdk/src/resources/audio/transcriptions.ts", "../../groq-sdk/src/resources/audio/translations.ts", "../../groq-sdk/src/resources/audio/audio.ts", "../../groq-sdk/src/resources/batches.ts", "../../groq-sdk/src/resources/chat/completions.ts", "../../groq-sdk/src/resources/chat/chat.ts", "../../groq-sdk/src/resources/completions.ts", "../../groq-sdk/src/resources/embeddings.ts", "../../groq-sdk/src/resources/files.ts", "../../groq-sdk/src/resources/models.ts", "../../groq-sdk/src/index.ts", "../../@langchain/core/src/runnables/router.ts", "../../@langchain/core/src/runnables/branch.ts", "../../@langchain/core/src/runnables/history.ts", "../../@langchain/core/dist/runnables/index.js", "../../@langchain/core/src/output_parsers/base.ts", "../../@langchain/core/src/output_parsers/transform.ts", "../../@langchain/core/src/output_parsers/bytes.ts", "../../@langchain/core/src/output_parsers/list.ts", "../../@langchain/core/src/output_parsers/string.ts", "../../@langchain/core/src/output_parsers/structured.ts", "../../@langchain/core/dist/utils/json_patch.js", "../../@langchain/core/src/output_parsers/json.ts", "../../@langchain/core/src/utils/sax-js/sax.ts", "../../@langchain/core/src/output_parsers/xml.ts", "../../@langchain/core/dist/output_parsers/index.js", "../../@langchain/core/src/output_parsers/openai_tools/json_output_tools_parsers.ts", "../../@langchain/core/dist/output_parsers/openai_tools/index.js", "../../@langchain/core/src/tools/types.ts", "../../@langchain/core/src/utils/function_calling.ts", "../../@langchain/groq/src/chat_models.ts"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/**\n * This file was automatically generated by an automated script. Do not edit manually.\n */\nimport type { ModelProfile } from \"@langchain/core/language_models/profile\";\nconst PROFILES: Record<string, ModelProfile> = {\n  \"llama-3.1-8b-instant\": {\n    maxInputTokens: 131072,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 8192,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"mistral-saba-24b\": {\n    maxInputTokens: 32768,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 32768,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"llama3-8b-8192\": {\n    maxInputTokens: 8192,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 8192,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"qwen-qwq-32b\": {\n    maxInputTokens: 131072,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 16384,\n    reasoningOutput: true,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"llama3-70b-8192\": {\n    maxInputTokens: 8192,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 8192,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"deepseek-r1-distill-llama-70b\": {\n    maxInputTokens: 131072,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 8192,\n    reasoningOutput: true,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"llama-guard-3-8b\": {\n    maxInputTokens: 8192,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 8192,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: false,\n    structuredOutput: false,\n  },\n  \"gemma2-9b-it\": {\n    maxInputTokens: 8192,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 8192,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"llama-3.3-70b-versatile\": {\n    maxInputTokens: 131072,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 32768,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"moonshotai/kimi-k2-instruct-0905\": {\n    maxInputTokens: 262144,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 16384,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"moonshotai/kimi-k2-instruct\": {\n    maxInputTokens: 131072,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 16384,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"openai/gpt-oss-20b\": {\n    maxInputTokens: 131072,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 32768,\n    reasoningOutput: true,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"openai/gpt-oss-120b\": {\n    maxInputTokens: 131072,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 32768,\n    reasoningOutput: true,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"qwen/qwen3-32b\": {\n    maxInputTokens: 131072,\n    imageInputs: false,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 16384,\n    reasoningOutput: true,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"meta-llama/llama-4-scout-17b-16e-instruct\": {\n    maxInputTokens: 131072,\n    imageInputs: true,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 8192,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"meta-llama/llama-4-maverick-17b-128e-instruct\": {\n    maxInputTokens: 131072,\n    imageInputs: true,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 8192,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: true,\n    structuredOutput: false,\n  },\n  \"meta-llama/llama-guard-4-12b\": {\n    maxInputTokens: 131072,\n    imageInputs: true,\n    audioInputs: false,\n    pdfInputs: false,\n    videoInputs: false,\n    maxOutputTokens: 128,\n    reasoningOutput: false,\n    imageOutputs: false,\n    audioOutputs: false,\n    videoOutputs: false,\n    toolCalling: false,\n    structuredOutput: false,\n  },\n};\nexport default PROFILES;\n", "import { Serializable } from \"./load/serializable.js\";\nimport { type BaseMessage } from \"./messages/base.js\";\nimport { HumanMessage } from \"./messages/human.js\";\nimport { getBufferString } from \"./messages/utils.js\";\n\nexport interface BasePromptValueInterface extends Serializable {\n  toString(): string;\n\n  toChatMessages(): BaseMessage[];\n}\n\nexport interface StringPromptValueInterface extends BasePromptValueInterface {\n  value: string;\n}\n\nexport interface ChatPromptValueInterface extends BasePromptValueInterface {\n  messages: BaseMessage[];\n}\n\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nexport abstract class BasePromptValue\n  extends Serializable\n  implements BasePromptValueInterface\n{\n  abstract toString(): string;\n\n  abstract toChatMessages(): BaseMessage[];\n}\n\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nexport class StringPromptValue\n  extends BasePromptValue\n  implements StringPromptValueInterface\n{\n  static lc_name(): string {\n    return \"StringPromptValue\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  value: string;\n\n  constructor(value: string) {\n    super({ value });\n    this.value = value;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  toChatMessages() {\n    return [new HumanMessage(this.value)];\n  }\n}\n\n/**\n * Interface for the fields of a ChatPromptValue.\n */\nexport interface ChatPromptValueFields {\n  messages: BaseMessage[];\n}\n\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nexport class ChatPromptValue\n  extends BasePromptValue\n  implements ChatPromptValueInterface\n{\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ChatPromptValue\";\n  }\n\n  messages: BaseMessage[];\n\n  constructor(messages: BaseMessage[]);\n\n  constructor(fields: ChatPromptValueFields);\n\n  constructor(fields: BaseMessage[] | ChatPromptValueFields) {\n    if (Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { messages: fields };\n    }\n\n    super(fields);\n    this.messages = fields.messages;\n  }\n\n  toString() {\n    return getBufferString(this.messages);\n  }\n\n  toChatMessages() {\n    return this.messages;\n  }\n}\n\nexport type ImageContent = {\n  /** Specifies the detail level of the image. */\n  detail?: \"auto\" | \"low\" | \"high\";\n\n  /** Either a URL of the image or the base64 encoded image data. */\n  url: string;\n};\n\nexport interface ImagePromptValueFields {\n  imageUrl: ImageContent;\n}\n\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nexport class ImagePromptValue extends BasePromptValue {\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ImagePromptValue\";\n  }\n\n  imageUrl: ImageContent;\n\n  /** @ignore */\n  value: string;\n\n  constructor(fields: ImagePromptValueFields);\n\n  constructor(fields: ImageContent);\n\n  constructor(fields: ImageContent | ImagePromptValueFields) {\n    if (!(\"imageUrl\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { imageUrl: fields };\n    }\n\n    super(fields);\n    this.imageUrl = fields.imageUrl;\n  }\n\n  toString() {\n    return this.imageUrl.url;\n  }\n\n  toChatMessages() {\n    return [\n      new HumanMessage({\n        content: [\n          {\n            type: \"image_url\",\n            image_url: {\n              detail: this.imageUrl.detail,\n              url: this.imageUrl.url,\n            },\n          },\n        ],\n      }),\n    ];\n  }\n}\n", "// @ts-nocheck\n\n// Inlined to deal with portability issues with importing crypto module\n\n/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.11.1\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2025\n * @license MIT\n */\n/*jslint bitwise: true */\n\"use strict\";\n\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n  0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n  0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n  0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n  0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n  0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\n\nvar blocks = [];\n\nfunction Sha256(is224, sharedMemory) {\n  if (sharedMemory) {\n    blocks[0] =\n      blocks[16] =\n      blocks[1] =\n      blocks[2] =\n      blocks[3] =\n      blocks[4] =\n      blocks[5] =\n      blocks[6] =\n      blocks[7] =\n      blocks[8] =\n      blocks[9] =\n      blocks[10] =\n      blocks[11] =\n      blocks[12] =\n      blocks[13] =\n      blocks[14] =\n      blocks[15] =\n        0;\n    this.blocks = blocks;\n  } else {\n    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  }\n\n  if (is224) {\n    this.h0 = 0xc1059ed8;\n    this.h1 = 0x367cd507;\n    this.h2 = 0x3070dd17;\n    this.h3 = 0xf70e5939;\n    this.h4 = 0xffc00b31;\n    this.h5 = 0x68581511;\n    this.h6 = 0x64f98fa7;\n    this.h7 = 0xbefa4fa4;\n  } else {\n    // 256\n    this.h0 = 0x6a09e667;\n    this.h1 = 0xbb67ae85;\n    this.h2 = 0x3c6ef372;\n    this.h3 = 0xa54ff53a;\n    this.h4 = 0x510e527f;\n    this.h5 = 0x9b05688c;\n    this.h6 = 0x1f83d9ab;\n    this.h7 = 0x5be0cd19;\n  }\n\n  this.block = this.start = this.bytes = this.hBytes = 0;\n  this.finalized = this.hashed = false;\n  this.first = true;\n  this.is224 = is224;\n}\n\nSha256.prototype.update = function (message) {\n  if (this.finalized) {\n    return;\n  }\n  var notString,\n    type = typeof message;\n  if (type !== \"string\") {\n    if (type === \"object\") {\n      if (message === null) {\n        throw new Error(ERROR);\n      } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n        message = new Uint8Array(message);\n      } else if (!Array.isArray(message)) {\n        if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n          throw new Error(ERROR);\n        }\n      }\n    } else {\n      throw new Error(ERROR);\n    }\n    notString = true;\n  }\n  var code,\n    index = 0,\n    i,\n    length = message.length,\n    blocks = this.blocks;\n  while (index < length) {\n    if (this.hashed) {\n      this.hashed = false;\n      blocks[0] = this.block;\n      this.block =\n        blocks[16] =\n        blocks[1] =\n        blocks[2] =\n        blocks[3] =\n        blocks[4] =\n        blocks[5] =\n        blocks[6] =\n        blocks[7] =\n        blocks[8] =\n        blocks[9] =\n        blocks[10] =\n        blocks[11] =\n        blocks[12] =\n        blocks[13] =\n        blocks[14] =\n        blocks[15] =\n          0;\n    }\n\n    if (notString) {\n      for (i = this.start; index < length && i < 64; ++index) {\n        blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];\n      }\n    } else {\n      for (i = this.start; index < length && i < 64; ++index) {\n        code = message.charCodeAt(index);\n        if (code < 0x80) {\n          blocks[i >>> 2] |= code << SHIFT[i++ & 3];\n        } else if (code < 0x800) {\n          blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n        } else if (code < 0xd800 || code >= 0xe000) {\n          blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n        } else {\n          code =\n            0x10000 +\n            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n          blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n        }\n      }\n    }\n\n    this.lastByteIndex = i;\n    this.bytes += i - this.start;\n    if (i >= 64) {\n      this.block = blocks[16];\n      this.start = i - 64;\n      this.hash();\n      this.hashed = true;\n    } else {\n      this.start = i;\n    }\n  }\n  if (this.bytes > 4294967295) {\n    this.hBytes += (this.bytes / 4294967296) << 0;\n    this.bytes = this.bytes % 4294967296;\n  }\n  return this;\n};\n\nSha256.prototype.finalize = function () {\n  if (this.finalized) {\n    return;\n  }\n  this.finalized = true;\n  var blocks = this.blocks,\n    i = this.lastByteIndex;\n  blocks[16] = this.block;\n  blocks[i >>> 2] |= EXTRA[i & 3];\n  this.block = blocks[16];\n  if (i >= 56) {\n    if (!this.hashed) {\n      this.hash();\n    }\n    blocks[0] = this.block;\n    blocks[16] =\n      blocks[1] =\n      blocks[2] =\n      blocks[3] =\n      blocks[4] =\n      blocks[5] =\n      blocks[6] =\n      blocks[7] =\n      blocks[8] =\n      blocks[9] =\n      blocks[10] =\n      blocks[11] =\n      blocks[12] =\n      blocks[13] =\n      blocks[14] =\n      blocks[15] =\n        0;\n  }\n  blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n  blocks[15] = this.bytes << 3;\n  this.hash();\n};\n\nSha256.prototype.hash = function () {\n  var a = this.h0,\n    b = this.h1,\n    c = this.h2,\n    d = this.h3,\n    e = this.h4,\n    f = this.h5,\n    g = this.h6,\n    h = this.h7,\n    blocks = this.blocks,\n    j,\n    s0,\n    s1,\n    maj,\n    t1,\n    t2,\n    ch,\n    ab,\n    da,\n    cd,\n    bc;\n\n  for (j = 16; j < 64; ++j) {\n    // rightrotate\n    t1 = blocks[j - 15];\n    s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n    t1 = blocks[j - 2];\n    s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n    blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;\n  }\n\n  bc = b & c;\n  for (j = 0; j < 64; j += 4) {\n    if (this.first) {\n      if (this.is224) {\n        ab = 300032;\n        t1 = blocks[0] - 1413257819;\n        h = (t1 - 150054599) << 0;\n        d = (t1 + 24177077) << 0;\n      } else {\n        ab = 704751109;\n        t1 = blocks[0] - 210244248;\n        h = (t1 - 1521486534) << 0;\n        d = (t1 + 143694565) << 0;\n      }\n      this.first = false;\n    } else {\n      s0 =\n        ((a >>> 2) | (a << 30)) ^\n        ((a >>> 13) | (a << 19)) ^\n        ((a >>> 22) | (a << 10));\n      s1 =\n        ((e >>> 6) | (e << 26)) ^\n        ((e >>> 11) | (e << 21)) ^\n        ((e >>> 25) | (e << 7));\n      ab = a & b;\n      maj = ab ^ (a & c) ^ bc;\n      ch = (e & f) ^ (~e & g);\n      t1 = h + s1 + ch + K[j] + blocks[j];\n      t2 = s0 + maj;\n      h = (d + t1) << 0;\n      d = (t1 + t2) << 0;\n    }\n    s0 =\n      ((d >>> 2) | (d << 30)) ^\n      ((d >>> 13) | (d << 19)) ^\n      ((d >>> 22) | (d << 10));\n    s1 =\n      ((h >>> 6) | (h << 26)) ^\n      ((h >>> 11) | (h << 21)) ^\n      ((h >>> 25) | (h << 7));\n    da = d & a;\n    maj = da ^ (d & b) ^ ab;\n    ch = (g & h) ^ (~g & e);\n    t1 = f + s1 + ch + K[j + 1] + blocks[j + 1];\n    t2 = s0 + maj;\n    g = (c + t1) << 0;\n    c = (t1 + t2) << 0;\n    s0 =\n      ((c >>> 2) | (c << 30)) ^\n      ((c >>> 13) | (c << 19)) ^\n      ((c >>> 22) | (c << 10));\n    s1 =\n      ((g >>> 6) | (g << 26)) ^\n      ((g >>> 11) | (g << 21)) ^\n      ((g >>> 25) | (g << 7));\n    cd = c & d;\n    maj = cd ^ (c & a) ^ da;\n    ch = (f & g) ^ (~f & h);\n    t1 = e + s1 + ch + K[j + 2] + blocks[j + 2];\n    t2 = s0 + maj;\n    f = (b + t1) << 0;\n    b = (t1 + t2) << 0;\n    s0 =\n      ((b >>> 2) | (b << 30)) ^\n      ((b >>> 13) | (b << 19)) ^\n      ((b >>> 22) | (b << 10));\n    s1 =\n      ((f >>> 6) | (f << 26)) ^\n      ((f >>> 11) | (f << 21)) ^\n      ((f >>> 25) | (f << 7));\n    bc = b & c;\n    maj = bc ^ (b & d) ^ cd;\n    ch = (f & g) ^ (~f & h);\n    t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n    t2 = s0 + maj;\n    e = (a + t1) << 0;\n    a = (t1 + t2) << 0;\n    this.chromeBugWorkAround = true;\n  }\n\n  this.h0 = (this.h0 + a) << 0;\n  this.h1 = (this.h1 + b) << 0;\n  this.h2 = (this.h2 + c) << 0;\n  this.h3 = (this.h3 + d) << 0;\n  this.h4 = (this.h4 + e) << 0;\n  this.h5 = (this.h5 + f) << 0;\n  this.h6 = (this.h6 + g) << 0;\n  this.h7 = (this.h7 + h) << 0;\n};\n\nSha256.prototype.hex = function () {\n  this.finalize();\n\n  var h0 = this.h0,\n    h1 = this.h1,\n    h2 = this.h2,\n    h3 = this.h3,\n    h4 = this.h4,\n    h5 = this.h5,\n    h6 = this.h6,\n    h7 = this.h7;\n\n  var hex =\n    HEX_CHARS[(h0 >>> 28) & 0x0f] +\n    HEX_CHARS[(h0 >>> 24) & 0x0f] +\n    HEX_CHARS[(h0 >>> 20) & 0x0f] +\n    HEX_CHARS[(h0 >>> 16) & 0x0f] +\n    HEX_CHARS[(h0 >>> 12) & 0x0f] +\n    HEX_CHARS[(h0 >>> 8) & 0x0f] +\n    HEX_CHARS[(h0 >>> 4) & 0x0f] +\n    HEX_CHARS[h0 & 0x0f] +\n    HEX_CHARS[(h1 >>> 28) & 0x0f] +\n    HEX_CHARS[(h1 >>> 24) & 0x0f] +\n    HEX_CHARS[(h1 >>> 20) & 0x0f] +\n    HEX_CHARS[(h1 >>> 16) & 0x0f] +\n    HEX_CHARS[(h1 >>> 12) & 0x0f] +\n    HEX_CHARS[(h1 >>> 8) & 0x0f] +\n    HEX_CHARS[(h1 >>> 4) & 0x0f] +\n    HEX_CHARS[h1 & 0x0f] +\n    HEX_CHARS[(h2 >>> 28) & 0x0f] +\n    HEX_CHARS[(h2 >>> 24) & 0x0f] +\n    HEX_CHARS[(h2 >>> 20) & 0x0f] +\n    HEX_CHARS[(h2 >>> 16) & 0x0f] +\n    HEX_CHARS[(h2 >>> 12) & 0x0f] +\n    HEX_CHARS[(h2 >>> 8) & 0x0f] +\n    HEX_CHARS[(h2 >>> 4) & 0x0f] +\n    HEX_CHARS[h2 & 0x0f] +\n    HEX_CHARS[(h3 >>> 28) & 0x0f] +\n    HEX_CHARS[(h3 >>> 24) & 0x0f] +\n    HEX_CHARS[(h3 >>> 20) & 0x0f] +\n    HEX_CHARS[(h3 >>> 16) & 0x0f] +\n    HEX_CHARS[(h3 >>> 12) & 0x0f] +\n    HEX_CHARS[(h3 >>> 8) & 0x0f] +\n    HEX_CHARS[(h3 >>> 4) & 0x0f] +\n    HEX_CHARS[h3 & 0x0f] +\n    HEX_CHARS[(h4 >>> 28) & 0x0f] +\n    HEX_CHARS[(h4 >>> 24) & 0x0f] +\n    HEX_CHARS[(h4 >>> 20) & 0x0f] +\n    HEX_CHARS[(h4 >>> 16) & 0x0f] +\n    HEX_CHARS[(h4 >>> 12) & 0x0f] +\n    HEX_CHARS[(h4 >>> 8) & 0x0f] +\n    HEX_CHARS[(h4 >>> 4) & 0x0f] +\n    HEX_CHARS[h4 & 0x0f] +\n    HEX_CHARS[(h5 >>> 28) & 0x0f] +\n    HEX_CHARS[(h5 >>> 24) & 0x0f] +\n    HEX_CHARS[(h5 >>> 20) & 0x0f] +\n    HEX_CHARS[(h5 >>> 16) & 0x0f] +\n    HEX_CHARS[(h5 >>> 12) & 0x0f] +\n    HEX_CHARS[(h5 >>> 8) & 0x0f] +\n    HEX_CHARS[(h5 >>> 4) & 0x0f] +\n    HEX_CHARS[h5 & 0x0f] +\n    HEX_CHARS[(h6 >>> 28) & 0x0f] +\n    HEX_CHARS[(h6 >>> 24) & 0x0f] +\n    HEX_CHARS[(h6 >>> 20) & 0x0f] +\n    HEX_CHARS[(h6 >>> 16) & 0x0f] +\n    HEX_CHARS[(h6 >>> 12) & 0x0f] +\n    HEX_CHARS[(h6 >>> 8) & 0x0f] +\n    HEX_CHARS[(h6 >>> 4) & 0x0f] +\n    HEX_CHARS[h6 & 0x0f];\n  if (!this.is224) {\n    hex +=\n      HEX_CHARS[(h7 >>> 28) & 0x0f] +\n      HEX_CHARS[(h7 >>> 24) & 0x0f] +\n      HEX_CHARS[(h7 >>> 20) & 0x0f] +\n      HEX_CHARS[(h7 >>> 16) & 0x0f] +\n      HEX_CHARS[(h7 >>> 12) & 0x0f] +\n      HEX_CHARS[(h7 >>> 8) & 0x0f] +\n      HEX_CHARS[(h7 >>> 4) & 0x0f] +\n      HEX_CHARS[h7 & 0x0f];\n  }\n  return hex;\n};\n\nSha256.prototype.toString = Sha256.prototype.hex;\n\nSha256.prototype.digest = function () {\n  this.finalize();\n\n  var h0 = this.h0,\n    h1 = this.h1,\n    h2 = this.h2,\n    h3 = this.h3,\n    h4 = this.h4,\n    h5 = this.h5,\n    h6 = this.h6,\n    h7 = this.h7;\n\n  var arr = [\n    (h0 >>> 24) & 0xff,\n    (h0 >>> 16) & 0xff,\n    (h0 >>> 8) & 0xff,\n    h0 & 0xff,\n    (h1 >>> 24) & 0xff,\n    (h1 >>> 16) & 0xff,\n    (h1 >>> 8) & 0xff,\n    h1 & 0xff,\n    (h2 >>> 24) & 0xff,\n    (h2 >>> 16) & 0xff,\n    (h2 >>> 8) & 0xff,\n    h2 & 0xff,\n    (h3 >>> 24) & 0xff,\n    (h3 >>> 16) & 0xff,\n    (h3 >>> 8) & 0xff,\n    h3 & 0xff,\n    (h4 >>> 24) & 0xff,\n    (h4 >>> 16) & 0xff,\n    (h4 >>> 8) & 0xff,\n    h4 & 0xff,\n    (h5 >>> 24) & 0xff,\n    (h5 >>> 16) & 0xff,\n    (h5 >>> 8) & 0xff,\n    h5 & 0xff,\n    (h6 >>> 24) & 0xff,\n    (h6 >>> 16) & 0xff,\n    (h6 >>> 8) & 0xff,\n    h6 & 0xff,\n  ];\n  if (!this.is224) {\n    arr.push(\n      (h7 >>> 24) & 0xff,\n      (h7 >>> 16) & 0xff,\n      (h7 >>> 8) & 0xff,\n      h7 & 0xff\n    );\n  }\n  return arr;\n};\n\nSha256.prototype.array = Sha256.prototype.digest;\n\nSha256.prototype.arrayBuffer = function () {\n  this.finalize();\n\n  var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n  var dataView = new DataView(buffer);\n  dataView.setUint32(0, this.h0);\n  dataView.setUint32(4, this.h1);\n  dataView.setUint32(8, this.h2);\n  dataView.setUint32(12, this.h3);\n  dataView.setUint32(16, this.h4);\n  dataView.setUint32(20, this.h5);\n  dataView.setUint32(24, this.h6);\n  if (!this.is224) {\n    dataView.setUint32(28, this.h7);\n  }\n  return buffer;\n};\n\nexport const sha256 = (...strings: string[]) => {\n  return new Sha256(false, true).update(strings.join(\"\")).hex();\n};\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { sha256 } from \"./js-sha256/hash.js\";\n\n//#region src/utils/hash.ts\nvar hash_exports = {};\n__export(hash_exports, { sha256: () => sha256 });\n\n//#endregion\nexport { hash_exports, sha256 };\n//# sourceMappingURL=hash.js.map", "import { sha256, type HashKeyEncoder } from \"../utils/hash.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { mapStoredMessageToChatMessage } from \"../messages/utils.js\";\nimport { type StoredGeneration } from \"../messages/base.js\";\n\nexport const defaultHashKeyEncoder: HashKeyEncoder = (...strings) =>\n  sha256(strings.join(\"_\"));\n\nexport function deserializeStoredGeneration(\n  storedGeneration: StoredGeneration\n) {\n  if (storedGeneration.message !== undefined) {\n    return {\n      text: storedGeneration.text,\n      message: mapStoredMessageToChatMessage(storedGeneration.message),\n    };\n  } else {\n    return { text: storedGeneration.text };\n  }\n}\n\nexport function serializeGeneration(generation: Generation) {\n  const serializedValue: StoredGeneration = {\n    text: generation.text,\n  };\n  if ((generation as ChatGeneration).message !== undefined) {\n    serializedValue.message = (generation as ChatGeneration).message.toDict();\n  }\n  return serializedValue;\n}\n\n/**\n * Base class for all caches. All caches should extend this class.\n */\nexport abstract class BaseCache<T = Generation[]> {\n  protected keyEncoder: HashKeyEncoder = defaultHashKeyEncoder;\n\n  /**\n   * Sets a custom key encoder function for the cache.\n   * This function should take a prompt and an LLM key and return a string\n   * that will be used as the cache key.\n   * @param keyEncoderFn The custom key encoder function.\n   */\n  makeDefaultKeyEncoder(keyEncoderFn: HashKeyEncoder): void {\n    this.keyEncoder = keyEncoderFn;\n  }\n\n  abstract lookup(prompt: string, llmKey: string): Promise<T | null>;\n\n  abstract update(prompt: string, llmKey: string, value: T): Promise<void>;\n}\n\nconst GLOBAL_MAP = new Map();\n\n/**\n * A cache for storing LLM generations that stores data in memory.\n */\nexport class InMemoryCache<T = Generation[]> extends BaseCache<T> {\n  private cache: Map<string, T>;\n\n  constructor(map?: Map<string, T>) {\n    super();\n    this.cache = map ?? new Map();\n  }\n\n  /**\n   * Retrieves data from the cache using a prompt and an LLM key. If the\n   * data is not found, it returns null.\n   * @param prompt The prompt used to find the data.\n   * @param llmKey The LLM key used to find the data.\n   * @returns The data corresponding to the prompt and LLM key, or null if not found.\n   */\n  lookup(prompt: string, llmKey: string): Promise<T | null> {\n    return Promise.resolve(\n      this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null\n    );\n  }\n\n  /**\n   * Updates the cache with new data using a prompt and an LLM key.\n   * @param prompt The prompt used to store the data.\n   * @param llmKey The LLM key used to store the data.\n   * @param value The data to be stored.\n   */\n  async update(prompt: string, llmKey: string, value: T): Promise<void> {\n    this.cache.set(this.keyEncoder(prompt, llmKey), value);\n  }\n\n  /**\n   * Returns a global instance of InMemoryCache using a predefined global\n   * map as the initial cache.\n   * @returns A global instance of InMemoryCache.\n   */\n  static global(): InMemoryCache {\n    return new InMemoryCache(GLOBAL_MAP);\n  }\n}\n", "import base64 from 'base64-js';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/utils.ts\nfunction never(_) {\n}\nfunction bytePairMerge(piece, ranks) {\n  let parts = Array.from(\n    { length: piece.length },\n    (_, i) => ({ start: i, end: i + 1 })\n  );\n  while (parts.length > 1) {\n    let minRank = null;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const slice = piece.slice(parts[i].start, parts[i + 1].end);\n      const rank = ranks.get(slice.join(\",\"));\n      if (rank == null)\n        continue;\n      if (minRank == null || rank < minRank[0]) {\n        minRank = [rank, i];\n      }\n    }\n    if (minRank != null) {\n      const i = minRank[1];\n      parts[i] = { start: parts[i].start, end: parts[i + 1].end };\n      parts.splice(i + 1, 1);\n    } else {\n      break;\n    }\n  }\n  return parts;\n}\nfunction bytePairEncode(piece, ranks) {\n  if (piece.length === 1)\n    return [ranks.get(piece.join(\",\"))];\n  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(\",\"))).filter((x) => x != null);\n}\nfunction escapeRegex(str) {\n  return str.replace(/[\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nvar _Tiktoken = class {\n  /** @internal */\n  specialTokens;\n  /** @internal */\n  inverseSpecialTokens;\n  /** @internal */\n  patStr;\n  /** @internal */\n  textEncoder = new TextEncoder();\n  /** @internal */\n  textDecoder = new TextDecoder(\"utf-8\");\n  /** @internal */\n  rankMap = /* @__PURE__ */ new Map();\n  /** @internal */\n  textMap = /* @__PURE__ */ new Map();\n  constructor(ranks, extendedSpecialTokens) {\n    this.patStr = ranks.pat_str;\n    const uncompressed = ranks.bpe_ranks.split(\"\\n\").filter(Boolean).reduce((memo, x) => {\n      const [_, offsetStr, ...tokens] = x.split(\" \");\n      const offset = Number.parseInt(offsetStr, 10);\n      tokens.forEach((token, i) => memo[token] = offset + i);\n      return memo;\n    }, {});\n    for (const [token, rank] of Object.entries(uncompressed)) {\n      const bytes = base64.toByteArray(token);\n      this.rankMap.set(bytes.join(\",\"), rank);\n      this.textMap.set(rank, bytes);\n    }\n    this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };\n    this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {\n      memo[rank] = this.textEncoder.encode(text);\n      return memo;\n    }, {});\n  }\n  encode(text, allowedSpecial = [], disallowedSpecial = \"all\") {\n    const regexes = new RegExp(this.patStr, \"ug\");\n    const specialRegex = _Tiktoken.specialTokenRegex(\n      Object.keys(this.specialTokens)\n    );\n    const ret = [];\n    const allowedSpecialSet = new Set(\n      allowedSpecial === \"all\" ? Object.keys(this.specialTokens) : allowedSpecial\n    );\n    const disallowedSpecialSet = new Set(\n      disallowedSpecial === \"all\" ? Object.keys(this.specialTokens).filter(\n        (x) => !allowedSpecialSet.has(x)\n      ) : disallowedSpecial\n    );\n    if (disallowedSpecialSet.size > 0) {\n      const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([\n        ...disallowedSpecialSet\n      ]);\n      const specialMatch = text.match(disallowedSpecialRegex);\n      if (specialMatch != null) {\n        throw new Error(\n          `The text contains a special token that is not allowed: ${specialMatch[0]}`\n        );\n      }\n    }\n    let start = 0;\n    while (true) {\n      let nextSpecial = null;\n      let startFind = start;\n      while (true) {\n        specialRegex.lastIndex = startFind;\n        nextSpecial = specialRegex.exec(text);\n        if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))\n          break;\n        startFind = nextSpecial.index + 1;\n      }\n      const end = nextSpecial?.index ?? text.length;\n      for (const match of text.substring(start, end).matchAll(regexes)) {\n        const piece = this.textEncoder.encode(match[0]);\n        const token2 = this.rankMap.get(piece.join(\",\"));\n        if (token2 != null) {\n          ret.push(token2);\n          continue;\n        }\n        ret.push(...bytePairEncode(piece, this.rankMap));\n      }\n      if (nextSpecial == null)\n        break;\n      let token = this.specialTokens[nextSpecial[0]];\n      ret.push(token);\n      start = nextSpecial.index + nextSpecial[0].length;\n    }\n    return ret;\n  }\n  decode(tokens) {\n    const res = [];\n    let length = 0;\n    for (let i2 = 0; i2 < tokens.length; ++i2) {\n      const token = tokens[i2];\n      const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];\n      if (bytes != null) {\n        res.push(bytes);\n        length += bytes.length;\n      }\n    }\n    const mergedArray = new Uint8Array(length);\n    let i = 0;\n    for (const bytes of res) {\n      mergedArray.set(bytes, i);\n      i += bytes.length;\n    }\n    return this.textDecoder.decode(mergedArray);\n  }\n};\nvar Tiktoken = _Tiktoken;\n__publicField(Tiktoken, \"specialTokenRegex\", (tokens) => {\n  return new RegExp(tokens.map((i) => escapeRegex(i)).join(\"|\"), \"g\");\n});\nfunction getEncodingNameForModel(model) {\n  switch (model) {\n    case \"gpt2\": {\n      return \"gpt2\";\n    }\n    case \"code-cushman-001\":\n    case \"code-cushman-002\":\n    case \"code-davinci-001\":\n    case \"code-davinci-002\":\n    case \"cushman-codex\":\n    case \"davinci-codex\":\n    case \"davinci-002\":\n    case \"text-davinci-002\":\n    case \"text-davinci-003\": {\n      return \"p50k_base\";\n    }\n    case \"code-davinci-edit-001\":\n    case \"text-davinci-edit-001\": {\n      return \"p50k_edit\";\n    }\n    case \"ada\":\n    case \"babbage\":\n    case \"babbage-002\":\n    case \"code-search-ada-code-001\":\n    case \"code-search-babbage-code-001\":\n    case \"curie\":\n    case \"davinci\":\n    case \"text-ada-001\":\n    case \"text-babbage-001\":\n    case \"text-curie-001\":\n    case \"text-davinci-001\":\n    case \"text-search-ada-doc-001\":\n    case \"text-search-babbage-doc-001\":\n    case \"text-search-curie-doc-001\":\n    case \"text-search-davinci-doc-001\":\n    case \"text-similarity-ada-001\":\n    case \"text-similarity-babbage-001\":\n    case \"text-similarity-curie-001\":\n    case \"text-similarity-davinci-001\": {\n      return \"r50k_base\";\n    }\n    case \"gpt-3.5-turbo-instruct-0914\":\n    case \"gpt-3.5-turbo-instruct\":\n    case \"gpt-3.5-turbo-16k-0613\":\n    case \"gpt-3.5-turbo-16k\":\n    case \"gpt-3.5-turbo-0613\":\n    case \"gpt-3.5-turbo-0301\":\n    case \"gpt-3.5-turbo\":\n    case \"gpt-4-32k-0613\":\n    case \"gpt-4-32k-0314\":\n    case \"gpt-4-32k\":\n    case \"gpt-4-0613\":\n    case \"gpt-4-0314\":\n    case \"gpt-4\":\n    case \"gpt-3.5-turbo-1106\":\n    case \"gpt-35-turbo\":\n    case \"gpt-4-1106-preview\":\n    case \"gpt-4-vision-preview\":\n    case \"gpt-3.5-turbo-0125\":\n    case \"gpt-4-turbo\":\n    case \"gpt-4-turbo-2024-04-09\":\n    case \"gpt-4-turbo-preview\":\n    case \"gpt-4-0125-preview\":\n    case \"text-embedding-ada-002\":\n    case \"text-embedding-3-small\":\n    case \"text-embedding-3-large\": {\n      return \"cl100k_base\";\n    }\n    case \"gpt-4o\":\n    case \"gpt-4o-2024-05-13\":\n    case \"gpt-4o-2024-08-06\":\n    case \"gpt-4o-2024-11-20\":\n    case \"gpt-4o-mini-2024-07-18\":\n    case \"gpt-4o-mini\":\n    case \"gpt-4o-search-preview\":\n    case \"gpt-4o-search-preview-2025-03-11\":\n    case \"gpt-4o-mini-search-preview\":\n    case \"gpt-4o-mini-search-preview-2025-03-11\":\n    case \"gpt-4o-audio-preview\":\n    case \"gpt-4o-audio-preview-2024-12-17\":\n    case \"gpt-4o-audio-preview-2024-10-01\":\n    case \"gpt-4o-mini-audio-preview\":\n    case \"gpt-4o-mini-audio-preview-2024-12-17\":\n    case \"o1\":\n    case \"o1-2024-12-17\":\n    case \"o1-mini\":\n    case \"o1-mini-2024-09-12\":\n    case \"o1-preview\":\n    case \"o1-preview-2024-09-12\":\n    case \"o1-pro\":\n    case \"o1-pro-2025-03-19\":\n    case \"o3\":\n    case \"o3-2025-04-16\":\n    case \"o3-mini\":\n    case \"o3-mini-2025-01-31\":\n    case \"o4-mini\":\n    case \"o4-mini-2025-04-16\":\n    case \"chatgpt-4o-latest\":\n    case \"gpt-4o-realtime\":\n    case \"gpt-4o-realtime-preview-2024-10-01\":\n    case \"gpt-4o-realtime-preview-2024-12-17\":\n    case \"gpt-4o-mini-realtime-preview\":\n    case \"gpt-4o-mini-realtime-preview-2024-12-17\":\n    case \"gpt-4.1\":\n    case \"gpt-4.1-2025-04-14\":\n    case \"gpt-4.1-mini\":\n    case \"gpt-4.1-mini-2025-04-14\":\n    case \"gpt-4.1-nano\":\n    case \"gpt-4.1-nano-2025-04-14\":\n    case \"gpt-4.5-preview\":\n    case \"gpt-4.5-preview-2025-02-27\":\n    case \"gpt-5\":\n    case \"gpt-5-2025-08-07\":\n    case \"gpt-5-nano\":\n    case \"gpt-5-nano-2025-08-07\":\n    case \"gpt-5-mini\":\n    case \"gpt-5-mini-2025-08-07\":\n    case \"gpt-5-chat-latest\": {\n      return \"o200k_base\";\n    }\n    default:\n      throw new Error(\"Unknown model\");\n  }\n}\n\nexport { Tiktoken, getEncodingNameForModel, never };\n", "import {\n  Tiktoken,\n  TiktokenEncoding,\n  TiktokenModel,\n  getEncodingNameForModel,\n} from \"js-tiktoken/lite\";\nimport { AsyncCaller } from \"./async_caller.js\";\n\nconst cache: Record<string, Promise<Tiktoken>> = {};\n\nconst caller = /* #__PURE__ */ new AsyncCaller({});\n\nexport async function getEncoding(encoding: TiktokenEncoding) {\n  if (!(encoding in cache)) {\n    cache[encoding] = caller\n      .fetch(`https://tiktoken.pages.dev/js/${encoding}.json`)\n      .then((res) => res.json())\n      .then((data) => new Tiktoken(data))\n      .catch((e) => {\n        delete cache[encoding];\n        throw e;\n      });\n  }\n\n  return await cache[encoding];\n}\n\nexport async function encodingForModel(model: TiktokenModel) {\n  return getEncoding(getEncodingNameForModel(model));\n}\n", "import type { Tiktoken, TiktokenModel } from \"js-tiktoken/lite\";\nimport type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\n\nimport { type BaseCache, InMemoryCache } from \"../caches/index.js\";\nimport {\n  type BasePromptValueInterface,\n  StringPromptValue,\n  ChatPromptValue,\n} from \"../prompt_values.js\";\nimport {\n  type BaseMessage,\n  type BaseMessageLike,\n  type MessageContent,\n} from \"../messages/base.js\";\nimport { coerceMessageLikeToMessage } from \"../messages/utils.js\";\nimport { type LLMResult } from \"../outputs.js\";\nimport { CallbackManager, Callbacks } from \"../callbacks/manager.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"../utils/async_caller.js\";\nimport { encodingForModel } from \"../utils/tiktoken.js\";\nimport { Runnable, type RunnableInterface } from \"../runnables/base.js\";\nimport { RunnableConfig } from \"../runnables/config.js\";\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport {\n  InferInteropZodOutput,\n  InteropZodObject,\n  InteropZodType,\n} from \"../utils/types/zod.js\";\nimport { ModelProfile } from \"./profile.js\";\n\n// https://www.npmjs.com/package/js-tiktoken\n\nexport const getModelNameForTiktoken = (modelName: string): TiktokenModel => {\n  if (modelName.startsWith(\"gpt-5\")) {\n    return \"gpt-5\" as TiktokenModel;\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n    return \"gpt-3.5-turbo-16k\";\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n    return \"gpt-3.5-turbo\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-32k\")) {\n    return \"gpt-4-32k\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-\")) {\n    return \"gpt-4\";\n  }\n\n  if (modelName.startsWith(\"gpt-4o\")) {\n    return \"gpt-4o\";\n  }\n\n  return modelName as TiktokenModel;\n};\n\nexport const getEmbeddingContextSize = (modelName?: string): number => {\n  switch (modelName) {\n    case \"text-embedding-ada-002\":\n      return 8191;\n    default:\n      return 2046;\n  }\n};\n\n/**\n * Get the context window size (max input tokens) for a given model.\n *\n * Context window sizes are sourced from official model documentation:\n * - OpenAI: https://platform.openai.com/docs/models\n * - Anthropic: https://docs.anthropic.com/claude/docs/models-overview\n * - Google: https://ai.google.dev/gemini/docs/models/gemini\n *\n * @param modelName - The name of the model\n * @returns The context window size in tokens\n */\nexport const getModelContextSize = (modelName: string): number => {\n  const normalizedName = getModelNameForTiktoken(modelName) as string;\n\n  switch (normalizedName) {\n    // GPT-5 series\n    case \"gpt-5\":\n    case \"gpt-5-turbo\":\n    case \"gpt-5-turbo-preview\":\n      return 400000;\n\n    // GPT-4o series\n    case \"gpt-4o\":\n    case \"gpt-4o-mini\":\n    case \"gpt-4o-2024-05-13\":\n    case \"gpt-4o-2024-08-06\":\n      return 128000;\n\n    // GPT-4 Turbo series\n    case \"gpt-4-turbo\":\n    case \"gpt-4-turbo-preview\":\n    case \"gpt-4-turbo-2024-04-09\":\n    case \"gpt-4-0125-preview\":\n    case \"gpt-4-1106-preview\":\n      return 128000;\n\n    // GPT-4 series\n    case \"gpt-4-32k\":\n    case \"gpt-4-32k-0314\":\n    case \"gpt-4-32k-0613\":\n      return 32768;\n    case \"gpt-4\":\n    case \"gpt-4-0314\":\n    case \"gpt-4-0613\":\n      return 8192;\n\n    // GPT-3.5 Turbo series\n    case \"gpt-3.5-turbo-16k\":\n    case \"gpt-3.5-turbo-16k-0613\":\n      return 16384;\n    case \"gpt-3.5-turbo\":\n    case \"gpt-3.5-turbo-0301\":\n    case \"gpt-3.5-turbo-0613\":\n    case \"gpt-3.5-turbo-1106\":\n    case \"gpt-3.5-turbo-0125\":\n      return 4096;\n\n    // Legacy GPT-3 models\n    case \"text-davinci-003\":\n    case \"text-davinci-002\":\n      return 4097;\n    case \"text-davinci-001\":\n      return 2049;\n    case \"text-curie-001\":\n    case \"text-babbage-001\":\n    case \"text-ada-001\":\n      return 2048;\n\n    // Code models\n    case \"code-davinci-002\":\n    case \"code-davinci-001\":\n      return 8000;\n    case \"code-cushman-001\":\n      return 2048;\n\n    // Claude models (Anthropic)\n    case \"claude-3-5-sonnet-20241022\":\n    case \"claude-3-5-sonnet-20240620\":\n    case \"claude-3-opus-20240229\":\n    case \"claude-3-sonnet-20240229\":\n    case \"claude-3-haiku-20240307\":\n    case \"claude-2.1\":\n      return 200000;\n    case \"claude-2.0\":\n    case \"claude-instant-1.2\":\n      return 100000;\n\n    // Gemini models (Google)\n    case \"gemini-1.5-pro\":\n    case \"gemini-1.5-pro-latest\":\n    case \"gemini-1.5-flash\":\n    case \"gemini-1.5-flash-latest\":\n      return 1000000; // 1M tokens\n    case \"gemini-pro\":\n    case \"gemini-pro-vision\":\n      return 32768;\n\n    default:\n      return 4097;\n  }\n};\n\n/**\n * Whether or not the input matches the OpenAI tool definition.\n * @param {unknown} tool The input to check.\n * @returns {boolean} Whether the input is an OpenAI tool definition.\n */\nexport function isOpenAITool(tool: unknown): tool is ToolDefinition {\n  if (typeof tool !== \"object\" || !tool) return false;\n  if (\n    \"type\" in tool &&\n    tool.type === \"function\" &&\n    \"function\" in tool &&\n    typeof tool.function === \"object\" &&\n    tool.function &&\n    \"name\" in tool.function &&\n    \"parameters\" in tool.function\n  ) {\n    return true;\n  }\n  return false;\n}\n\ninterface CalculateMaxTokenProps {\n  prompt: string;\n  modelName: TiktokenModel;\n}\n\nexport const calculateMaxTokens = async ({\n  prompt,\n  modelName,\n}: CalculateMaxTokenProps) => {\n  let numTokens;\n\n  try {\n    numTokens = (\n      await encodingForModel(getModelNameForTiktoken(modelName))\n    ).encode(prompt).length;\n  } catch {\n    console.warn(\n      \"Failed to calculate number of tokens, falling back to approximate count\"\n    );\n\n    // fallback to approximate calculation if tiktoken is not available\n    // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n    numTokens = Math.ceil(prompt.length / 4);\n  }\n\n  const maxTokens = getModelContextSize(modelName);\n  return maxTokens - numTokens;\n};\n\nconst getVerbosity = () => false;\n\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport interface BaseLangChainParams {\n  verbose?: boolean;\n  callbacks?: Callbacks;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Base class for language models, chains, tools.\n */\nexport abstract class BaseLangChain<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig,\n  >\n  extends Runnable<RunInput, RunOutput, CallOptions>\n  implements BaseLangChainParams\n{\n  /**\n   * Whether to print out response text.\n   */\n  verbose: boolean;\n\n  callbacks?: Callbacks;\n\n  tags?: string[];\n\n  metadata?: Record<string, unknown>;\n\n  get lc_attributes(): { [key: string]: undefined } | undefined {\n    return {\n      callbacks: undefined,\n      verbose: undefined,\n    };\n  }\n\n  constructor(params: BaseLangChainParams) {\n    super(params);\n    this.verbose = params.verbose ?? getVerbosity();\n    this.callbacks = params.callbacks;\n    this.tags = params.tags ?? [];\n    this.metadata = params.metadata ?? {};\n  }\n}\n\n/**\n * Base interface for language model parameters.\n * A subclass of {@link BaseLanguageModel} should have a constructor that\n * takes in a parameter that extends this interface.\n */\nexport interface BaseLanguageModelParams\n  extends AsyncCallerParams,\n    BaseLangChainParams {\n  /**\n   * @deprecated Use `callbacks` instead\n   */\n  callbackManager?: CallbackManager;\n\n  cache?: BaseCache | boolean;\n}\n\nexport interface BaseLanguageModelTracingCallOptions {\n  /**\n   * Describes the format of structured outputs.\n   * This should be provided if an output is considered to be structured\n   */\n  ls_structured_output_format?: {\n    /**\n     * An object containing the method used for structured output (e.g., \"jsonMode\").\n     */\n    kwargs: { method: string };\n    /**\n     * The JSON schema describing the expected output structure.\n     */\n    schema?: JSONSchema;\n  };\n}\n\nexport interface BaseLanguageModelCallOptions\n  extends RunnableConfig,\n    BaseLanguageModelTracingCallOptions {\n  /**\n   * Stop tokens to use for this call.\n   * If not provided, the default stop tokens for the model will be used.\n   */\n  stop?: string[];\n}\n\nexport interface FunctionDefinition {\n  /**\n   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain\n   * underscores and dashes, with a maximum length of 64.\n   */\n  name: string;\n\n  /**\n   * The parameters the functions accepts, described as a JSON Schema object. See the\n   * [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for\n   * examples, and the\n   * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\n   * documentation about the format.\n   *\n   * To describe a function that accepts no parameters, provide the value\n   * `{\"type\": \"object\", \"properties\": {}}`.\n   */\n  parameters: Record<string, unknown> | JSONSchema;\n\n  /**\n   * A description of what the function does, used by the model to choose when and\n   * how to call the function.\n   */\n  description?: string;\n}\n\nexport interface ToolDefinition {\n  type: \"function\";\n  function: FunctionDefinition;\n}\n\nexport type FunctionCallOption = {\n  name: string;\n};\n\nexport interface BaseFunctionCallOptions extends BaseLanguageModelCallOptions {\n  function_call?: FunctionCallOption;\n  functions?: FunctionDefinition[];\n}\n\nexport type BaseLanguageModelInput =\n  | BasePromptValueInterface\n  | string\n  | BaseMessageLike[];\n\nexport type StructuredOutputType = InferInteropZodOutput<InteropZodObject>;\n\nexport type StructuredOutputMethodOptions<IncludeRaw extends boolean = false> =\n  {\n    name?: string;\n    method?: \"functionCalling\" | \"jsonMode\" | \"jsonSchema\" | string;\n    includeRaw?: IncludeRaw;\n    /** Whether to use strict mode. Currently only supported by OpenAI models. */\n    strict?: boolean;\n  };\n\n/** @deprecated Use StructuredOutputMethodOptions instead */\nexport type StructuredOutputMethodParams<\n  RunOutput,\n  IncludeRaw extends boolean = false,\n> = {\n  /** @deprecated Pass schema in as the first argument */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: InteropZodType<RunOutput> | Record<string, any>;\n  name?: string;\n  method?: \"functionCalling\" | \"jsonMode\";\n  includeRaw?: IncludeRaw;\n};\n\nexport interface BaseLanguageModelInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends\n    BaseLanguageModelCallOptions = BaseLanguageModelCallOptions,\n> extends RunnableInterface<BaseLanguageModelInput, RunOutput, CallOptions> {\n  get callKeys(): string[];\n\n  generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  _modelType(): string;\n\n  _llmType(): string;\n\n  getNumTokens(content: MessageContent): Promise<number>;\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any>;\n\n  serialize(): SerializedLLM;\n}\n\nexport type LanguageModelOutput = BaseMessage | string;\n\nexport type LanguageModelLike = Runnable<\n  BaseLanguageModelInput,\n  LanguageModelOutput\n>;\n\n/**\n * Base class for language models.\n */\nexport abstract class BaseLanguageModel<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput = any,\n    CallOptions extends\n      BaseLanguageModelCallOptions = BaseLanguageModelCallOptions,\n  >\n  extends BaseLangChain<BaseLanguageModelInput, RunOutput, CallOptions>\n  implements\n    BaseLanguageModelParams,\n    BaseLanguageModelInterface<RunOutput, CallOptions>\n{\n  /**\n   * Keys that the language model accepts as call options.\n   */\n  get callKeys(): string[] {\n    return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n  }\n\n  /**\n   * The async caller should be used by subclasses to make any async calls,\n   * which will thus benefit from the concurrency and retry logic.\n   */\n  caller: AsyncCaller;\n\n  cache?: BaseCache;\n\n  constructor({\n    callbacks,\n    callbackManager,\n    ...params\n  }: BaseLanguageModelParams) {\n    const { cache, ...rest } = params;\n    super({\n      callbacks: callbacks ?? callbackManager,\n      ...rest,\n    });\n    if (typeof cache === \"object\") {\n      this.cache = cache;\n    } else if (cache) {\n      this.cache = InMemoryCache.global();\n    } else {\n      this.cache = undefined;\n    }\n    this.caller = new AsyncCaller(params ?? {});\n  }\n\n  abstract generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  abstract _modelType(): string;\n\n  abstract _llmType(): string;\n\n  private _encoding?: Tiktoken;\n\n  /**\n   * Get the number of tokens in the content.\n   * @param content The content to get the number of tokens for.\n   * @returns The number of tokens in the content.\n   */\n  async getNumTokens(content: MessageContent) {\n    // Extract text content from MessageContent\n    let textContent: string;\n    if (typeof content === \"string\") {\n      textContent = content;\n    } else {\n      /**\n       * Content is an array of ContentBlock\n       *\n       * ToDo(@christian-bromann): This is a temporary fix to get the number of tokens for the content.\n       * We need to find a better way to do this.\n       * @see https://github.com/langchain-ai/langchainjs/pull/8341#pullrequestreview-2933713116\n       */\n      textContent = content\n        .map((item) => {\n          if (typeof item === \"string\") return item;\n          if (item.type === \"text\" && \"text\" in item) return item.text;\n          return \"\";\n        })\n        .join(\"\");\n    }\n\n    // fallback to approximate calculation if tiktoken is not available\n    let numTokens = Math.ceil(textContent.length / 4);\n\n    if (!this._encoding) {\n      try {\n        this._encoding = await encodingForModel(\n          \"modelName\" in this\n            ? getModelNameForTiktoken(this.modelName as string)\n            : \"gpt2\"\n        );\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    if (this._encoding) {\n      try {\n        numTokens = this._encoding.encode(textContent).length;\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    return numTokens;\n  }\n\n  protected static _convertInputToPromptValue(\n    input: BaseLanguageModelInput\n  ): BasePromptValueInterface {\n    if (typeof input === \"string\") {\n      return new StringPromptValue(input);\n    } else if (Array.isArray(input)) {\n      return new ChatPromptValue(input.map(coerceMessageLikeToMessage));\n    } else {\n      return input;\n    }\n  }\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any> {\n    return {};\n  }\n\n  /**\n   * Create a unique cache key for a specific call to a specific language model.\n   * @param callOptions Call options for the model\n   * @returns A unique cache key.\n   */\n  _getSerializedCacheKeyParametersForCall(\n    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n    { config, ...callOptions }: CallOptions & { config?: RunnableConfig }\n  ): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const params: Record<string, any> = {\n      ...this._identifyingParams(),\n      ...callOptions,\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n    const filteredEntries = Object.entries(params).filter(\n      ([_, value]) => value !== undefined\n    );\n    const serializedEntries = filteredEntries\n      .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n      .sort()\n      .join(\",\");\n    return serializedEntries;\n  }\n\n  /**\n   * @deprecated\n   * Return a json-like object representing this LLM.\n   */\n  serialize(): SerializedLLM {\n    return {\n      ...this._identifyingParams(),\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n  }\n\n  /**\n   * @deprecated\n   * Load an LLM from a json-like object describing it.\n   */\n  static async deserialize(_data: SerializedLLM): Promise<BaseLanguageModel> {\n    throw new Error(\"Use .toJSON() instead\");\n  }\n\n  /**\n   * Return profiling information for the model.\n   *\n   * @returns {ModelProfile} An object describing the model's capabilities and constraints\n   */\n  get profile(): ModelProfile {\n    return {};\n  }\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  /**\n   * Model wrapper that returns outputs formatted to match the given schema.\n   *\n   * @template {BaseLanguageModelInput} RunInput The input type for the Runnable, expected to be the same input for the LLM.\n   * @template {Record<string, any>} RunOutput The output type for the Runnable, expected to be a Zod schema object for structured output validation.\n   *\n   * @param {InteropZodType<RunOutput>} schema The schema for the structured output. Either as a Zod schema or a valid JSON schema object.\n   *   If a Zod schema is passed, the returned attributes will be validated, whereas with JSON schema they will not be.\n   * @param {string} name The name of the function to call.\n   * @param {\"functionCalling\" | \"jsonMode\"} [method=functionCalling] The method to use for getting the structured output. Defaults to \"functionCalling\".\n   * @param {boolean | undefined} [includeRaw=false] Whether to include the raw output in the result. Defaults to false.\n   * @returns {Runnable<RunInput, RunOutput> | Runnable<RunInput, { raw: BaseMessage; parsed: RunOutput }>} A new runnable that calls the LLM with structured output.\n   */\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    schema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      >;\n}\n\n/**\n * Shared interface for token usage\n * return type from LLM calls.\n */\nexport interface TokenUsage {\n  completionTokens?: number;\n  promptTokens?: number;\n  totalTokens?: number;\n}\n", "import { concat } from \"../utils/stream.js\";\nimport {\n  Runnable,\n  RunnableAssign,\n  RunnableMap,\n  RunnableMapLike,\n} from \"./base.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RunnablePassthroughFunc<RunInput = any> =\n  | ((input: RunInput) => void)\n  | ((input: RunInput, config?: RunnableConfig) => void)\n  | ((input: RunInput) => Promise<void>)\n  | ((input: RunInput, config?: RunnableConfig) => Promise<void>);\n\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnablePassthrough<RunInput = any> extends Runnable<\n  RunInput,\n  RunInput\n> {\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  func?: RunnablePassthroughFunc<RunInput>;\n\n  constructor(fields?: { func?: RunnablePassthroughFunc<RunInput> }) {\n    super(fields);\n    if (fields) {\n      this.func = fields.func;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunInput> {\n    const config = ensureConfig(options);\n    if (this.func) {\n      await this.func(input, config);\n    }\n\n    return this._callWithConfig(\n      (input: RunInput) => Promise.resolve(input),\n      input,\n      config\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<RunnableConfig>\n  ): AsyncGenerator<RunInput> {\n    const config = ensureConfig(options);\n    let finalOutput: RunInput | undefined;\n    let finalOutputSupported = true;\n\n    for await (const chunk of this._transformStreamWithConfig(\n      generator,\n      (input: AsyncGenerator<RunInput>) => input,\n      config\n    )) {\n      yield chunk;\n      if (finalOutputSupported) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            finalOutput = concat(finalOutput, chunk as any);\n          } catch {\n            finalOutput = undefined;\n            finalOutputSupported = false;\n          }\n        }\n      }\n    }\n\n    if (this.func && finalOutput !== undefined) {\n      await this.func(finalOutput, config);\n    }\n  }\n\n  /**\n   * A runnable that assigns key-value pairs to the input.\n   *\n   * The example below shows how you could use it with an inline function.\n   *\n   * @example\n   * ```typescript\n   * const prompt =\n   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n   * Question: {question}\n   * SQL Query:`);\n   *\n   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n   * // In this case, we're passing the schema.\n   * const sqlQueryGeneratorChain = RunnableSequence.from([\n   *   RunnablePassthrough.assign({\n   *     schema: async () => db.getTableInfo(),\n   *   }),\n   *   prompt,\n   *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n   *   new StringOutputParser(),\n   * ]);\n   * const result = await sqlQueryGeneratorChain.invoke({\n   *   question: \"How many employees are there?\",\n   * });\n   * ```\n   */\n  static assign<\n    RunInput extends Record<string, unknown> = Record<string, unknown>,\n    RunOutput extends Record<string, unknown> = Record<string, unknown>,\n  >(\n    mapping: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableAssign<RunInput, RunInput & RunOutput> {\n    return new RunnableAssign(new RunnableMap({ steps: mapping }));\n  }\n}\n", "import { BaseMessage } from \"../messages/base.js\";\n\ntype Constructor<T> = new (...args: unknown[]) => T;\n\nexport const iife = <T>(fn: () => T): T => fn();\n\nfunction castStandardMessageContent<T extends BaseMessage>(message: T) {\n  const Cls = message.constructor as Constructor<T>;\n  return new Cls({\n    ...message,\n    content: message.contentBlocks,\n    response_metadata: {\n      ...message.response_metadata,\n      output_version: \"v1\",\n    },\n  });\n}\n\nexport { castStandardMessageContent };\n", "import type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\nimport {\n  AIMessage,\n  type BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageLike,\n  coerceMessageLikeToMessage,\n  AIMessageChunk,\n  isAIMessageChunk,\n  isBaseMessage,\n  isAIMessage,\n  MessageOutputVersion,\n} from \"../messages/index.js\";\nimport {\n  convertToOpenAIImageBlock,\n  isURLContentBlock,\n  isBase64ContentBlock,\n} from \"../messages/content/data.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport {\n  LLMResult,\n  RUN_KEY,\n  type ChatGeneration,\n  ChatGenerationChunk,\n  type ChatResult,\n  type Generation,\n} from \"../outputs.js\";\nimport {\n  BaseLanguageModel,\n  type StructuredOutputMethodOptions,\n  type ToolDefinition,\n  type BaseLanguageModelCallOptions,\n  type BaseLanguageModelInput,\n  type BaseLanguageModelParams,\n} from \"./base.js\";\nimport {\n  CallbackManager,\n  type CallbackManagerForLLMRun,\n  type Callbacks,\n} from \"../callbacks/manager.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BaseCache } from \"../caches/index.js\";\nimport {\n  StructuredToolInterface,\n  StructuredToolParams,\n} from \"../tools/index.js\";\nimport {\n  Runnable,\n  RunnableLambda,\n  RunnableSequence,\n  RunnableToolLike,\n} from \"../runnables/base.js\";\nimport { concat } from \"../utils/stream.js\";\nimport { RunnablePassthrough } from \"../runnables/passthrough.js\";\nimport {\n  getSchemaDescription,\n  InteropZodType,\n  isInteropZodSchema,\n} from \"../utils/types/zod.js\";\nimport { callbackHandlerPrefersStreaming } from \"../callbacks/base.js\";\nimport { toJsonSchema } from \"../utils/json_schema.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { castStandardMessageContent, iife } from \"./utils.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolChoice = string | Record<string, any> | \"auto\" | \"any\";\n\n/**\n * Represents a serialized chat model.\n */\nexport type SerializedChatModel = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n// todo?\n/**\n * Represents a serialized large language model.\n */\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n/**\n * Represents the parameters for a base chat model.\n */\nexport type BaseChatModelParams = BaseLanguageModelParams & {\n  /**\n   * Whether to disable streaming.\n   *\n   * If streaming is bypassed, then `stream()` will defer to\n   * `invoke()`.\n   *\n   * - If true, will always bypass streaming case.\n   * - If false (default), will always use streaming case if available.\n   */\n  disableStreaming?: boolean;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\n/**\n * Represents the call options for a base chat model.\n */\nexport type BaseChatModelCallOptions = BaseLanguageModelCallOptions & {\n  /**\n   * Specifies how the chat model should use tools.\n   * @default undefined\n   *\n   * Possible values:\n   * - \"auto\": The model may choose to use any of the provided tools, or none.\n   * - \"any\": The model must use one of the provided tools.\n   * - \"none\": The model must not use any tools.\n   * - A string (not \"auto\", \"any\", or \"none\"): The name of a specific tool the model must use.\n   * - An object: A custom schema specifying tool choice parameters. Specific to the provider.\n   *\n   * Note: Not all providers support tool_choice. An error will be thrown\n   * if used with an unsupported model.\n   */\n  tool_choice?: ToolChoice;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\nfunction _formatForTracing(messages: BaseMessage[]): BaseMessage[] {\n  const messagesToTrace: BaseMessage[] = [];\n  for (const message of messages) {\n    let messageToTrace = message;\n    if (Array.isArray(message.content)) {\n      for (let idx = 0; idx < message.content.length; idx++) {\n        const block = message.content[idx];\n        if (isURLContentBlock(block) || isBase64ContentBlock(block)) {\n          if (messageToTrace === message) {\n            // Also shallow-copy content\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            messageToTrace = new (message.constructor as any)({\n              ...messageToTrace,\n              content: [\n                ...message.content.slice(0, idx),\n                convertToOpenAIImageBlock(block),\n                ...message.content.slice(idx + 1),\n              ],\n            });\n          }\n        }\n      }\n    }\n    messagesToTrace.push(messageToTrace);\n  }\n  return messagesToTrace;\n}\n\nexport type LangSmithParams = {\n  ls_provider?: string;\n  ls_model_name?: string;\n  ls_model_type: \"chat\";\n  ls_temperature?: number;\n  ls_max_tokens?: number;\n  ls_stop?: Array<string>;\n};\n\nexport type BindToolsInput =\n  | StructuredToolInterface\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | Record<string, any>\n  | ToolDefinition\n  | RunnableToolLike\n  | StructuredToolParams;\n\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nexport abstract class BaseChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions,\n  // TODO: Fix the parameter order on the next minor version.\n  OutputMessageType extends BaseMessageChunk = AIMessageChunk,\n> extends BaseLanguageModel<OutputMessageType, CallOptions> {\n  // Backwards compatibility since fields have been moved to RunnableConfig\n  declare ParsedCallOptions: Omit<\n    CallOptions,\n    Exclude<keyof RunnableConfig, \"signal\" | \"timeout\" | \"maxConcurrency\">\n  >;\n\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"chat_models\", this._llmType()];\n\n  disableStreaming = false;\n\n  outputVersion?: MessageOutputVersion;\n\n  get callKeys(): string[] {\n    return [...super.callKeys, \"outputVersion\"];\n  }\n\n  constructor(fields: BaseChatModelParams) {\n    super(fields);\n    this.outputVersion = iife(() => {\n      const outputVersion =\n        fields.outputVersion ?? getEnvironmentVariable(\"LC_OUTPUT_VERSION\");\n      if (outputVersion && [\"v0\", \"v1\"].includes(outputVersion)) {\n        return outputVersion as \"v0\" | \"v1\";\n      }\n      return \"v0\";\n    });\n  }\n\n  _combineLLMOutput?(\n    ...llmOutputs: LLMResult[\"llmOutput\"][]\n  ): LLMResult[\"llmOutput\"];\n\n  protected _separateRunnableConfigFromCallOptionsCompat(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, this[\"ParsedCallOptions\"]] {\n    // For backwards compat, keep `signal` in both runnableConfig and callOptions\n    const [runnableConfig, callOptions] =\n      super._separateRunnableConfigFromCallOptions(options);\n    (callOptions as this[\"ParsedCallOptions\"]).signal = runnableConfig.signal;\n    return [runnableConfig, callOptions as this[\"ParsedCallOptions\"]];\n  }\n\n  /**\n   * Bind tool-like objects to this chat model.\n   *\n   * @param tools A list of tool definitions to bind to this chat model.\n   * Can be a structured tool, an OpenAI formatted tool, or an object\n   * matching the provider's specific tool schema.\n   * @param kwargs Any additional parameters to bind.\n   */\n  bindTools?(\n    tools: BindToolsInput[],\n    kwargs?: Partial<CallOptions>\n  ): Runnable<BaseLanguageModelInput, OutputMessageType, CallOptions>;\n\n  /**\n   * Invokes the chat model with a single input.\n   * @param input The input for the language model.\n   * @param options The call options.\n   * @returns A Promise that resolves to a BaseMessageChunk.\n   */\n  async invoke(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): Promise<OutputMessageType> {\n    const promptValue = BaseChatModel._convertInputToPromptValue(input);\n    const result = await this.generatePrompt(\n      [promptValue],\n      options,\n      options?.callbacks\n    );\n    const chatGeneration = result.generations[0][0] as ChatGeneration;\n    // TODO: Remove cast after figuring out inheritance\n    return chatGeneration.message as OutputMessageType;\n  }\n\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(\n    _messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async *_streamIterator(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): AsyncGenerator<OutputMessageType> {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (\n      this._streamResponseChunks ===\n        BaseChatModel.prototype._streamResponseChunks ||\n      this.disableStreaming\n    ) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseChatModel._convertInputToPromptValue(input);\n      const messages = prompt.toChatMessages();\n      const [runnableConfig, callOptions] =\n        this._separateRunnableConfigFromCallOptionsCompat(options);\n\n      const inheritableMetadata = {\n        ...runnableConfig.metadata,\n        ...this.getLsParams(callOptions),\n      };\n      const callbackManager_ = await CallbackManager.configure(\n        runnableConfig.callbacks,\n        this.callbacks,\n        runnableConfig.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1,\n      };\n      const outputVersion = callOptions.outputVersion ?? this.outputVersion;\n      const runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        [_formatForTracing(messages)],\n        runnableConfig.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        runnableConfig.runName\n      );\n      let generationChunk: ChatGenerationChunk | undefined;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let llmOutput: Record<string, any> | undefined;\n      try {\n        for await (const chunk of this._streamResponseChunks(\n          messages,\n          callOptions,\n          runManagers?.[0]\n        )) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          chunk.message.response_metadata = {\n            ...chunk.generationInfo,\n            ...chunk.message.response_metadata,\n          };\n          if (outputVersion === \"v1\") {\n            yield castStandardMessageContent(\n              chunk.message\n            ) as OutputMessageType;\n          } else {\n            yield chunk.message as OutputMessageType;\n          }\n          if (!generationChunk) {\n            generationChunk = chunk;\n          } else {\n            generationChunk = generationChunk.concat(chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n      await Promise.all(\n        (runManagers ?? []).map((runManager) =>\n          runManager?.handleLLMEnd({\n            // TODO: Remove cast after figuring out inheritance\n            generations: [[generationChunk as ChatGeneration]],\n            llmOutput,\n          })\n        )\n      );\n    }\n  }\n\n  getLsParams(options: this[\"ParsedCallOptions\"]): LangSmithParams {\n    const providerName = this.getName().startsWith(\"Chat\")\n      ? this.getName().replace(\"Chat\", \"\")\n      : this.getName();\n\n    return {\n      ls_model_type: \"chat\",\n      ls_stop: options.stop,\n      ls_provider: providerName,\n    };\n  }\n\n  /** @ignore */\n  async _generateUncached(\n    messages: BaseMessageLike[][],\n    parsedOptions: this[\"ParsedCallOptions\"],\n    handledOptions: RunnableConfig,\n    startedRunManagers?: CallbackManagerForLLMRun[]\n  ): Promise<LLMResult> {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    let runManagers: CallbackManagerForLLMRun[] | undefined;\n    if (\n      startedRunManagers !== undefined &&\n      startedRunManagers.length === baseMessages.length\n    ) {\n      runManagers = startedRunManagers;\n    } else {\n      const inheritableMetadata = {\n        ...handledOptions.metadata,\n        ...this.getLsParams(parsedOptions),\n      };\n      // create callback manager and start run\n      const callbackManager_ = await CallbackManager.configure(\n        handledOptions.callbacks,\n        this.callbacks,\n        handledOptions.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: parsedOptions,\n        invocation_params: this?.invocationParams(parsedOptions),\n        batch_size: 1,\n      };\n      runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        baseMessages.map(_formatForTracing),\n        handledOptions.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        handledOptions.runName\n      );\n    }\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: ChatGeneration[][] = [];\n    const llmOutputs: LLMResult[\"llmOutput\"][] = [];\n    // Even if stream is not explicitly called, check if model is implicitly\n    // called from streamEvents() or streamLog() to get all streamed events.\n    // Bail out if _streamResponseChunks not overridden\n    const hasStreamingHandler = !!runManagers?.[0].handlers.find(\n      callbackHandlerPrefersStreaming\n    );\n    if (\n      hasStreamingHandler &&\n      !this.disableStreaming &&\n      baseMessages.length === 1 &&\n      this._streamResponseChunks !==\n        BaseChatModel.prototype._streamResponseChunks\n    ) {\n      try {\n        const stream = await this._streamResponseChunks(\n          baseMessages[0],\n          parsedOptions,\n          runManagers?.[0]\n        );\n        let aggregated;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let llmOutput: Record<string, any> | undefined;\n        for await (const chunk of stream) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          if (aggregated === undefined) {\n            aggregated = chunk;\n          } else {\n            aggregated = concat(aggregated, chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n        if (aggregated === undefined) {\n          throw new Error(\"Received empty response from chat model call.\");\n        }\n        generations.push([aggregated]);\n        await runManagers?.[0].handleLLMEnd({\n          generations,\n          llmOutput,\n        });\n      } catch (e) {\n        await runManagers?.[0].handleLLMError(e);\n        throw e;\n      }\n    } else {\n      // generate results\n      const results = await Promise.allSettled(\n        baseMessages.map(async (messageList, i) => {\n          const generateResults = await this._generate(\n            messageList,\n            { ...parsedOptions, promptIndex: i },\n            runManagers?.[i]\n          );\n          if (outputVersion === \"v1\") {\n            for (const generation of generateResults.generations) {\n              generation.message = castStandardMessageContent(\n                generation.message\n              );\n            }\n          }\n          return generateResults;\n        })\n      );\n      // handle results\n      await Promise.all(\n        results.map(async (pResult, i) => {\n          if (pResult.status === \"fulfilled\") {\n            const result = pResult.value;\n            for (const generation of result.generations) {\n              if (generation.message.id == null) {\n                const runId = runManagers?.at(0)?.runId;\n                if (runId != null) generation.message._updateId(`run-${runId}`);\n              }\n              generation.message.response_metadata = {\n                ...generation.generationInfo,\n                ...generation.message.response_metadata,\n              };\n            }\n            if (result.generations.length === 1) {\n              result.generations[0].message.response_metadata = {\n                ...result.llmOutput,\n                ...result.generations[0].message.response_metadata,\n              };\n            }\n            generations[i] = result.generations;\n            llmOutputs[i] = result.llmOutput;\n            return runManagers?.[i]?.handleLLMEnd({\n              generations: [result.generations],\n              llmOutput: result.llmOutput,\n            });\n          } else {\n            // status === \"rejected\"\n            await runManagers?.[i]?.handleLLMError(pResult.reason);\n            return Promise.reject(pResult.reason);\n          }\n        })\n      );\n    }\n    // create combined output\n    const output: LLMResult = {\n      generations,\n      llmOutput: llmOutputs.length\n        ? this._combineLLMOutput?.(...llmOutputs)\n        : undefined,\n    };\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n    return output;\n  }\n\n  async _generateCached({\n    messages,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions,\n  }: {\n    messages: BaseMessageLike[][];\n    cache: BaseCache<Generation[]>;\n    llmStringKey: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parsedOptions: any;\n    handledOptions: RunnableConfig;\n  }): Promise<\n    LLMResult & {\n      missingPromptIndices: number[];\n      startedRunManagers?: CallbackManagerForLLMRun[];\n    }\n  > {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const inheritableMetadata = {\n      ...handledOptions.metadata,\n      ...this.getLsParams(parsedOptions),\n    };\n    // create callback manager and start run\n    const callbackManager_ = await CallbackManager.configure(\n      handledOptions.callbacks,\n      this.callbacks,\n      handledOptions.tags,\n      this.tags,\n      inheritableMetadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: 1,\n    };\n    const runManagers = await callbackManager_?.handleChatModelStart(\n      this.toJSON(),\n      baseMessages.map(_formatForTracing),\n      handledOptions.runId,\n      undefined,\n      extra,\n      undefined,\n      undefined,\n      handledOptions.runName\n    );\n\n    // generate results\n    const missingPromptIndices: number[] = [];\n    const results = await Promise.allSettled(\n      baseMessages.map(async (baseMessage, index) => {\n        // Join all content into one string for the prompt index\n        const prompt =\n          BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n        const result = await cache.lookup(prompt, llmStringKey);\n\n        if (result == null) {\n          missingPromptIndices.push(index);\n        }\n\n        return result;\n      })\n    );\n\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results\n      .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n      .filter(\n        ({ result }) =>\n          (result.status === \"fulfilled\" && result.value != null) ||\n          result.status === \"rejected\"\n      );\n\n    // Handle results and call run managers\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: Generation[][] = [];\n    await Promise.all(\n      cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n        if (promiseResult.status === \"fulfilled\") {\n          const result = promiseResult.value as Generation[];\n          generations[i] = result.map((result) => {\n            if (\n              \"message\" in result &&\n              isBaseMessage(result.message) &&\n              isAIMessage(result.message)\n            ) {\n              result.message.usage_metadata = {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n              };\n              if (outputVersion === \"v1\") {\n                result.message = castStandardMessageContent(result.message);\n              }\n            }\n            result.generationInfo = {\n              ...result.generationInfo,\n              tokenUsage: {},\n            };\n            return result;\n          });\n          if (result.length) {\n            await runManager?.handleLLMNewToken(result[0].text);\n          }\n          return runManager?.handleLLMEnd(\n            {\n              generations: [result],\n            },\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n        } else {\n          // status === \"rejected\"\n          await runManager?.handleLLMError(\n            promiseResult.reason,\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n          return Promise.reject(promiseResult.reason);\n        }\n      })\n    );\n\n    const output = {\n      generations,\n      missingPromptIndices,\n      startedRunManagers: runManagers,\n    };\n\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n\n    return output;\n  }\n\n  /**\n   * Generates chat based on the input messages.\n   * @param messages An array of arrays of BaseMessage instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generate(\n    messages: BaseMessageLike[][],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    // parse call options\n    let parsedOptions: CallOptions | undefined;\n    if (Array.isArray(options)) {\n      parsedOptions = { stop: options } as CallOptions;\n    } else {\n      parsedOptions = options;\n    }\n\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const [runnableConfig, callOptions] =\n      this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n\n    if (!this.cache) {\n      return this._generateUncached(baseMessages, callOptions, runnableConfig);\n    }\n\n    const { cache } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(\n      callOptions as CallOptions\n    );\n\n    const { generations, missingPromptIndices, startedRunManagers } =\n      await this._generateCached({\n        messages: baseMessages,\n        cache,\n        llmStringKey,\n        parsedOptions: callOptions,\n        handledOptions: runnableConfig,\n      });\n\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(\n        missingPromptIndices.map((i) => baseMessages[i]),\n        callOptions,\n        runnableConfig,\n        startedRunManagers !== undefined\n          ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n          : undefined\n      );\n      await Promise.all(\n        results.generations.map(async (generation, index) => {\n          const promptIndex = missingPromptIndices[index];\n          generations[promptIndex] = generation;\n          // Join all content into one string for the prompt index\n          const prompt = BaseChatModel._convertInputToPromptValue(\n            baseMessages[promptIndex]\n          ).toString();\n          return cache.update(prompt, llmStringKey, generation);\n        })\n      );\n      llmOutput = results.llmOutput ?? {};\n    }\n\n    return { generations, llmOutput } as LLMResult;\n  }\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options?: this[\"ParsedCallOptions\"]): any {\n    return {};\n  }\n\n  _modelType(): string {\n    return \"base_chat_model\" as const;\n  }\n\n  abstract _llmType(): string;\n\n  /**\n   * Generates a prompt based on the input prompt values.\n   * @param promptValues An array of BasePromptValue instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    const promptMessages: BaseMessage[][] = promptValues.map((promptValue) =>\n      promptValue.toChatMessages()\n    );\n    return this.generate(promptMessages, options, callbacks);\n  }\n\n  abstract _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      > {\n    if (typeof this.bindTools !== \"function\") {\n      throw new Error(\n        `Chat model must implement \".bindTools()\" to use withStructuredOutput.`\n      );\n    }\n    if (config?.strict) {\n      throw new Error(\n        `\"strict\" mode is not supported for this model by default.`\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const schema: Record<string, any> | InteropZodType<RunOutput> =\n      outputSchema;\n    const name = config?.name;\n    const description =\n      getSchemaDescription(schema) ?? \"A function available to call.\";\n    const method = config?.method;\n    const includeRaw = config?.includeRaw;\n    if (method === \"jsonMode\") {\n      throw new Error(\n        `Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`\n      );\n    }\n\n    let functionName = name ?? \"extract\";\n    let tools: ToolDefinition[];\n    if (isInteropZodSchema(schema)) {\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: toJsonSchema(schema),\n          },\n        },\n      ];\n    } else {\n      if (\"name\" in schema) {\n        functionName = schema.name;\n      }\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: schema,\n          },\n        },\n      ];\n    }\n\n    const llm = this.bindTools(tools);\n    const outputParser = RunnableLambda.from<OutputMessageType, RunOutput>(\n      (input: BaseMessageChunk): RunOutput => {\n        if (!AIMessageChunk.isInstance(input)) {\n          throw new Error(\"Input is not an AIMessageChunk.\");\n        }\n        if (!input.tool_calls || input.tool_calls.length === 0) {\n          throw new Error(\"No tool calls found in the response.\");\n        }\n        const toolCall = input.tool_calls.find(\n          (tc) => tc.name === functionName\n        );\n        if (!toolCall) {\n          throw new Error(`No tool call found with name ${functionName}.`);\n        }\n        return toolCall.args as RunOutput;\n      }\n    );\n\n    if (!includeRaw) {\n      return llm.pipe(outputParser).withConfig({\n        runName: \"StructuredOutput\",\n      }) as Runnable<BaseLanguageModelInput, RunOutput>;\n    }\n\n    const parserAssign = RunnablePassthrough.assign({\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parsed: (input: any, config) => outputParser.invoke(input.raw, config),\n    });\n    const parserNone = RunnablePassthrough.assign({\n      parsed: () => null,\n    });\n    const parsedWithFallback = parserAssign.withFallbacks({\n      fallbacks: [parserNone],\n    });\n    return RunnableSequence.from<\n      BaseLanguageModelInput,\n      { raw: BaseMessage; parsed: RunOutput }\n    >([\n      {\n        raw: llm,\n      },\n      parsedWithFallback,\n    ]).withConfig({\n      runName: \"StructuredOutputRunnable\",\n    });\n  }\n}\n\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nexport abstract class SimpleChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions,\n> extends BaseChatModel<CallOptions> {\n  abstract _call(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string>;\n\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const text = await this._call(messages, options, runManager);\n    const message = new AIMessage(text);\n    if (typeof message.content !== \"string\") {\n      throw new Error(\n        \"Cannot generate with a simple chat model when output is not a string.\"\n      );\n    }\n    return {\n      generations: [\n        {\n          text: message.content,\n          message,\n        },\n      ],\n    };\n  }\n}\n", "import { __export } from \"../../_virtual/rolldown_runtime.js\";\nimport { extendInteropZodObject, getInteropZodDefaultGetter, getInteropZodObjectShape, getSchemaDescription, interopParse, interopParseAsync, interopSafeParse, interopSafeParseAsync, interopZodObjectMakeFieldsOptional, interopZodObjectPartial, interopZodObjectPassthrough, interopZodObjectStrict, interopZodTransformInputSchema, isInteropZodError, isInteropZodLiteral, isInteropZodObject, isInteropZodSchema, isShapelessZodSchema, isSimpleStringZodSchema, isZodArrayV4, isZodLiteralV3, isZodLiteralV4, isZodNullableV4, isZodObjectV3, isZodObjectV4, isZodOptionalV4, isZodSchema, isZodSchemaV3, isZodSchemaV4 } from \"./zod.js\";\n\n//#region src/utils/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n\textendInteropZodObject: () => extendInteropZodObject,\n\tgetInteropZodDefaultGetter: () => getInteropZodDefaultGetter,\n\tgetInteropZodObjectShape: () => getInteropZodObjectShape,\n\tgetSchemaDescription: () => getSchemaDescription,\n\tinteropParse: () => interopParse,\n\tinteropParseAsync: () => interopParseAsync,\n\tinteropSafeParse: () => interopSafeParse,\n\tinteropSafeParseAsync: () => interopSafeParseAsync,\n\tinteropZodObjectMakeFieldsOptional: () => interopZodObjectMakeFieldsOptional,\n\tinteropZodObjectPartial: () => interopZodObjectPartial,\n\tinteropZodObjectPassthrough: () => interopZodObjectPassthrough,\n\tinteropZodObjectStrict: () => interopZodObjectStrict,\n\tinteropZodTransformInputSchema: () => interopZodTransformInputSchema,\n\tisInteropZodError: () => isInteropZodError,\n\tisInteropZodLiteral: () => isInteropZodLiteral,\n\tisInteropZodObject: () => isInteropZodObject,\n\tisInteropZodSchema: () => isInteropZodSchema,\n\tisShapelessZodSchema: () => isShapelessZodSchema,\n\tisSimpleStringZodSchema: () => isSimpleStringZodSchema,\n\tisZodArrayV4: () => isZodArrayV4,\n\tisZodLiteralV3: () => isZodLiteralV3,\n\tisZodLiteralV4: () => isZodLiteralV4,\n\tisZodNullableV4: () => isZodNullableV4,\n\tisZodObjectV3: () => isZodObjectV3,\n\tisZodObjectV4: () => isZodObjectV4,\n\tisZodOptionalV4: () => isZodOptionalV4,\n\tisZodSchema: () => isZodSchema,\n\tisZodSchemaV3: () => isZodSchemaV3,\n\tisZodSchemaV4: () => isZodSchemaV4\n});\n\n//#endregion\nexport { extendInteropZodObject, getInteropZodDefaultGetter, getInteropZodObjectShape, getSchemaDescription, interopParse, interopParseAsync, interopSafeParse, interopSafeParseAsync, interopZodObjectMakeFieldsOptional, interopZodObjectPartial, interopZodObjectPassthrough, interopZodObjectStrict, interopZodTransformInputSchema, isInteropZodError, isInteropZodLiteral, isInteropZodObject, isInteropZodSchema, isShapelessZodSchema, isSimpleStringZodSchema, isZodArrayV4, isZodLiteralV3, isZodLiteralV4, isZodNullableV4, isZodObjectV3, isZodObjectV4, isZodOptionalV4, isZodSchema, isZodSchemaV3, isZodSchemaV4, types_exports };\n//# sourceMappingURL=index.js.map", "export const VERSION = '0.19.0'; // x-release-please-version\n", "/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nimport { type RequestOptions } from '../core';\n\nexport interface Shims {\n  kind: string;\n  fetch: any;\n  Request: any;\n  Response: any;\n  Headers: any;\n  FormData: any;\n  Blob: any;\n  File: any;\n  ReadableStream: any;\n  getMultipartRequestOptions: <T = Record<string, unknown>>(\n    form: Shims['FormData'],\n    opts: RequestOptions<T>,\n  ) => Promise<RequestOptions<T>>;\n  getDefaultAgent: (url: string) => any;\n  fileFromPath:\n    | ((path: string, filename?: string, options?: {}) => Promise<Shims['File']>)\n    | ((path: string, options?: {}) => Promise<Shims['File']>);\n  isFsReadStream: (value: any) => boolean;\n}\n\nexport let auto = false;\nexport let kind: Shims['kind'] | undefined = undefined;\nexport let fetch: Shims['fetch'] | undefined = undefined;\nexport let Request: Shims['Request'] | undefined = undefined;\nexport let Response: Shims['Response'] | undefined = undefined;\nexport let Headers: Shims['Headers'] | undefined = undefined;\nexport let FormData: Shims['FormData'] | undefined = undefined;\nexport let Blob: Shims['Blob'] | undefined = undefined;\nexport let File: Shims['File'] | undefined = undefined;\nexport let ReadableStream: Shims['ReadableStream'] | undefined = undefined;\nexport let getMultipartRequestOptions: Shims['getMultipartRequestOptions'] | undefined = undefined;\nexport let getDefaultAgent: Shims['getDefaultAgent'] | undefined = undefined;\nexport let fileFromPath: Shims['fileFromPath'] | undefined = undefined;\nexport let isFsReadStream: Shims['isFsReadStream'] | undefined = undefined;\n\nexport function setShims(shims: Shims, options: { auto: boolean } = { auto: false }) {\n  if (auto) {\n    throw new Error(\n      `you must \\`import 'groq-sdk/shims/${shims.kind}'\\` before importing anything else from groq-sdk`,\n    );\n  }\n  if (kind) {\n    throw new Error(\n      `can't \\`import 'groq-sdk/shims/${shims.kind}'\\` after \\`import 'groq-sdk/shims/${kind}'\\``,\n    );\n  }\n  auto = options.auto;\n  kind = shims.kind;\n  fetch = shims.fetch;\n  Request = shims.Request;\n  Response = shims.Response;\n  Headers = shims.Headers;\n  FormData = shims.FormData;\n  Blob = shims.Blob;\n  File = shims.File;\n  ReadableStream = shims.ReadableStream;\n  getMultipartRequestOptions = shims.getMultipartRequestOptions;\n  getDefaultAgent = shims.getDefaultAgent;\n  fileFromPath = shims.fileFromPath;\n  isFsReadStream = shims.isFsReadStream;\n}\n", "/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nexport class MultipartBody {\n  constructor(public body: any) {}\n  get [Symbol.toStringTag](): string {\n    return 'MultipartBody';\n  }\n}\n", "/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nimport { MultipartBody } from './MultipartBody';\nimport { type RequestOptions } from '../core';\nimport { type Shims } from './registry';\n\nexport function getRuntime({ manuallyImported }: { manuallyImported?: boolean } = {}): Shims {\n  const recommendation =\n    manuallyImported ?\n      `You may need to use polyfills`\n    : `Add one of these imports before your first \\`import  from 'groq-sdk'\\`:\n- \\`import 'groq-sdk/shims/node'\\` (if you're running on Node)\n- \\`import 'groq-sdk/shims/web'\\` (otherwise)\n`;\n\n  let _fetch, _Request, _Response, _Headers;\n  try {\n    // @ts-ignore\n    _fetch = fetch;\n    // @ts-ignore\n    _Request = Request;\n    // @ts-ignore\n    _Response = Response;\n    // @ts-ignore\n    _Headers = Headers;\n  } catch (error) {\n    throw new Error(\n      `this environment is missing the following Web Fetch API type: ${\n        (error as any).message\n      }. ${recommendation}`,\n    );\n  }\n\n  return {\n    kind: 'web',\n    fetch: _fetch,\n    Request: _Request,\n    Response: _Response,\n    Headers: _Headers,\n    FormData:\n      // @ts-ignore\n      typeof FormData !== 'undefined' ? FormData : (\n        class FormData {\n          // @ts-ignore\n          constructor() {\n            throw new Error(\n              `file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`,\n            );\n          }\n        }\n      ),\n    Blob:\n      typeof Blob !== 'undefined' ? Blob : (\n        class Blob {\n          constructor() {\n            throw new Error(\n              `file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`,\n            );\n          }\n        }\n      ),\n    File:\n      // @ts-ignore\n      typeof File !== 'undefined' ? File : (\n        class File {\n          // @ts-ignore\n          constructor() {\n            throw new Error(\n              `file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`,\n            );\n          }\n        }\n      ),\n    ReadableStream:\n      // @ts-ignore\n      typeof ReadableStream !== 'undefined' ? ReadableStream : (\n        class ReadableStream {\n          // @ts-ignore\n          constructor() {\n            throw new Error(\n              `streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`,\n            );\n          }\n        }\n      ),\n    getMultipartRequestOptions: async <T = Record<string, unknown>>(\n      // @ts-ignore\n      form: FormData,\n      opts: RequestOptions<T>,\n    ): Promise<RequestOptions<T>> => ({\n      ...opts,\n      body: new MultipartBody(form) as any,\n    }),\n    getDefaultAgent: (url: string) => undefined,\n    fileFromPath: () => {\n      throw new Error(\n        'The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/groq/groq-typescript#file-uploads',\n      );\n    },\n    isFsReadStream: (value: any) => false,\n  };\n}\n", "/**\n * Disclaimer: modules in _shims aren't intended to be imported by SDK users.\n */\nimport * as shims from './registry.mjs';\nimport * as auto from 'groq-sdk/_shims/auto/runtime';\nexport const init = () => {\n  if (!shims.kind) shims.setShims(auto.getRuntime(), { auto: true });\n};\nexport * from './registry.mjs';\n\ninit();\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { castToError, Headers } from './core';\n\nexport class GroqError extends Error {}\n\nexport class APIError<\n  TStatus extends number | undefined = number | undefined,\n  THeaders extends Headers | undefined = Headers | undefined,\n  TError extends Object | undefined = Object | undefined,\n> extends GroqError {\n  /** HTTP status for the response that caused the error */\n  readonly status: TStatus;\n  /** HTTP headers for the response that caused the error */\n  readonly headers: THeaders;\n  /** JSON body of the response that caused the error */\n  readonly error: TError;\n\n  constructor(status: TStatus, error: TError, message: string | undefined, headers: THeaders) {\n    super(`${APIError.makeMessage(status, error, message)}`);\n    this.status = status;\n    this.headers = headers;\n    this.error = error;\n  }\n\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\n    const msg =\n      error?.message ?\n        typeof error.message === 'string' ?\n          error.message\n        : JSON.stringify(error.message)\n      : error ? JSON.stringify(error)\n      : message;\n\n    if (status && msg) {\n      return `${status} ${msg}`;\n    }\n    if (status) {\n      return `${status} status code (no body)`;\n    }\n    if (msg) {\n      return msg;\n    }\n    return '(no status code or body)';\n  }\n\n  static generate(\n    status: number | undefined,\n    errorResponse: Object | undefined,\n    message: string | undefined,\n    headers: Headers | undefined,\n  ): APIError {\n    if (!status || !headers) {\n      return new APIConnectionError({ message, cause: castToError(errorResponse) });\n    }\n\n    const error = errorResponse as Record<string, any>;\n\n    if (status === 400) {\n      return new BadRequestError(status, error, message, headers);\n    }\n\n    if (status === 401) {\n      return new AuthenticationError(status, error, message, headers);\n    }\n\n    if (status === 403) {\n      return new PermissionDeniedError(status, error, message, headers);\n    }\n\n    if (status === 404) {\n      return new NotFoundError(status, error, message, headers);\n    }\n\n    if (status === 409) {\n      return new ConflictError(status, error, message, headers);\n    }\n\n    if (status === 422) {\n      return new UnprocessableEntityError(status, error, message, headers);\n    }\n\n    if (status === 429) {\n      return new RateLimitError(status, error, message, headers);\n    }\n\n    if (status >= 500) {\n      return new InternalServerError(status, error, message, headers);\n    }\n\n    return new APIError(status, error, message, headers);\n  }\n}\n\nexport class APIUserAbortError extends APIError<undefined, undefined, undefined> {\n  constructor({ message }: { message?: string } = {}) {\n    super(undefined, undefined, message || 'Request was aborted.', undefined);\n  }\n}\n\nexport class APIConnectionError extends APIError<undefined, undefined, undefined> {\n  constructor({ message, cause }: { message?: string | undefined; cause?: Error | undefined }) {\n    super(undefined, undefined, message || 'Connection error.', undefined);\n    // in some environments the 'cause' property is already declared\n    // @ts-ignore\n    if (cause) this.cause = cause;\n  }\n}\n\nexport class APIConnectionTimeoutError extends APIConnectionError {\n  constructor({ message }: { message?: string } = {}) {\n    super({ message: message ?? 'Request timed out.' });\n  }\n}\n\nexport class BadRequestError extends APIError<400, Headers> {}\n\nexport class AuthenticationError extends APIError<401, Headers> {}\n\nexport class PermissionDeniedError extends APIError<403, Headers> {}\n\nexport class NotFoundError extends APIError<404, Headers> {}\n\nexport class ConflictError extends APIError<409, Headers> {}\n\nexport class UnprocessableEntityError extends APIError<422, Headers> {}\n\nexport class RateLimitError extends APIError<429, Headers> {}\n\nexport class InternalServerError extends APIError<number, Headers> {}\n", "import { ReadableStream, type Response } from '../_shims/index';\nimport { GroqError } from '../error';\n\nimport { APIError } from '../error';\n\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\nexport type ServerSentEvent = {\n  event: string | null;\n  data: string;\n  raw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n  controller: AbortController;\n\n  constructor(\n    private iterator: () => AsyncIterator<Item>,\n    controller: AbortController,\n  ) {\n    this.controller = controller;\n  }\n\n  static fromSSEResponse<Item>(response: Response, controller: AbortController) {\n    let consumed = false;\n    const decoder = new SSEDecoder();\n\n    async function* iterMessages(): AsyncGenerator<ServerSentEvent, void, unknown> {\n      if (!response.body) {\n        controller.abort();\n        throw new GroqError(`Attempted to iterate over a response with no body`);\n      }\n\n      const lineDecoder = new LineDecoder();\n\n      const iter = readableStreamAsyncIterable<Bytes>(response.body);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          const sse = decoder.decode(line);\n          if (sse) yield sse;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        const sse = decoder.decode(line);\n        if (sse) yield sse;\n      }\n    }\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of iterMessages()) {\n          if (done) continue;\n\n          if (sse.data.startsWith('[DONE]')) {\n            done = true;\n            continue;\n          }\n\n          if (sse.event === null || sse.event === 'error') {\n            let data;\n\n            try {\n              data = JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n\n            if (data && data.error) {\n              throw new APIError(data.error.status_code, data.error, data.error.message, undefined);\n            }\n\n            yield data;\n          }\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController) {\n    let consumed = false;\n\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\n      const lineDecoder = new LineDecoder();\n\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\n    return this.iterator();\n  }\n\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee(): [Stream<Item>, Stream<Item>] {\n    const left: Array<Promise<IteratorResult<Item>>> = [];\n    const right: Array<Promise<IteratorResult<Item>>> = [];\n    const iterator = this.iterator();\n\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift()!;\n        },\n      };\n    };\n\n    return [\n      new Stream(() => teeIterator(left), this.controller),\n      new Stream(() => teeIterator(right), this.controller),\n    ];\n  }\n\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream(): ReadableStream {\n    const self = this;\n    let iter: AsyncIterator<Item>;\n    const encoder = new TextEncoder();\n\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl) {\n        try {\n          const { value, done } = await iter.next();\n          if (done) return ctrl.close();\n\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        await iter.return?.();\n      },\n    });\n  }\n}\n\nclass SSEDecoder {\n  private data: string[];\n  private event: string | null;\n  private chunks: string[];\n\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line: string) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n\n      const sse: ServerSentEvent = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks,\n      };\n\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n  // prettier-ignore\n  static NEWLINE_CHARS = new Set(['\\n', '\\r', '\\x0b', '\\x0c', '\\x1c', '\\x1d', '\\x1e', '\\x85', '\\u2028', '\\u2029']);\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/g;\n\n  buffer: string[];\n  trailingCR: boolean;\n  textDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\n\n  constructor() {\n    this.buffer = [];\n    this.trailingCR = false;\n  }\n\n  decode(chunk: Bytes): string[] {\n    let text = this.decodeText(chunk);\n\n    if (this.trailingCR) {\n      text = '\\r' + text;\n      this.trailingCR = false;\n    }\n    if (text.endsWith('\\r')) {\n      this.trailingCR = true;\n      text = text.slice(0, -1);\n    }\n\n    if (!text) {\n      return [];\n    }\n\n    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || '');\n    let lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n    if (lines.length === 1 && !trailingNewline) {\n      this.buffer.push(lines[0]!);\n      return [];\n    }\n\n    if (this.buffer.length > 0) {\n      lines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n      this.buffer = [];\n    }\n\n    if (!trailingNewline) {\n      this.buffer = [lines.pop() || ''];\n    }\n\n    return lines;\n  }\n\n  decodeText(bytes: Bytes): string {\n    if (bytes == null) return '';\n    if (typeof bytes === 'string') return bytes;\n\n    // Node:\n    if (typeof Buffer !== 'undefined') {\n      if (bytes instanceof Buffer) {\n        return bytes.toString();\n      }\n      if (bytes instanceof Uint8Array) {\n        return Buffer.from(bytes).toString();\n      }\n\n      throw new GroqError(\n        `Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\n      );\n    }\n\n    // Browser\n    if (typeof TextDecoder !== 'undefined') {\n      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n        this.textDecoder ??= new TextDecoder('utf8');\n        return this.textDecoder.decode(bytes);\n      }\n\n      throw new GroqError(\n        `Unexpected: received non-Uint8Array/ArrayBuffer (${\n          (bytes as any).constructor.name\n        }) in a web platform. Please report this error.`,\n      );\n    }\n\n    throw new GroqError(\n      `Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\n    );\n  }\n\n  flush(): string[] {\n    if (!this.buffer.length && !this.trailingCR) {\n      return [];\n    }\n\n    const lines = [this.buffer.join('')];\n    this.buffer = [];\n    this.trailingCR = false;\n    return lines;\n  }\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n", "import { type RequestOptions } from './core';\nimport {\n  FormData,\n  File,\n  type Blob,\n  type FilePropertyBag,\n  getMultipartRequestOptions,\n  type FsReadStream,\n  isFsReadStream,\n} from './_shims/index';\nimport { MultipartBody } from './_shims/MultipartBody';\nexport { fileFromPath } from './_shims/index';\n\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | Uint8Array | DataView;\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | Uint8Array | DataView;\n\n/**\n * Typically, this is a native \"File\" class.\n *\n * We provide the {@link toFile} utility to convert a variety of objects\n * into the File class.\n *\n * For convenience, you can also pass a fetch Response, or in Node,\n * the result of fs.createReadStream().\n */\nexport type Uploadable = FileLike | ResponseLike | FsReadStream;\n\n/**\n * Intended to match web.Blob, node.Blob, node-fetch.Blob, etc.\n */\nexport interface BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\n  readonly size: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\n  readonly type: string;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\n  text(): Promise<string>;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\n  slice(start?: number, end?: number): BlobLike;\n  // unfortunately @types/node-fetch@^2.6.4 doesn't type the arrayBuffer method\n}\n\n/**\n * Intended to match web.File, node.File, node-fetch.File, etc.\n */\nexport interface FileLike extends BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\n  readonly lastModified: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\n  readonly name: string;\n}\n\n/**\n * Intended to match web.Response, node.Response, node-fetch.Response, etc.\n */\nexport interface ResponseLike {\n  url: string;\n  blob(): Promise<BlobLike>;\n}\n\nexport const isResponseLike = (value: any): value is ResponseLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.url === 'string' &&\n  typeof value.blob === 'function';\n\nexport const isFileLike = (value: any): value is FileLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.name === 'string' &&\n  typeof value.lastModified === 'number' &&\n  isBlobLike(value);\n\n/**\n * The BlobLike type omits arrayBuffer() because @types/node-fetch@^2.6.4 lacks it; but this check\n * adds the arrayBuffer() method type because it is available and used at runtime\n */\nexport const isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.size === 'number' &&\n  typeof value.type === 'string' &&\n  typeof value.text === 'function' &&\n  typeof value.slice === 'function' &&\n  typeof value.arrayBuffer === 'function';\n\nexport const isUploadable = (value: any): value is Uploadable => {\n  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);\n};\n\nexport type ToFileInput = Uploadable | Exclude<BlobLikePart, string> | AsyncIterable<BlobLikePart>;\n\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(\n  value: ToFileInput | PromiseLike<ToFileInput>,\n  name?: string | null | undefined,\n  options?: FilePropertyBag | undefined,\n): Promise<FileLike> {\n  // If it's a promise, resolve it.\n  value = await value;\n\n  // If we've been given a `File` we don't need to do anything\n  if (isFileLike(value)) {\n    return value;\n  }\n\n  if (isResponseLike(value)) {\n    const blob = await value.blob();\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop() ?? 'unknown_file';\n\n    // we need to convert the `Blob` into an array buffer because the `Blob` class\n    // that `node-fetch` defines is incompatible with the web standard which results\n    // in `new File` interpreting it as a string instead of binary data.\n    const data = isBlobLike(blob) ? [(await blob.arrayBuffer()) as any] : [blob];\n\n    return new File(data, name, options);\n  }\n\n  const bits = await getBytes(value);\n\n  name ||= getName(value) ?? 'unknown_file';\n\n  if (!options?.type) {\n    const type = (bits[0] as any)?.type;\n    if (typeof type === 'string') {\n      options = { ...options, type };\n    }\n  }\n\n  return new File(bits, name, options);\n}\n\nasync function getBytes(value: ToFileInput): Promise<Array<BlobPart>> {\n  let parts: Array<BlobPart> = [];\n  if (\n    typeof value === 'string' ||\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n    value instanceof ArrayBuffer\n  ) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(await value.arrayBuffer());\n  } else if (\n    isAsyncIterableIterator(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(chunk as BlobPart); // TODO, consider validating?\n    }\n  } else {\n    throw new Error(\n      `Unexpected data type: ${typeof value}; constructor: ${value?.constructor\n        ?.name}; props: ${propsForError(value)}`,\n    );\n  }\n\n  return parts;\n}\n\nfunction propsForError(value: any): string {\n  const props = Object.getOwnPropertyNames(value);\n  return `[${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\n\nfunction getName(value: any): string | undefined {\n  return (\n    getStringFromMaybeBuffer(value.name) ||\n    getStringFromMaybeBuffer(value.filename) ||\n    // For fs.ReadStream\n    getStringFromMaybeBuffer(value.path)?.split(/[\\\\/]/).pop()\n  );\n}\n\nconst getStringFromMaybeBuffer = (x: string | Buffer | unknown): string | undefined => {\n  if (typeof x === 'string') return x;\n  if (typeof Buffer !== 'undefined' && x instanceof Buffer) return String(x);\n  return undefined;\n};\n\nconst isAsyncIterableIterator = (value: any): value is AsyncIterableIterator<unknown> =>\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n\nexport const isMultipartBody = (body: any): body is MultipartBody =>\n  body && typeof body === 'object' && body.body && body[Symbol.toStringTag] === 'MultipartBody';\n\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async <T = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  if (!hasUploadableValue(opts.body)) return opts;\n\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const multipartFormRequestOptions = async <T = Record<string, unknown>>(\n  opts: RequestOptions<T>,\n): Promise<RequestOptions<T | MultipartBody>> => {\n  const form = await createForm(opts.body);\n  return getMultipartRequestOptions(form, opts);\n};\n\nexport const createForm = async <T = Record<string, unknown>>(body: T | undefined): Promise<FormData> => {\n  const form = new FormData();\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  return form;\n};\n\nconst hasUploadableValue = (value: unknown): boolean => {\n  if (isUploadable(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue((value as any)[k])) return true;\n    }\n  }\n  return false;\n};\n\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\n    );\n  }\n\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if (isUploadable(value)) {\n    const file = await toFile(value);\n    form.append(key, file as File);\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\n    );\n  } else {\n    throw new TypeError(\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\n    );\n  }\n};\n", "import { VERSION } from './version';\nimport { Stream } from './lib/streaming';\nimport {\n  GroqError,\n  APIError,\n  APIConnectionError,\n  APIConnectionTimeoutError,\n  APIUserAbortError,\n} from './error';\nimport {\n  kind as shimsKind,\n  type Readable,\n  getDefaultAgent,\n  type Agent,\n  fetch,\n  type RequestInfo,\n  type RequestInit,\n  type Response,\n  type HeadersInit,\n  init,\n} from './_shims/index';\n\n// try running side effects outside of _shims/index to workaround https://github.com/vercel/next.js/issues/76881\ninit();\n\nexport { type Response };\nimport { BlobLike, isBlobLike, isMultipartBody } from './uploads';\nexport {\n  maybeMultipartFormRequestOptions,\n  multipartFormRequestOptions,\n  createForm,\n  type Uploadable,\n} from './uploads';\n\nexport type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\ntype APIResponseProps = {\n  response: Response;\n  options: FinalRequestOptions;\n  controller: AbortController;\n};\n\nasync function defaultParseResponse<T>(props: APIResponseProps): Promise<T> {\n  const { response } = props;\n  if (props.options.stream) {\n    debug('response', response.status, response.url, response.headers, response.body);\n\n    // Note: there is an invariant here that isn't represented in the type system\n    // that if you set `stream: true` the response type must also be `Stream<T>`\n\n    if (props.options.__streamClass) {\n      return props.options.__streamClass.fromSSEResponse(response, props.controller) as any;\n    }\n\n    return Stream.fromSSEResponse(response, props.controller) as any;\n  }\n\n  // fetch refuses to read the body when the status code is 204.\n  if (response.status === 204) {\n    return null as T;\n  }\n\n  if (props.options.__binaryResponse) {\n    return response as unknown as T;\n  }\n\n  const contentType = response.headers.get('content-type');\n  const mediaType = contentType?.split(';')[0]?.trim();\n  const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\n  if (isJSON) {\n    const json = await response.json();\n\n    debug('response', response.status, response.url, response.headers, json);\n\n    return json as T;\n  }\n\n  const text = await response.text();\n  debug('response', response.status, response.url, response.headers, text);\n\n  // TODO handle blob, arraybuffer, other content types, etc.\n  return text as unknown as T;\n}\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise<T> extends Promise<T> {\n  private parsedPromise: Promise<T> | undefined;\n\n  constructor(\n    private responsePromise: Promise<APIResponseProps>,\n    private parseResponse: (props: APIResponseProps) => PromiseOrValue<T> = defaultParseResponse,\n  ) {\n    super((resolve) => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null as any);\n    });\n  }\n\n  _thenUnwrap<U>(transform: (data: T, props: APIResponseProps) => U): APIPromise<U> {\n    return new APIPromise(this.responsePromise, async (props) =>\n      transform(await this.parseResponse(props), props),\n    );\n  }\n\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   *\n   *  Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import  from 'groq-sdk'`:\n   * - `import 'groq-sdk/shims/node'` (if you're running on Node)\n   * - `import 'groq-sdk/shims/web'` (otherwise)\n   */\n  asResponse(): Promise<Response> {\n    return this.responsePromise.then((p) => p.response);\n  }\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   *\n   *\n   *  Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import  from 'groq-sdk'`:\n   * - `import 'groq-sdk/shims/node'` (if you're running on Node)\n   * - `import 'groq-sdk/shims/web'` (otherwise)\n   */\n  async withResponse(): Promise<{ data: T; response: Response }> {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data, response };\n  }\n\n  private parse(): Promise<T> {\n    if (!this.parsedPromise) {\n      this.parsedPromise = this.responsePromise.then(this.parseResponse);\n    }\n    return this.parsedPromise;\n  }\n\n  override then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n  ): Promise<TResult1 | TResult2> {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  override catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,\n  ): Promise<T | TResult> {\n    return this.parse().catch(onrejected);\n  }\n\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this.parse().finally(onfinally);\n  }\n}\n\nexport abstract class APIClient {\n  baseURL: string;\n  maxRetries: number;\n  timeout: number;\n  httpAgent: Agent | undefined;\n\n  private fetch: Fetch;\n  protected idempotencyHeader?: string;\n\n  constructor({\n    baseURL,\n    maxRetries = 2,\n    timeout = 60000, // 1 minute\n    httpAgent,\n    fetch: overriddenFetch,\n  }: {\n    baseURL: string;\n    maxRetries?: number | undefined;\n    timeout: number | undefined;\n    httpAgent: Agent | undefined;\n    fetch: Fetch | undefined;\n  }) {\n    this.baseURL = baseURL;\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n    this.timeout = validatePositiveInteger('timeout', timeout);\n    this.httpAgent = httpAgent;\n\n    this.fetch = overriddenFetch ?? fetch;\n  }\n\n  protected authHeaders(opts: FinalRequestOptions): Headers {\n    return {};\n  }\n\n  /**\n   * Override this to add your own default headers, for example:\n   *\n   *  {\n   *    ...super.defaultHeaders(),\n   *    Authorization: 'Bearer 123',\n   *  }\n   */\n  protected defaultHeaders(opts: FinalRequestOptions): Headers {\n    return {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      'User-Agent': this.getUserAgent(),\n      ...getPlatformHeaders(),\n      ...this.authHeaders(opts),\n    };\n  }\n\n  protected abstract defaultQuery(): DefaultQuery | undefined;\n\n  /**\n   * Override this to add your own headers validation:\n   */\n  protected validateHeaders(headers: Headers, customHeaders: Headers) {}\n\n  protected defaultIdempotencyKey(): string {\n    return `stainless-node-retry-${uuid4()}`;\n  }\n\n  get<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('get', path, opts);\n  }\n\n  post<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('post', path, opts);\n  }\n\n  patch<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('patch', path, opts);\n  }\n\n  put<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('put', path, opts);\n  }\n\n  delete<Req, Rsp>(path: string, opts?: PromiseOrValue<RequestOptions<Req>>): APIPromise<Rsp> {\n    return this.methodRequest('delete', path, opts);\n  }\n\n  private methodRequest<Req, Rsp>(\n    method: HTTPMethod,\n    path: string,\n    opts?: PromiseOrValue<RequestOptions<Req>>,\n  ): APIPromise<Rsp> {\n    return this.request(\n      Promise.resolve(opts).then(async (opts) => {\n        const body =\n          opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\n          : opts?.body instanceof DataView ? opts.body\n          : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\n          : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\n          : opts?.body;\n        return { method, path, ...opts, body };\n      }),\n    );\n  }\n\n  getAPIList<Item, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\n    path: string,\n    Page: new (...args: any[]) => PageClass,\n    opts?: RequestOptions<any>,\n  ): PagePromise<PageClass, Item> {\n    return this.requestAPIList(Page, { method: 'get', path, ...opts });\n  }\n\n  private calculateContentLength(body: unknown): string | null {\n    if (typeof body === 'string') {\n      if (typeof Buffer !== 'undefined') {\n        return Buffer.byteLength(body, 'utf8').toString();\n      }\n\n      if (typeof TextEncoder !== 'undefined') {\n        const encoder = new TextEncoder();\n        const encoded = encoder.encode(body);\n        return encoded.length.toString();\n      }\n    } else if (ArrayBuffer.isView(body)) {\n      return body.byteLength.toString();\n    }\n\n    return null;\n  }\n\n  buildRequest<Req>(\n    options: FinalRequestOptions<Req>,\n    { retryCount = 0 }: { retryCount?: number } = {},\n  ): { req: RequestInit; url: string; timeout: number } {\n    options = { ...options };\n    const { method, path, query, headers: headers = {} } = options;\n\n    const body =\n      ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\n        options.body\n      : isMultipartBody(options.body) ? options.body.body\n      : options.body ? JSON.stringify(options.body, null, 2)\n      : null;\n    const contentLength = this.calculateContentLength(body);\n\n    const url = this.buildURL(path!, query);\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\n    options.timeout = options.timeout ?? this.timeout;\n    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n    const minAgentTimeout = options.timeout + 1000;\n    if (\n      typeof (httpAgent as any)?.options?.timeout === 'number' &&\n      minAgentTimeout > ((httpAgent as any).options.timeout ?? 0)\n    ) {\n      // Allow any given request to bump our agent active socket timeout.\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n      // and without mutating agent we would need to create more of them.\n      // This tradeoff optimizes for performance.\n      (httpAgent as any).options.timeout = minAgentTimeout;\n    }\n\n    if (this.idempotencyHeader && method !== 'get') {\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\n      headers[this.idempotencyHeader] = options.idempotencyKey;\n    }\n\n    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\n\n    const req: RequestInit = {\n      method,\n      ...(body && { body: body as any }),\n      headers: reqHeaders,\n      ...(httpAgent && { agent: httpAgent }),\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\n      // not compatible with standard web types\n      signal: options.signal ?? null,\n    };\n\n    return { req, url, timeout: options.timeout };\n  }\n\n  private buildHeaders({\n    options,\n    headers,\n    contentLength,\n    retryCount,\n  }: {\n    options: FinalRequestOptions;\n    headers: Record<string, string | null | undefined>;\n    contentLength: string | null | undefined;\n    retryCount: number;\n  }): Record<string, string> {\n    const reqHeaders: Record<string, string> = {};\n    if (contentLength) {\n      reqHeaders['content-length'] = contentLength;\n    }\n\n    const defaultHeaders = this.defaultHeaders(options);\n    applyHeadersMut(reqHeaders, defaultHeaders);\n    applyHeadersMut(reqHeaders, headers);\n\n    // let builtin fetch set the Content-Type for multipart bodies\n    if (isMultipartBody(options.body) && shimsKind !== 'node') {\n      delete reqHeaders['content-type'];\n    }\n\n    // Don't set theses headers if they were already set or removed through default headers or by the caller.\n    // We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to account\n    // for the removal case.\n    if (\n      getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined &&\n      getHeader(headers, 'x-stainless-retry-count') === undefined\n    ) {\n      reqHeaders['x-stainless-retry-count'] = String(retryCount);\n    }\n    if (\n      getHeader(defaultHeaders, 'x-stainless-timeout') === undefined &&\n      getHeader(headers, 'x-stainless-timeout') === undefined &&\n      options.timeout\n    ) {\n      reqHeaders['x-stainless-timeout'] = String(options.timeout);\n    }\n\n    this.validateHeaders(reqHeaders, headers);\n\n    return reqHeaders;\n  }\n\n  /**\n   * Used as a callback for mutating the given `FinalRequestOptions` object.\n   */\n  protected async prepareOptions(options: FinalRequestOptions): Promise<void> {}\n\n  /**\n   * Used as a callback for mutating the given `RequestInit` object.\n   *\n   * This is useful for cases where you want to add certain headers based off of\n   * the request properties, e.g. `method` or `url`.\n   */\n  protected async prepareRequest(\n    request: RequestInit,\n    { url, options }: { url: string; options: FinalRequestOptions },\n  ): Promise<void> {}\n\n  protected parseHeaders(headers: HeadersInit | null | undefined): Record<string, string> {\n    return (\n      !headers ? {}\n      : Symbol.iterator in headers ?\n        Object.fromEntries(Array.from(headers as Iterable<string[]>).map((header) => [...header]))\n      : { ...(headers as any as Record<string, string>) }\n    );\n  }\n\n  protected makeStatusError(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: Headers | undefined,\n  ): APIError {\n    return APIError.generate(status, error, message, headers);\n  }\n\n  request<Req, Rsp>(\n    options: PromiseOrValue<FinalRequestOptions<Req>>,\n    remainingRetries: number | null = null,\n  ): APIPromise<Rsp> {\n    return new APIPromise(this.makeRequest(options, remainingRetries));\n  }\n\n  private async makeRequest<Req>(\n    optionsInput: PromiseOrValue<FinalRequestOptions<Req>>,\n    retriesRemaining: number | null,\n  ): Promise<APIResponseProps> {\n    const options = await optionsInput;\n    const maxRetries = options.maxRetries ?? this.maxRetries;\n    if (retriesRemaining == null) {\n      retriesRemaining = maxRetries;\n    }\n\n    await this.prepareOptions(options);\n\n    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n\n    await this.prepareRequest(req, { url, options });\n\n    debug('request', url, options, req.headers);\n\n    if (options.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n\n    const controller = new AbortController();\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n\n    if (response instanceof Error) {\n      if (options.signal?.aborted) {\n        throw new APIUserAbortError();\n      }\n      if (retriesRemaining) {\n        return this.retryRequest(options, retriesRemaining);\n      }\n      if (response.name === 'AbortError') {\n        throw new APIConnectionTimeoutError();\n      }\n      throw new APIConnectionError({ cause: response });\n    }\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      if (retriesRemaining && this.shouldRetry(response)) {\n        const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\n      }\n\n      const errText = await response.text().catch((e) => castToError(e).message);\n      const errJSON = safeJSON(errText);\n      const errMessage = errJSON ? undefined : errText;\n      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n\n      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n      throw err;\n    }\n\n    return { response, options, controller };\n  }\n\n  requestAPIList<Item = unknown, PageClass extends AbstractPage<Item> = AbstractPage<Item>>(\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\n    options: FinalRequestOptions,\n  ): PagePromise<PageClass, Item> {\n    const request = this.makeRequest(options, null);\n    return new PagePromise<PageClass, Item>(this, request, Page);\n  }\n\n  buildURL<Req>(path: string, query: Req | null | undefined): string {\n    const url =\n      isAbsoluteURL(path) ?\n        new URL(path)\n      : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n\n    const defaultQuery = this.defaultQuery();\n    if (!isEmptyObj(defaultQuery)) {\n      query = { ...defaultQuery, ...query } as Req;\n    }\n\n    if (typeof query === 'object' && query && !Array.isArray(query)) {\n      url.search = this.stringifyQuery(query as Record<string, unknown>);\n    }\n\n    return url.toString();\n  }\n\n  protected stringifyQuery(query: Record<string, unknown>): string {\n    return Object.entries(query)\n      .filter(([_, value]) => typeof value !== 'undefined')\n      .map(([key, value]) => {\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n          return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n        }\n        if (value === null) {\n          return `${encodeURIComponent(key)}=`;\n        }\n        throw new GroqError(\n          `Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`,\n        );\n      })\n      .join('&');\n  }\n\n  async fetchWithTimeout(\n    url: RequestInfo,\n    init: RequestInit | undefined,\n    ms: number,\n    controller: AbortController,\n  ): Promise<Response> {\n    const { signal, ...options } = init || {};\n    if (signal) signal.addEventListener('abort', () => controller.abort());\n\n    const timeout = setTimeout(() => controller.abort(), ms);\n\n    const fetchOptions = {\n      signal: controller.signal as any,\n      ...options,\n    };\n    if (fetchOptions.method) {\n      // Custom methods like 'patch' need to be uppercased\n      // See https://github.com/nodejs/undici/issues/2294\n      fetchOptions.method = fetchOptions.method.toUpperCase();\n    }\n\n    return (\n      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n      this.fetch.call(undefined, url, fetchOptions).finally(() => {\n        clearTimeout(timeout);\n      })\n    );\n  }\n\n  private shouldRetry(response: Response): boolean {\n    // Note this is not a standard header.\n    const shouldRetryHeader = response.headers.get('x-should-retry');\n\n    // If the server explicitly says whether or not to retry, obey.\n    if (shouldRetryHeader === 'true') return true;\n    if (shouldRetryHeader === 'false') return false;\n\n    // Retry on request timeouts.\n    if (response.status === 408) return true;\n\n    // Retry on lock timeouts.\n    if (response.status === 409) return true;\n\n    // Retry on rate limits.\n    if (response.status === 429) return true;\n\n    // Retry internal errors.\n    if (response.status >= 500) return true;\n\n    return false;\n  }\n\n  private async retryRequest(\n    options: FinalRequestOptions,\n    retriesRemaining: number,\n    responseHeaders?: Headers | undefined,\n  ): Promise<APIResponseProps> {\n    let timeoutMillis: number | undefined;\n\n    // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n    const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n    if (retryAfterMillisHeader) {\n      const timeoutMs = parseFloat(retryAfterMillisHeader);\n      if (!Number.isNaN(timeoutMs)) {\n        timeoutMillis = timeoutMs;\n      }\n    }\n\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n    const retryAfterHeader = responseHeaders?.['retry-after'];\n    if (retryAfterHeader && !timeoutMillis) {\n      const timeoutSeconds = parseFloat(retryAfterHeader);\n      if (!Number.isNaN(timeoutSeconds)) {\n        timeoutMillis = timeoutSeconds * 1000;\n      } else {\n        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n      }\n    }\n\n    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n    // just do what it says, but otherwise calculate a default\n    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n      const maxRetries = options.maxRetries ?? this.maxRetries;\n      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n    }\n    await sleep(timeoutMillis);\n\n    return this.makeRequest(options, retriesRemaining - 1);\n  }\n\n  private calculateDefaultRetryTimeoutMillis(retriesRemaining: number, maxRetries: number): number {\n    const initialRetryDelay = 0.5;\n    const maxRetryDelay = 8.0;\n\n    const numRetries = maxRetries - retriesRemaining;\n\n    // Apply exponential backoff, but not more than the max.\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n\n    // Apply some jitter, take up to at most 25 percent of the retry time.\n    const jitter = 1 - Math.random() * 0.25;\n\n    return sleepSeconds * jitter * 1000;\n  }\n\n  private getUserAgent(): string {\n    return `${this.constructor.name}/JS ${VERSION}`;\n  }\n}\n\nexport type PageInfo = { url: URL } | { params: Record<string, unknown> | null };\n\nexport abstract class AbstractPage<Item> implements AsyncIterable<Item> {\n  #client: APIClient;\n  protected options: FinalRequestOptions;\n\n  protected response: Response;\n  protected body: unknown;\n\n  constructor(client: APIClient, response: Response, body: unknown, options: FinalRequestOptions) {\n    this.#client = client;\n    this.options = options;\n    this.response = response;\n    this.body = body;\n  }\n\n  /**\n   * @deprecated Use nextPageInfo instead\n   */\n  abstract nextPageParams(): Partial<Record<string, unknown>> | null;\n  abstract nextPageInfo(): PageInfo | null;\n\n  abstract getPaginatedItems(): Item[];\n\n  hasNextPage(): boolean {\n    const items = this.getPaginatedItems();\n    if (!items.length) return false;\n    return this.nextPageInfo() != null;\n  }\n\n  async getNextPage(): Promise<this> {\n    const nextInfo = this.nextPageInfo();\n    if (!nextInfo) {\n      throw new GroqError(\n        'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.',\n      );\n    }\n    const nextOptions = { ...this.options };\n    if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n    } else if ('url' in nextInfo) {\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n      for (const [key, value] of params) {\n        nextInfo.url.searchParams.set(key, value as any);\n      }\n      nextOptions.query = undefined;\n      nextOptions.path = nextInfo.url.toString();\n    }\n    return await this.#client.requestAPIList(this.constructor as any, nextOptions);\n  }\n\n  async *iterPages(): AsyncGenerator<this> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: this = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise<\n    PageClass extends AbstractPage<Item>,\n    Item = ReturnType<PageClass['getPaginatedItems']>[number],\n  >\n  extends APIPromise<PageClass>\n  implements AsyncIterable<Item>\n{\n  constructor(\n    client: APIClient,\n    request: Promise<APIResponseProps>,\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\n  ) {\n    super(\n      request,\n      async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options),\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport const createResponseHeaders = (\n  headers: Awaited<ReturnType<Fetch>>['headers'],\n): Record<string, string> => {\n  return new Proxy(\n    Object.fromEntries(\n      // @ts-ignore\n      headers.entries(),\n    ),\n    {\n      get(target, name) {\n        const key = name.toString();\n        return target[key.toLowerCase()] || target[key];\n      },\n    },\n  );\n};\n\ntype HTTPMethod = 'get' | 'post' | 'put' | 'patch' | 'delete';\n\nexport type RequestClient = { fetch: Fetch };\nexport type Headers = Record<string, string | null | undefined>;\nexport type DefaultQuery = Record<string, string | undefined>;\nexport type KeysEnum<T> = { [P in keyof Required<T>]: true };\n\nexport type RequestOptions<\n  Req = unknown | Record<string, unknown> | Readable | BlobLike | ArrayBufferView | ArrayBuffer,\n> = {\n  method?: HTTPMethod;\n  path?: string;\n  query?: Req | undefined;\n  body?: Req | null | undefined;\n  headers?: Headers | undefined;\n\n  maxRetries?: number;\n  stream?: boolean | undefined;\n  timeout?: number;\n  httpAgent?: Agent;\n  signal?: AbortSignal | undefined | null;\n  idempotencyKey?: string;\n\n  __binaryRequest?: boolean | undefined;\n  __binaryResponse?: boolean | undefined;\n  __streamClass?: typeof Stream;\n};\n\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys: KeysEnum<RequestOptions> = {\n  method: true,\n  path: true,\n  query: true,\n  body: true,\n  headers: true,\n\n  maxRetries: true,\n  stream: true,\n  timeout: true,\n  httpAgent: true,\n  signal: true,\n  idempotencyKey: true,\n\n  __binaryRequest: true,\n  __binaryResponse: true,\n  __streamClass: true,\n};\n\nexport const isRequestOptions = (obj: unknown): obj is RequestOptions => {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    !isEmptyObj(obj) &&\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\n  );\n};\n\nexport type FinalRequestOptions<Req = unknown | Record<string, unknown> | Readable | DataView> =\n  RequestOptions<Req> & {\n    method: HTTPMethod;\n    path: string;\n  };\n\ndeclare const Deno: any;\ndeclare const EdgeRuntime: any;\ntype Arch = 'x32' | 'x64' | 'arm' | 'arm64' | `other:${string}` | 'unknown';\ntype PlatformName =\n  | 'MacOS'\n  | 'Linux'\n  | 'Windows'\n  | 'FreeBSD'\n  | 'OpenBSD'\n  | 'iOS'\n  | 'Android'\n  | `Other:${string}`\n  | 'Unknown';\ntype Browser = 'ie' | 'edge' | 'chrome' | 'firefox' | 'safari';\ntype PlatformProperties = {\n  'X-Stainless-Lang': 'js';\n  'X-Stainless-Package-Version': string;\n  'X-Stainless-OS': PlatformName;\n  'X-Stainless-Arch': Arch;\n  'X-Stainless-Runtime': 'node' | 'deno' | 'edge' | `browser:${Browser}` | 'unknown';\n  'X-Stainless-Runtime-Version': string;\n};\nconst getPlatformProperties = (): PlatformProperties => {\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n      'X-Stainless-Runtime': 'deno',\n      'X-Stainless-Runtime-Version':\n        typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n    };\n  }\n  if (typeof EdgeRuntime !== 'undefined') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\n      'X-Stainless-Runtime': 'edge',\n      'X-Stainless-Runtime-Version': process.version,\n    };\n  }\n  // Check if Node.js\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(process.platform),\n      'X-Stainless-Arch': normalizeArch(process.arch),\n      'X-Stainless-Runtime': 'node',\n      'X-Stainless-Runtime-Version': process.version,\n    };\n  }\n\n  const browserInfo = getBrowserInfo();\n  if (browserInfo) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': 'unknown',\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n      'X-Stainless-Runtime-Version': browserInfo.version,\n    };\n  }\n\n  // TODO add support for Cloudflare workers, etc.\n  return {\n    'X-Stainless-Lang': 'js',\n    'X-Stainless-Package-Version': VERSION,\n    'X-Stainless-OS': 'Unknown',\n    'X-Stainless-Arch': 'unknown',\n    'X-Stainless-Runtime': 'unknown',\n    'X-Stainless-Runtime-Version': 'unknown',\n  };\n};\n\ntype BrowserInfo = {\n  browser: Browser;\n  version: string;\n};\n\ndeclare const navigator: { userAgent: string } | undefined;\n\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo(): BrowserInfo | null {\n  if (typeof navigator === 'undefined' || !navigator) {\n    return null;\n  }\n\n  // NOTE: The order matters here!\n  const browserPatterns = [\n    { key: 'edge' as const, pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'ie' as const, pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'ie' as const, pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'chrome' as const, pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'firefox' as const, pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n    { key: 'safari' as const, pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n  ];\n\n  // Find the FIRST matching browser\n  for (const { key, pattern } of browserPatterns) {\n    const match = pattern.exec(navigator.userAgent);\n    if (match) {\n      const major = match[1] || 0;\n      const minor = match[2] || 0;\n      const patch = match[3] || 0;\n\n      return { browser: key, version: `${major}.${minor}.${patch}` };\n    }\n  }\n\n  return null;\n}\n\nconst normalizeArch = (arch: string): Arch => {\n  // Node docs:\n  // - https://nodejs.org/api/process.html#processarch\n  // Deno docs:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  if (arch === 'x32') return 'x32';\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\n  if (arch === 'arm') return 'arm';\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\n  if (arch) return `other:${arch}`;\n  return 'unknown';\n};\n\nconst normalizePlatform = (platform: string): PlatformName => {\n  // Node platforms:\n  // - https://nodejs.org/api/process.html#processplatform\n  // Deno platforms:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  // - https://github.com/denoland/deno/issues/14799\n\n  platform = platform.toLowerCase();\n\n  // NOTE: this iOS check is untested and may not work\n  // Node does not work natively on IOS, there is a fork at\n  // https://github.com/nodejs-mobile/nodejs-mobile\n  // however it is unknown at the time of writing how to detect if it is running\n  if (platform.includes('ios')) return 'iOS';\n  if (platform === 'android') return 'Android';\n  if (platform === 'darwin') return 'MacOS';\n  if (platform === 'win32') return 'Windows';\n  if (platform === 'freebsd') return 'FreeBSD';\n  if (platform === 'openbsd') return 'OpenBSD';\n  if (platform === 'linux') return 'Linux';\n  if (platform) return `Other:${platform}`;\n  return 'Unknown';\n};\n\nlet _platformHeaders: PlatformProperties;\nconst getPlatformHeaders = () => {\n  return (_platformHeaders ??= getPlatformProperties());\n};\n\nexport const safeJSON = (text: string) => {\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    return undefined;\n  }\n};\n\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = (url: string): boolean => {\n  return startsWithSchemeRegexp.test(url);\n};\n\nexport const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst validatePositiveInteger = (name: string, n: unknown): number => {\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\n    throw new GroqError(`${name} must be an integer`);\n  }\n  if (n < 0) {\n    throw new GroqError(`${name} must be a positive integer`);\n  }\n  return n;\n};\n\nexport const castToError = (err: any): Error => {\n  if (err instanceof Error) return err;\n  if (typeof err === 'object' && err !== null) {\n    try {\n      return new Error(JSON.stringify(err));\n    } catch {}\n  }\n  return new Error(err);\n};\n\nexport const ensurePresent = <T>(value: T | null | undefined): T => {\n  if (value == null) throw new GroqError(`Expected a value to be given but received ${value} instead.`);\n  return value;\n};\n\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env: string): string | undefined => {\n  if (typeof process !== 'undefined') {\n    return process.env?.[env]?.trim() ?? undefined;\n  }\n  if (typeof Deno !== 'undefined') {\n    return Deno.env?.get?.(env)?.trim();\n  }\n  return undefined;\n};\n\nexport const coerceInteger = (value: unknown): number => {\n  if (typeof value === 'number') return Math.round(value);\n  if (typeof value === 'string') return parseInt(value, 10);\n\n  throw new GroqError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\n\nexport const coerceFloat = (value: unknown): number => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') return parseFloat(value);\n\n  throw new GroqError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\n\nexport const coerceBoolean = (value: unknown): boolean => {\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'string') return value === 'true';\n  return Boolean(value);\n};\n\nexport const maybeCoerceInteger = (value: unknown): number | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceInteger(value);\n};\n\nexport const maybeCoerceFloat = (value: unknown): number | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceFloat(value);\n};\n\nexport const maybeCoerceBoolean = (value: unknown): boolean | undefined => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceBoolean(value);\n};\n\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj: Object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */\nfunction applyHeadersMut(targetHeaders: Headers, newHeaders: Headers): void {\n  for (const k in newHeaders) {\n    if (!hasOwn(newHeaders, k)) continue;\n    const lowerKey = k.toLowerCase();\n    if (!lowerKey) continue;\n\n    const val = newHeaders[k];\n\n    if (val === null) {\n      delete targetHeaders[lowerKey];\n    } else if (val !== undefined) {\n      targetHeaders[lowerKey] = val;\n    }\n  }\n}\n\nexport function debug(action: string, ...args: any[]) {\n  if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\n    console.log(`Groq:DEBUG:${action}`, ...args);\n  }\n}\n\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\nexport const isRunningInBrowser = () => {\n  return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n    // @ts-ignore\n    typeof window.document !== 'undefined' &&\n    // @ts-ignore\n    typeof navigator !== 'undefined'\n  );\n};\n\nexport interface HeadersProtocol {\n  get: (header: string) => string | null | undefined;\n}\nexport type HeadersLike = Record<string, string | string[] | undefined> | HeadersProtocol;\n\nexport const isHeadersProtocol = (headers: any): headers is HeadersProtocol => {\n  return typeof headers?.get === 'function';\n};\n\nexport const getRequiredHeader = (headers: HeadersLike | Headers, header: string): string => {\n  const foundHeader = getHeader(headers, header);\n  if (foundHeader === undefined) {\n    throw new Error(`Could not find ${header} header`);\n  }\n  return foundHeader;\n};\n\nexport const getHeader = (headers: HeadersLike | Headers, header: string): string | undefined => {\n  const lowerCasedHeader = header.toLowerCase();\n  if (isHeadersProtocol(headers)) {\n    // to deal with the case where the header looks like Stainless-Event-Id\n    const intercapsHeader =\n      header[0]?.toUpperCase() +\n      header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n      const value = headers.get(key);\n      if (value) {\n        return value;\n      }\n    }\n  }\n\n  for (const [key, value] of Object.entries(headers)) {\n    if (key.toLowerCase() === lowerCasedHeader) {\n      if (Array.isArray(value)) {\n        if (value.length <= 1) return value[0];\n        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n        return value[0];\n      }\n      return value;\n    }\n  }\n\n  return undefined;\n};\n\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = (str: string | null | undefined): string => {\n  if (!str) return '';\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(str).toString('base64');\n  }\n\n  if (typeof btoa !== 'undefined') {\n    return btoa(str);\n  }\n\n  throw new GroqError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\n\nexport function isObj(obj: unknown): obj is Record<string, unknown> {\n  return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport type { Groq } from './index';\n\nexport class APIResource {\n  protected _client: Groq;\n\n  constructor(client: Groq) {\n    this._client = client;\n  }\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as Core from '../../core';\nimport { type Response } from '../../_shims/index';\n\nexport class Speech extends APIResource {\n  /**\n   * Generates audio from the input text.\n   */\n  create(body: SpeechCreateParams, options?: Core.RequestOptions): Core.APIPromise<Response> {\n    return this._client.post('/openai/v1/audio/speech', {\n      body,\n      ...options,\n      headers: { Accept: 'application/octet-stream', ...options?.headers },\n      __binaryResponse: true,\n    });\n  }\n}\n\nexport interface SpeechCreateParams {\n  /**\n   * The text to generate audio for.\n   */\n  input: string;\n\n  /**\n   * One of the available TTS models\n   */\n  model: string;\n\n  /**\n   * The voice to use when generating the audio.\n   */\n  voice: string;\n\n  /**\n   * The format to audio in. Supported formats are `wav`.\n   */\n  response_format?: 'wav';\n\n  /**\n   * The speed of the generated audio. 1.0 is the only supported value.\n   */\n  speed?: number;\n}\n\nexport declare namespace Speech {\n  export { type SpeechCreateParams as SpeechCreateParams };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as Core from '../../core';\n\nexport class Transcriptions extends APIResource {\n  /**\n   * Transcribes audio into the input language.\n   */\n  create(body: TranscriptionCreateParams, options?: Core.RequestOptions): Core.APIPromise<Transcription> {\n    return this._client.post(\n      '/openai/v1/audio/transcriptions',\n      Core.multipartFormRequestOptions({ body, ...options }),\n    );\n  }\n}\n\n/**\n * Represents a transcription response returned by model, based on the provided\n * input.\n */\nexport interface Transcription {\n  /**\n   * The transcribed text.\n   */\n  text: string;\n}\n\nexport interface TranscriptionCreateParams {\n  /**\n   * ID of the model to use. Only `whisper-large-v3` is currently available.\n   */\n  model: (string & {}) | 'whisper-large-v3';\n\n  /**\n   * The audio file object (not file name) to transcribe, in one of these formats:\n   * flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. Either a file or a URL must\n   * be provided. Note that the file field is not supported in Batch API requests.\n   */\n  file?: Core.Uploadable;\n\n  /**\n   * The language of the input audio. Supplying the input language in\n   * [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will\n   * improve accuracy and latency.\n   */\n  language?:\n    | (string & {})\n    | 'en'\n    | 'zh'\n    | 'de'\n    | 'es'\n    | 'ru'\n    | 'ko'\n    | 'fr'\n    | 'ja'\n    | 'pt'\n    | 'tr'\n    | 'pl'\n    | 'ca'\n    | 'nl'\n    | 'ar'\n    | 'sv'\n    | 'it'\n    | 'id'\n    | 'hi'\n    | 'fi'\n    | 'vi'\n    | 'he'\n    | 'uk'\n    | 'el'\n    | 'ms'\n    | 'cs'\n    | 'ro'\n    | 'da'\n    | 'hu'\n    | 'ta'\n    | 'no'\n    | 'th'\n    | 'ur'\n    | 'hr'\n    | 'bg'\n    | 'lt'\n    | 'la'\n    | 'mi'\n    | 'ml'\n    | 'cy'\n    | 'sk'\n    | 'te'\n    | 'fa'\n    | 'lv'\n    | 'bn'\n    | 'sr'\n    | 'az'\n    | 'sl'\n    | 'kn'\n    | 'et'\n    | 'mk'\n    | 'br'\n    | 'eu'\n    | 'is'\n    | 'hy'\n    | 'ne'\n    | 'mn'\n    | 'bs'\n    | 'kk'\n    | 'sq'\n    | 'sw'\n    | 'gl'\n    | 'mr'\n    | 'pa'\n    | 'si'\n    | 'km'\n    | 'sn'\n    | 'yo'\n    | 'so'\n    | 'af'\n    | 'oc'\n    | 'ka'\n    | 'be'\n    | 'tg'\n    | 'sd'\n    | 'gu'\n    | 'am'\n    | 'yi'\n    | 'lo'\n    | 'uz'\n    | 'fo'\n    | 'ht'\n    | 'ps'\n    | 'tk'\n    | 'nn'\n    | 'mt'\n    | 'sa'\n    | 'lb'\n    | 'my'\n    | 'bo'\n    | 'tl'\n    | 'mg'\n    | 'as'\n    | 'tt'\n    | 'haw'\n    | 'ln'\n    | 'ha'\n    | 'ba'\n    | 'jv'\n    | 'su'\n    | 'yue';\n\n  /**\n   * An optional text to guide the model's style or continue a previous audio\n   * segment. The [prompt](/docs/speech-text) should match the audio language.\n   */\n  prompt?: string;\n\n  /**\n   * The format of the transcript output, in one of these options: `json`, `text`, or\n   * `verbose_json`.\n   */\n  response_format?: 'json' | 'text' | 'verbose_json';\n\n  /**\n   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the\n   * output more random, while lower values like 0.2 will make it more focused and\n   * deterministic. If set to 0, the model will use\n   * [log probability](https://en.wikipedia.org/wiki/Log_probability) to\n   * automatically increase the temperature until certain thresholds are hit.\n   */\n  temperature?: number;\n\n  /**\n   * The timestamp granularities to populate for this transcription.\n   * `response_format` must be set `verbose_json` to use timestamp granularities.\n   * Either or both of these options are supported: `word`, or `segment`. Note: There\n   * is no additional latency for segment timestamps, but generating word timestamps\n   * incurs additional latency.\n   */\n  timestamp_granularities?: Array<'word' | 'segment'>;\n\n  /**\n   * The audio URL to translate/transcribe (supports Base64URL). Either a file or a\n   * URL must be provided. For Batch API requests, the URL field is required since\n   * the file field is not supported.\n   */\n  url?: string;\n}\n\nexport declare namespace Transcriptions {\n  export { type Transcription as Transcription, type TranscriptionCreateParams as TranscriptionCreateParams };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as Core from '../../core';\n\nexport class Translations extends APIResource {\n  /**\n   * Translates audio into English.\n   */\n  create(body: TranslationCreateParams, options?: Core.RequestOptions): Core.APIPromise<Translation> {\n    return this._client.post(\n      '/openai/v1/audio/translations',\n      Core.multipartFormRequestOptions({ body, ...options }),\n    );\n  }\n}\n\nexport interface Translation {\n  text: string;\n}\n\nexport interface TranslationCreateParams {\n  /**\n   * ID of the model to use. Only `whisper-large-v3` is currently available.\n   */\n  model: (string & {}) | 'whisper-large-v3';\n\n  /**\n   * The audio file object (not file name) translate, in one of these formats: flac,\n   * mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n   */\n  file?: Core.Uploadable;\n\n  /**\n   * An optional text to guide the model's style or continue a previous audio\n   * segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in\n   * English.\n   */\n  prompt?: string;\n\n  /**\n   * The format of the transcript output, in one of these options: `json`, `text`, or\n   * `verbose_json`.\n   */\n  response_format?: 'json' | 'text' | 'verbose_json';\n\n  /**\n   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the\n   * output more random, while lower values like 0.2 will make it more focused and\n   * deterministic. If set to 0, the model will use\n   * [log probability](https://en.wikipedia.org/wiki/Log_probability) to\n   * automatically increase the temperature until certain thresholds are hit.\n   */\n  temperature?: number;\n\n  /**\n   * The audio URL to translate/transcribe (supports Base64URL). Either file or url\n   * must be provided. When using the Batch API only url is supported.\n   */\n  url?: string;\n}\n\nexport declare namespace Translations {\n  export { type Translation as Translation, type TranslationCreateParams as TranslationCreateParams };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as SpeechAPI from './speech';\nimport { Speech, SpeechCreateParams } from './speech';\nimport * as TranscriptionsAPI from './transcriptions';\nimport { Transcription, TranscriptionCreateParams, Transcriptions } from './transcriptions';\nimport * as TranslationsAPI from './translations';\nimport { Translation, TranslationCreateParams, Translations } from './translations';\n\nexport class Audio extends APIResource {\n  speech: SpeechAPI.Speech = new SpeechAPI.Speech(this._client);\n  transcriptions: TranscriptionsAPI.Transcriptions = new TranscriptionsAPI.Transcriptions(this._client);\n  translations: TranslationsAPI.Translations = new TranslationsAPI.Translations(this._client);\n}\n\nAudio.Speech = Speech;\nAudio.Transcriptions = Transcriptions;\nAudio.Translations = Translations;\n\nexport declare namespace Audio {\n  export { Speech as Speech, type SpeechCreateParams as SpeechCreateParams };\n\n  export {\n    Transcriptions as Transcriptions,\n    type Transcription as Transcription,\n    type TranscriptionCreateParams as TranscriptionCreateParams,\n  };\n\n  export {\n    Translations as Translations,\n    type Translation as Translation,\n    type TranslationCreateParams as TranslationCreateParams,\n  };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport * as Core from '../core';\n\nexport class Batches extends APIResource {\n  /**\n   * Creates and executes a batch from an uploaded file of requests\n   */\n  create(body: BatchCreateParams, options?: Core.RequestOptions): Core.APIPromise<BatchCreateResponse> {\n    return this._client.post('/openai/v1/batches', { body, ...options });\n  }\n\n  /**\n   * Retrieves a batch.\n   */\n  retrieve(batchId: string, options?: Core.RequestOptions): Core.APIPromise<BatchRetrieveResponse> {\n    return this._client.get(`/openai/v1/batches/${batchId}`, options);\n  }\n\n  /**\n   * List your organization's batches.\n   */\n  list(options?: Core.RequestOptions): Core.APIPromise<BatchListResponse> {\n    return this._client.get('/openai/v1/batches', options);\n  }\n\n  /**\n   * Cancels a batch.\n   */\n  cancel(batchId: string, options?: Core.RequestOptions): Core.APIPromise<BatchCancelResponse> {\n    return this._client.post(`/openai/v1/batches/${batchId}/cancel`, options);\n  }\n}\n\nexport interface BatchCreateResponse {\n  id: string;\n\n  /**\n   * The time frame within which the batch should be processed.\n   */\n  completion_window: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was created.\n   */\n  created_at: number;\n\n  /**\n   * The API endpoint used by the batch.\n   */\n  endpoint: string;\n\n  /**\n   * The ID of the input file for the batch.\n   */\n  input_file_id: string;\n\n  /**\n   * The object type, which is always `batch`.\n   */\n  object: 'batch';\n\n  /**\n   * The current status of the batch.\n   */\n  status:\n    | 'validating'\n    | 'failed'\n    | 'in_progress'\n    | 'finalizing'\n    | 'completed'\n    | 'expired'\n    | 'cancelling'\n    | 'cancelled';\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was cancelled.\n   */\n  cancelled_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started cancelling.\n   */\n  cancelling_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was completed.\n   */\n  completed_at?: number;\n\n  /**\n   * The ID of the file containing the outputs of requests with errors.\n   */\n  error_file_id?: string;\n\n  errors?: BatchCreateResponse.Errors;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch expired.\n   */\n  expired_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch will expire.\n   */\n  expires_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch failed.\n   */\n  failed_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started finalizing.\n   */\n  finalizing_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started processing.\n   */\n  in_progress_at?: number;\n\n  /**\n   * Set of key-value pairs that can be attached to an object. This can be useful for\n   * storing additional information about the object in a structured format.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the file containing the outputs of successfully executed requests.\n   */\n  output_file_id?: string;\n\n  /**\n   * The request counts for different statuses within the batch.\n   */\n  request_counts?: BatchCreateResponse.RequestCounts;\n}\n\nexport namespace BatchCreateResponse {\n  export interface Errors {\n    data?: Array<Errors.Data>;\n\n    /**\n     * The object type, which is always `list`.\n     */\n    object?: string;\n  }\n\n  export namespace Errors {\n    export interface Data {\n      /**\n       * An error code identifying the error type.\n       */\n      code?: string;\n\n      /**\n       * The line number of the input file where the error occurred, if applicable.\n       */\n      line?: number | null;\n\n      /**\n       * A human-readable message providing more details about the error.\n       */\n      message?: string;\n\n      /**\n       * The name of the parameter that caused the error, if applicable.\n       */\n      param?: string | null;\n    }\n  }\n\n  /**\n   * The request counts for different statuses within the batch.\n   */\n  export interface RequestCounts {\n    /**\n     * Number of requests that have been completed successfully.\n     */\n    completed: number;\n\n    /**\n     * Number of requests that have failed.\n     */\n    failed: number;\n\n    /**\n     * Total number of requests in the batch.\n     */\n    total: number;\n  }\n}\n\nexport interface BatchRetrieveResponse {\n  id: string;\n\n  /**\n   * The time frame within which the batch should be processed.\n   */\n  completion_window: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was created.\n   */\n  created_at: number;\n\n  /**\n   * The API endpoint used by the batch.\n   */\n  endpoint: string;\n\n  /**\n   * The ID of the input file for the batch.\n   */\n  input_file_id: string;\n\n  /**\n   * The object type, which is always `batch`.\n   */\n  object: 'batch';\n\n  /**\n   * The current status of the batch.\n   */\n  status:\n    | 'validating'\n    | 'failed'\n    | 'in_progress'\n    | 'finalizing'\n    | 'completed'\n    | 'expired'\n    | 'cancelling'\n    | 'cancelled';\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was cancelled.\n   */\n  cancelled_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started cancelling.\n   */\n  cancelling_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was completed.\n   */\n  completed_at?: number;\n\n  /**\n   * The ID of the file containing the outputs of requests with errors.\n   */\n  error_file_id?: string;\n\n  errors?: BatchRetrieveResponse.Errors;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch expired.\n   */\n  expired_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch will expire.\n   */\n  expires_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch failed.\n   */\n  failed_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started finalizing.\n   */\n  finalizing_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started processing.\n   */\n  in_progress_at?: number;\n\n  /**\n   * Set of key-value pairs that can be attached to an object. This can be useful for\n   * storing additional information about the object in a structured format.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the file containing the outputs of successfully executed requests.\n   */\n  output_file_id?: string;\n\n  /**\n   * The request counts for different statuses within the batch.\n   */\n  request_counts?: BatchRetrieveResponse.RequestCounts;\n}\n\nexport namespace BatchRetrieveResponse {\n  export interface Errors {\n    data?: Array<Errors.Data>;\n\n    /**\n     * The object type, which is always `list`.\n     */\n    object?: string;\n  }\n\n  export namespace Errors {\n    export interface Data {\n      /**\n       * An error code identifying the error type.\n       */\n      code?: string;\n\n      /**\n       * The line number of the input file where the error occurred, if applicable.\n       */\n      line?: number | null;\n\n      /**\n       * A human-readable message providing more details about the error.\n       */\n      message?: string;\n\n      /**\n       * The name of the parameter that caused the error, if applicable.\n       */\n      param?: string | null;\n    }\n  }\n\n  /**\n   * The request counts for different statuses within the batch.\n   */\n  export interface RequestCounts {\n    /**\n     * Number of requests that have been completed successfully.\n     */\n    completed: number;\n\n    /**\n     * Number of requests that have failed.\n     */\n    failed: number;\n\n    /**\n     * Total number of requests in the batch.\n     */\n    total: number;\n  }\n}\n\nexport interface BatchListResponse {\n  data: Array<BatchListResponse.Data>;\n\n  object: 'list';\n}\n\nexport namespace BatchListResponse {\n  export interface Data {\n    id: string;\n\n    /**\n     * The time frame within which the batch should be processed.\n     */\n    completion_window: string;\n\n    /**\n     * The Unix timestamp (in seconds) for when the batch was created.\n     */\n    created_at: number;\n\n    /**\n     * The API endpoint used by the batch.\n     */\n    endpoint: string;\n\n    /**\n     * The ID of the input file for the batch.\n     */\n    input_file_id: string;\n\n    /**\n     * The object type, which is always `batch`.\n     */\n    object: 'batch';\n\n    /**\n     * The current status of the batch.\n     */\n    status:\n      | 'validating'\n      | 'failed'\n      | 'in_progress'\n      | 'finalizing'\n      | 'completed'\n      | 'expired'\n      | 'cancelling'\n      | 'cancelled';\n\n    /**\n     * The Unix timestamp (in seconds) for when the batch was cancelled.\n     */\n    cancelled_at?: number;\n\n    /**\n     * The Unix timestamp (in seconds) for when the batch started cancelling.\n     */\n    cancelling_at?: number;\n\n    /**\n     * The Unix timestamp (in seconds) for when the batch was completed.\n     */\n    completed_at?: number;\n\n    /**\n     * The ID of the file containing the outputs of requests with errors.\n     */\n    error_file_id?: string;\n\n    errors?: Data.Errors;\n\n    /**\n     * The Unix timestamp (in seconds) for when the batch expired.\n     */\n    expired_at?: number;\n\n    /**\n     * The Unix timestamp (in seconds) for when the batch will expire.\n     */\n    expires_at?: number;\n\n    /**\n     * The Unix timestamp (in seconds) for when the batch failed.\n     */\n    failed_at?: number;\n\n    /**\n     * The Unix timestamp (in seconds) for when the batch started finalizing.\n     */\n    finalizing_at?: number;\n\n    /**\n     * The Unix timestamp (in seconds) for when the batch started processing.\n     */\n    in_progress_at?: number;\n\n    /**\n     * Set of key-value pairs that can be attached to an object. This can be useful for\n     * storing additional information about the object in a structured format.\n     */\n    metadata?: unknown | null;\n\n    /**\n     * The ID of the file containing the outputs of successfully executed requests.\n     */\n    output_file_id?: string;\n\n    /**\n     * The request counts for different statuses within the batch.\n     */\n    request_counts?: Data.RequestCounts;\n  }\n\n  export namespace Data {\n    export interface Errors {\n      data?: Array<Errors.Data>;\n\n      /**\n       * The object type, which is always `list`.\n       */\n      object?: string;\n    }\n\n    export namespace Errors {\n      export interface Data {\n        /**\n         * An error code identifying the error type.\n         */\n        code?: string;\n\n        /**\n         * The line number of the input file where the error occurred, if applicable.\n         */\n        line?: number | null;\n\n        /**\n         * A human-readable message providing more details about the error.\n         */\n        message?: string;\n\n        /**\n         * The name of the parameter that caused the error, if applicable.\n         */\n        param?: string | null;\n      }\n    }\n\n    /**\n     * The request counts for different statuses within the batch.\n     */\n    export interface RequestCounts {\n      /**\n       * Number of requests that have been completed successfully.\n       */\n      completed: number;\n\n      /**\n       * Number of requests that have failed.\n       */\n      failed: number;\n\n      /**\n       * Total number of requests in the batch.\n       */\n      total: number;\n    }\n  }\n}\n\nexport interface BatchCancelResponse {\n  id: string;\n\n  /**\n   * The time frame within which the batch should be processed.\n   */\n  completion_window: string;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was created.\n   */\n  created_at: number;\n\n  /**\n   * The API endpoint used by the batch.\n   */\n  endpoint: string;\n\n  /**\n   * The ID of the input file for the batch.\n   */\n  input_file_id: string;\n\n  /**\n   * The object type, which is always `batch`.\n   */\n  object: 'batch';\n\n  /**\n   * The current status of the batch.\n   */\n  status:\n    | 'validating'\n    | 'failed'\n    | 'in_progress'\n    | 'finalizing'\n    | 'completed'\n    | 'expired'\n    | 'cancelling'\n    | 'cancelled';\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was cancelled.\n   */\n  cancelled_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started cancelling.\n   */\n  cancelling_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch was completed.\n   */\n  completed_at?: number;\n\n  /**\n   * The ID of the file containing the outputs of requests with errors.\n   */\n  error_file_id?: string;\n\n  errors?: BatchCancelResponse.Errors;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch expired.\n   */\n  expired_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch will expire.\n   */\n  expires_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch failed.\n   */\n  failed_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started finalizing.\n   */\n  finalizing_at?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the batch started processing.\n   */\n  in_progress_at?: number;\n\n  /**\n   * Set of key-value pairs that can be attached to an object. This can be useful for\n   * storing additional information about the object in a structured format.\n   */\n  metadata?: unknown | null;\n\n  /**\n   * The ID of the file containing the outputs of successfully executed requests.\n   */\n  output_file_id?: string;\n\n  /**\n   * The request counts for different statuses within the batch.\n   */\n  request_counts?: BatchCancelResponse.RequestCounts;\n}\n\nexport namespace BatchCancelResponse {\n  export interface Errors {\n    data?: Array<Errors.Data>;\n\n    /**\n     * The object type, which is always `list`.\n     */\n    object?: string;\n  }\n\n  export namespace Errors {\n    export interface Data {\n      /**\n       * An error code identifying the error type.\n       */\n      code?: string;\n\n      /**\n       * The line number of the input file where the error occurred, if applicable.\n       */\n      line?: number | null;\n\n      /**\n       * A human-readable message providing more details about the error.\n       */\n      message?: string;\n\n      /**\n       * The name of the parameter that caused the error, if applicable.\n       */\n      param?: string | null;\n    }\n  }\n\n  /**\n   * The request counts for different statuses within the batch.\n   */\n  export interface RequestCounts {\n    /**\n     * Number of requests that have been completed successfully.\n     */\n    completed: number;\n\n    /**\n     * Number of requests that have failed.\n     */\n    failed: number;\n\n    /**\n     * Total number of requests in the batch.\n     */\n    total: number;\n  }\n}\n\nexport interface BatchCreateParams {\n  /**\n   * The time frame within which the batch should be processed. Currently only `24h`\n   * is supported.\n   */\n  completion_window: '24h';\n\n  /**\n   * The endpoint to be used for all requests in the batch. Currently\n   * `/v1/chat/completions` is supported.\n   */\n  endpoint: '/v1/chat/completions';\n\n  /**\n   * The ID of an uploaded file that contains requests for the new batch.\n   *\n   * See [upload file](/docs/api-reference#files-upload) for how to upload a file.\n   *\n   * Your input file must be formatted as a [JSONL file](/docs/batch), and must be\n   * uploaded with the purpose `batch`. The file can be up to 100 MB in size.\n   */\n  input_file_id: string;\n\n  /**\n   * Optional custom metadata for the batch.\n   */\n  metadata?: Record<string, string> | null;\n}\n\nexport declare namespace Batches {\n  export {\n    type BatchCreateResponse as BatchCreateResponse,\n    type BatchRetrieveResponse as BatchRetrieveResponse,\n    type BatchListResponse as BatchListResponse,\n    type BatchCancelResponse as BatchCancelResponse,\n    type BatchCreateParams as BatchCreateParams,\n  };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as Core from '../../core';\nimport * as ChatCompletionsAPI from './completions';\nimport * as CompletionsAPI from '../completions';\nimport * as Shared from '../shared';\nimport { Stream } from '../../lib/streaming';\n\nexport class Completions extends APIResource {\n  /**\n   * Creates a model response for the given chat conversation.\n   */\n  create(\n    body: ChatCompletionCreateParamsNonStreaming,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<ChatCompletion>;\n  create(\n    body: ChatCompletionCreateParamsStreaming,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Stream<ChatCompletionChunk>>;\n  create(\n    body: ChatCompletionCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<Stream<ChatCompletionChunk> | ChatCompletion>;\n  create(\n    body: ChatCompletionCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<ChatCompletion> | Core.APIPromise<Stream<ChatCompletionChunk>> {\n    return this._client.post('/openai/v1/chat/completions', {\n      body,\n      ...options,\n      stream: body.stream ?? false,\n    }) as Core.APIPromise<ChatCompletion> | Core.APIPromise<Stream<ChatCompletionChunk>>;\n  }\n}\n\n/**\n * Represents a chat completion response returned by model, based on the provided\n * input.\n */\nexport interface ChatCompletion {\n  /**\n   * A unique identifier for the chat completion.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can be more than one if `n` is greater\n   * than 1.\n   */\n  choices: Array<ChatCompletion.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created.\n   */\n  created: number;\n\n  /**\n   * The model used for the chat completion.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always `chat.completion`.\n   */\n  object: 'chat.completion';\n\n  /**\n   * This fingerprint represents the backend configuration that the model runs with.\n   *\n   * Can be used in conjunction with the `seed` request parameter to understand when\n   * backend changes have been made that might impact determinism.\n   */\n  system_fingerprint?: string;\n\n  /**\n   * Usage statistics for the completion request.\n   */\n  usage?: CompletionsAPI.CompletionUsage;\n\n  /**\n   * Detailed usage breakdown by model when multiple models are used in the request\n   * for compound AI systems.\n   */\n  usage_breakdown?: ChatCompletion.UsageBreakdown;\n}\n\nexport namespace ChatCompletion {\n  export interface Choice {\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `tool_calls` if the model\n     * called a tool, or `function_call` (deprecated) if the model called a function.\n     */\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'function_call';\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n\n    /**\n     * Log probability information for the choice.\n     */\n    logprobs: Choice.Logprobs | null;\n\n    /**\n     * A chat completion message generated by the model.\n     */\n    message: ChatCompletionsAPI.ChatCompletionMessage;\n  }\n\n  export namespace Choice {\n    /**\n     * Log probability information for the choice.\n     */\n    export interface Logprobs {\n      /**\n       * A list of message content tokens with log probability information.\n       */\n      content: Array<ChatCompletionsAPI.ChatCompletionTokenLogprob> | null;\n    }\n  }\n\n  /**\n   * Detailed usage breakdown by model when multiple models are used in the request\n   * for compound AI systems.\n   */\n  export interface UsageBreakdown {\n    /**\n     * List of models used in the request and their individual usage statistics\n     */\n    models: Array<UsageBreakdown.Model>;\n  }\n\n  export namespace UsageBreakdown {\n    export interface Model {\n      /**\n       * The name/identifier of the model used\n       */\n      model: string;\n\n      /**\n       * Usage statistics for the completion request.\n       */\n      usage: CompletionsAPI.CompletionUsage;\n    }\n  }\n}\n\nexport interface ChatCompletionAssistantMessageParam {\n  /**\n   * The role of the messages author, in this case `assistant`.\n   */\n  role: 'assistant';\n\n  /**\n   * The contents of the assistant message. Required unless `tool_calls` or\n   * `function_call` is specified.\n   */\n  content?: string | null;\n\n  /**\n   * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\n   * function that should be called, as generated by the model.\n   */\n  function_call?: ChatCompletionAssistantMessageParam.FunctionCall;\n\n  /**\n   * An optional name for the participant. Provides the model information to\n   * differentiate between participants of the same role.\n   */\n  name?: string;\n\n  /**\n   * The tool calls generated by the model, such as function calls.\n   */\n  tool_calls?: Array<ChatCompletionMessageToolCall>;\n}\n\nexport namespace ChatCompletionAssistantMessageParam {\n  /**\n   * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\n   * function that should be called, as generated by the model.\n   */\n  export interface FunctionCall {\n    /**\n     * The arguments to call the function with, as generated by the model in JSON\n     * format. Note that the model does not always generate valid JSON, and may\n     * hallucinate parameters not defined by your function schema. Validate the\n     * arguments in your code before calling your function.\n     */\n    arguments?: string;\n\n    /**\n     * The name of the function to call.\n     */\n    name?: string;\n  }\n}\n\n/**\n * Represents a streamed chunk of a chat completion response returned by model,\n * based on the provided input.\n */\nexport interface ChatCompletionChunk {\n  /**\n   * A unique identifier for the chat completion. Each chunk has the same ID.\n   */\n  id: string;\n\n  /**\n   * A list of chat completion choices. Can contain more than one elements if `n` is\n   * greater than 1.\n   */\n  choices: Array<ChatCompletionChunk.Choice>;\n\n  /**\n   * The Unix timestamp (in seconds) of when the chat completion was created. Each\n   * chunk has the same timestamp.\n   */\n  created: number;\n\n  /**\n   * The model to generate the completion.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always `chat.completion.chunk`.\n   */\n  object: 'chat.completion.chunk';\n\n  /**\n   * This fingerprint represents the backend configuration that the model runs with.\n   * Can be used in conjunction with the `seed` request parameter to understand when\n   * backend changes have been made that might impact determinism.\n   */\n  system_fingerprint?: string;\n\n  x_groq?: ChatCompletionChunk.XGroq;\n}\n\nexport namespace ChatCompletionChunk {\n  export interface Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    delta: Choice.Delta;\n\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model\n     * hit a natural stop point or a provided stop sequence, `length` if the maximum\n     * number of tokens specified in the request was reached, `tool_calls` if the model\n     * called a tool, or `function_call` (deprecated) if the model called a function.\n     */\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call' | null;\n\n    /**\n     * The index of the choice in the list of choices.\n     */\n    index: number;\n\n    /**\n     * Log probability information for the choice.\n     */\n    logprobs?: Choice.Logprobs | null;\n  }\n\n  export namespace Choice {\n    /**\n     * A chat completion delta generated by streamed model responses.\n     */\n    export interface Delta {\n      /**\n       * The contents of the chunk message.\n       */\n      content?: string | null;\n\n      /**\n       * A list of tools that were executed during the chat completion for compound AI\n       * systems.\n       */\n      executed_tools?: Array<Delta.ExecutedTool>;\n\n      /**\n       * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\n       * function that should be called, as generated by the model.\n       */\n      function_call?: Delta.FunctionCall;\n\n      /**\n       * The model's reasoning for a response. Only available for reasoning models when\n       * requests parameter reasoning_format has value `parsed.\n       */\n      reasoning?: string | null;\n\n      /**\n       * The role of the author of this message.\n       */\n      role?: 'system' | 'user' | 'assistant' | 'tool';\n\n      tool_calls?: Array<Delta.ToolCall>;\n    }\n\n    export namespace Delta {\n      export interface ExecutedTool {\n        /**\n         * The arguments passed to the tool in JSON format.\n         */\n        arguments: string;\n\n        /**\n         * The index of the executed tool.\n         */\n        index: number;\n\n        /**\n         * The type of tool that was executed.\n         */\n        type: string;\n\n        /**\n         * The output returned by the tool.\n         */\n        output?: string | null;\n      }\n\n      /**\n       * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\n       * function that should be called, as generated by the model.\n       */\n      export interface FunctionCall {\n        /**\n         * The arguments to call the function with, as generated by the model in JSON\n         * format. Note that the model does not always generate valid JSON, and may\n         * hallucinate parameters not defined by your function schema. Validate the\n         * arguments in your code before calling your function.\n         */\n        arguments?: string;\n\n        /**\n         * The name of the function to call.\n         */\n        name?: string;\n      }\n\n      export interface ToolCall {\n        index: number;\n\n        /**\n         * The ID of the tool call.\n         */\n        id?: string;\n\n        function?: ToolCall.Function;\n\n        /**\n         * The type of the tool. Currently, only `function` is supported.\n         */\n        type?: 'function';\n      }\n\n      export namespace ToolCall {\n        export interface Function {\n          /**\n           * The arguments to call the function with, as generated by the model in JSON\n           * format. Note that the model does not always generate valid JSON, and may\n           * hallucinate parameters not defined by your function schema. Validate the\n           * arguments in your code before calling your function.\n           */\n          arguments?: string;\n\n          /**\n           * The name of the function to call.\n           */\n          name?: string;\n        }\n      }\n    }\n\n    /**\n     * Log probability information for the choice.\n     */\n    export interface Logprobs {\n      /**\n       * A list of message content tokens with log probability information.\n       */\n      content: Array<ChatCompletionsAPI.ChatCompletionTokenLogprob> | null;\n    }\n  }\n\n  export interface XGroq {\n    /**\n     * A groq request ID which can be used by to refer to a specific request to groq\n     * support Only sent with the first chunk\n     */\n    id?: string;\n\n    /**\n     * An error string indicating why a stream was stopped early\n     */\n    error?: string;\n\n    /**\n     * Usage information for the stream. Only sent in the final chunk\n     */\n    usage?: CompletionsAPI.CompletionUsage;\n\n    /**\n     * Detailed usage breakdown by model when multiple models are used in the request\n     * for compound AI systems. Only sent in the final chunk\n     */\n    usage_breakdown?: XGroq.UsageBreakdown;\n  }\n\n  export namespace XGroq {\n    /**\n     * Detailed usage breakdown by model when multiple models are used in the request\n     * for compound AI systems. Only sent in the final chunk\n     */\n    export interface UsageBreakdown {\n      /**\n       * List of models used in the request and their individual usage statistics\n       */\n      models: Array<UsageBreakdown.Model>;\n    }\n\n    export namespace UsageBreakdown {\n      export interface Model {\n        /**\n         * The name/identifier of the model used\n         */\n        model: string;\n\n        /**\n         * Usage statistics for the completion request.\n         */\n        usage: CompletionsAPI.CompletionUsage;\n      }\n    }\n  }\n}\n\nexport type ChatCompletionContentPart = ChatCompletionContentPartText | ChatCompletionContentPartImage;\n\nexport interface ChatCompletionContentPartImage {\n  image_url: ChatCompletionContentPartImage.ImageURL;\n\n  /**\n   * The type of the content part.\n   */\n  type: 'image_url';\n}\n\nexport namespace ChatCompletionContentPartImage {\n  export interface ImageURL {\n    /**\n     * Either a URL of the image or the base64 encoded image data.\n     */\n    url: string;\n\n    /**\n     * Specifies the detail level of the image.\n     */\n    detail?: 'auto' | 'low' | 'high';\n  }\n}\n\nexport interface ChatCompletionContentPartText {\n  /**\n   * The text content.\n   */\n  text: string;\n\n  /**\n   * The type of the content part.\n   */\n  type: 'text';\n}\n\n/**\n * Specifying a particular function via `{\"name\": \"my_function\"}` forces the model\n * to call that function.\n */\nexport interface ChatCompletionFunctionCallOption {\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n}\n\n/**\n * @deprecated\n */\nexport interface ChatCompletionFunctionMessageParam {\n  /**\n   * The contents of the function message.\n   */\n  content: string | null;\n\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n\n  /**\n   * The role of the messages author, in this case `function`.\n   */\n  role: 'function';\n}\n\n/**\n * A chat completion message generated by the model.\n */\nexport interface ChatCompletionMessage {\n  /**\n   * The contents of the message.\n   */\n  content: string | null;\n\n  /**\n   * The role of the author of this message.\n   */\n  role: 'assistant';\n\n  /**\n   * A list of tools that were executed during the chat completion for compound AI\n   * systems.\n   */\n  executed_tools?: Array<ChatCompletionMessage.ExecutedTool>;\n\n  /**\n   * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\n   * function that should be called, as generated by the model.\n   */\n  function_call?: ChatCompletionMessage.FunctionCall;\n\n  /**\n   * The model's reasoning for a response. Only available for reasoning models when\n   * requests parameter reasoning_format has value `parsed.\n   */\n  reasoning?: string | null;\n\n  /**\n   * The tool calls generated by the model, such as function calls.\n   */\n  tool_calls?: Array<ChatCompletionMessageToolCall>;\n}\n\nexport namespace ChatCompletionMessage {\n  export interface ExecutedTool {\n    /**\n     * The arguments passed to the tool in JSON format.\n     */\n    arguments: string;\n\n    /**\n     * The index of the executed tool.\n     */\n    index: number;\n\n    /**\n     * The type of tool that was executed.\n     */\n    type: string;\n\n    /**\n     * The output returned by the tool.\n     */\n    output?: string | null;\n  }\n\n  /**\n   * @deprecated Deprecated and replaced by `tool_calls`. The name and arguments of a\n   * function that should be called, as generated by the model.\n   */\n  export interface FunctionCall {\n    /**\n     * The arguments to call the function with, as generated by the model in JSON\n     * format. Note that the model does not always generate valid JSON, and may\n     * hallucinate parameters not defined by your function schema. Validate the\n     * arguments in your code before calling your function.\n     */\n    arguments: string;\n\n    /**\n     * The name of the function to call.\n     */\n    name: string;\n  }\n}\n\nexport type ChatCompletionMessageParam =\n  | ChatCompletionSystemMessageParam\n  | ChatCompletionUserMessageParam\n  | ChatCompletionAssistantMessageParam\n  | ChatCompletionToolMessageParam\n  | ChatCompletionFunctionMessageParam;\n\nexport interface ChatCompletionMessageToolCall {\n  /**\n   * The ID of the tool call.\n   */\n  id: string;\n\n  /**\n   * The function that the model called.\n   */\n  function: ChatCompletionMessageToolCall.Function;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: 'function';\n}\n\nexport namespace ChatCompletionMessageToolCall {\n  /**\n   * The function that the model called.\n   */\n  export interface Function {\n    /**\n     * The arguments to call the function with, as generated by the model in JSON\n     * format. Note that the model does not always generate valid JSON, and may\n     * hallucinate parameters not defined by your function schema. Validate the\n     * arguments in your code before calling your function.\n     */\n    arguments: string;\n\n    /**\n     * The name of the function to call.\n     */\n    name: string;\n  }\n}\n\n/**\n * Specifies a tool the model should use. Use to force the model to call a specific\n * function.\n */\nexport interface ChatCompletionNamedToolChoice {\n  function: ChatCompletionNamedToolChoice.Function;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: 'function';\n}\n\nexport namespace ChatCompletionNamedToolChoice {\n  export interface Function {\n    /**\n     * The name of the function to call.\n     */\n    name: string;\n  }\n}\n\n/**\n * The role of the author of a message\n */\nexport type ChatCompletionRole = 'system' | 'user' | 'assistant' | 'tool' | 'function';\n\nexport interface ChatCompletionSystemMessageParam {\n  /**\n   * The contents of the system message.\n   */\n  content: string;\n\n  /**\n   * The role of the messages author, in this case `system`.\n   */\n  role: 'system';\n\n  /**\n   * An optional name for the participant. Provides the model information to\n   * differentiate between participants of the same role.\n   */\n  name?: string;\n}\n\nexport interface ChatCompletionTokenLogprob {\n  /**\n   * The token.\n   */\n  token: string;\n\n  /**\n   * A list of integers representing the UTF-8 bytes representation of the token.\n   * Useful in instances where characters are represented by multiple tokens and\n   * their byte representations must be combined to generate the correct text\n   * representation. Can be `null` if there is no bytes representation for the token.\n   */\n  bytes: Array<number> | null;\n\n  /**\n   * The log probability of this token, if it is within the top 20 most likely\n   * tokens. Otherwise, the value `-9999.0` is used to signify that the token is very\n   * unlikely.\n   */\n  logprob: number;\n\n  /**\n   * List of the most likely tokens and their log probability, at this token\n   * position. In rare cases, there may be fewer than the number of requested\n   * `top_logprobs` returned.\n   */\n  top_logprobs: Array<ChatCompletionTokenLogprob.TopLogprob>;\n}\n\nexport namespace ChatCompletionTokenLogprob {\n  export interface TopLogprob {\n    /**\n     * The token.\n     */\n    token: string;\n\n    /**\n     * A list of integers representing the UTF-8 bytes representation of the token.\n     * Useful in instances where characters are represented by multiple tokens and\n     * their byte representations must be combined to generate the correct text\n     * representation. Can be `null` if there is no bytes representation for the token.\n     */\n    bytes: Array<number> | null;\n\n    /**\n     * The log probability of this token, if it is within the top 20 most likely\n     * tokens. Otherwise, the value `-9999.0` is used to signify that the token is very\n     * unlikely.\n     */\n    logprob: number;\n  }\n}\n\nexport interface ChatCompletionTool {\n  function: Shared.FunctionDefinition;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: 'function';\n}\n\n/**\n * Controls which (if any) tool is called by the model. `none` means the model will\n * not call any tool and instead generates a message. `auto` means the model can\n * pick between generating a message or calling one or more tools. `required` means\n * the model must call one or more tools. Specifying a particular tool via\n * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n * call that tool.\n *\n * `none` is the default when no tools are present. `auto` is the default if tools\n * are present.\n */\nexport type ChatCompletionToolChoiceOption = 'none' | 'auto' | 'required' | ChatCompletionNamedToolChoice;\n\nexport interface ChatCompletionToolMessageParam {\n  /**\n   * The contents of the tool message.\n   */\n  content: string;\n\n  /**\n   * The role of the messages author, in this case `tool`.\n   */\n  role: 'tool';\n\n  /**\n   * Tool call that this message is responding to.\n   */\n  tool_call_id: string;\n}\n\nexport interface ChatCompletionUserMessageParam {\n  /**\n   * The contents of the user message.\n   */\n  content: string | Array<ChatCompletionContentPart>;\n\n  /**\n   * The role of the messages author, in this case `user`.\n   */\n  role: 'user';\n\n  /**\n   * An optional name for the participant. Provides the model information to\n   * differentiate between participants of the same role.\n   */\n  name?: string;\n}\n\nexport type ChatCompletionCreateParams =\n  | ChatCompletionCreateParamsNonStreaming\n  | ChatCompletionCreateParamsStreaming;\n\nexport interface ChatCompletionCreateParamsBase {\n  /**\n   * A list of messages comprising the conversation so far.\n   */\n  messages: Array<ChatCompletionMessageParam>;\n\n  /**\n   * ID of the model to use. For details on which models are compatible with the Chat\n   * API, see available [models](/docs/models)\n   */\n  model: (string & {}) | 'gemma-7b-it' | 'llama3-70b-8192' | 'llama3-8b-8192' | 'mixtral-8x7b-32768';\n\n  /**\n   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their\n   * existing frequency in the text so far, decreasing the model's likelihood to\n   * repeat the same line verbatim.\n   */\n  frequency_penalty?: number | null;\n\n  /**\n   * Deprecated in favor of `tool_choice`.\n   *\n   * Controls which (if any) function is called by the model. `none` means the model\n   * will not call a function and instead generates a message. `auto` means the model\n   * can pick between generating a message or calling a function. Specifying a\n   * particular function via `{\"name\": \"my_function\"}` forces the model to call that\n   * function.\n   *\n   * `none` is the default when no functions are present. `auto` is the default if\n   * functions are present.\n   */\n  function_call?: 'none' | 'auto' | 'required' | ChatCompletionFunctionCallOption | null;\n\n  /**\n   * Deprecated in favor of `tools`.\n   *\n   * A list of functions the model may generate JSON inputs for.\n   */\n  functions?: Array<CompletionCreateParams.Function> | null;\n\n  /**\n   * This is not yet supported by any of our models. Modify the likelihood of\n   * specified tokens appearing in the completion.\n   */\n  logit_bias?: Record<string, number> | null;\n\n  /**\n   * This is not yet supported by any of our models. Whether to return log\n   * probabilities of the output tokens or not. If true, returns the log\n   * probabilities of each output token returned in the `content` of `message`.\n   */\n  logprobs?: boolean | null;\n\n  /**\n   * The maximum number of tokens that can be generated in the chat completion. The\n   * total length of input tokens and generated tokens is limited by the model's\n   * context length.\n   */\n  max_completion_tokens?: number | null;\n\n  /**\n   * Deprecated in favor of `max_completion_tokens`. The maximum number of tokens\n   * that can be generated in the chat completion. The total length of input tokens\n   * and generated tokens is limited by the model's context length.\n   */\n  max_tokens?: number | null;\n\n  /**\n   * How many chat completion choices to generate for each input message. Note that\n   * the current moment, only n=1 is supported. Other values will result in a 400\n   * response.\n   */\n  n?: number | null;\n\n  /**\n   * Whether to enable parallel function calling during tool use.\n   */\n  parallel_tool_calls?: boolean | null;\n\n  /**\n   * Number between -2.0 and 2.0. Positive values penalize new tokens based on\n   * whether they appear in the text so far, increasing the model's likelihood to\n   * talk about new topics.\n   */\n  presence_penalty?: number | null;\n\n  /**\n   * Specifies how to output reasoning tokens\n   */\n  reasoning_format?: 'hidden' | 'raw' | 'parsed' | null;\n\n  /**\n   * An object specifying the format that the model must output.\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message.\n   */\n  response_format?: CompletionCreateParams.ResponseFormat | null;\n\n  /**\n   * If specified, our system will make a best effort to sample deterministically,\n   * such that repeated requests with the same `seed` and parameters should return\n   * the same result. Determinism is not guaranteed, and you should refer to the\n   * `system_fingerprint` response parameter to monitor changes in the backend.\n   */\n  seed?: number | null;\n\n  /**\n   * The service tier to use for the request. Defaults to `on_demand`.\n   *\n   * - `auto` will automatically select the highest tier available within the rate\n   *   limits of your organization.\n   * - `flex` uses the flex tier, which will succeed or fail quickly.\n   */\n  service_tier?: 'auto' | 'on_demand' | 'flex' | null;\n\n  /**\n   * Up to 4 sequences where the API will stop generating further tokens. The\n   * returned text will not contain the stop sequence.\n   */\n  stop?: string | null | Array<string>;\n\n  /**\n   * If set, partial message deltas will be sent. Tokens will be sent as data-only\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\n   * as they become available, with the stream terminated by a `data: [DONE]`\n   * message. [Example code](/docs/text-chat#streaming-a-chat-completion).\n   */\n  stream?: boolean | null;\n\n  /**\n   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will\n   * make the output more random, while lower values like 0.2 will make it more\n   * focused and deterministic. We generally recommend altering this or top_p but not\n   * both\n   */\n  temperature?: number | null;\n\n  /**\n   * Controls which (if any) tool is called by the model. `none` means the model will\n   * not call any tool and instead generates a message. `auto` means the model can\n   * pick between generating a message or calling one or more tools. `required` means\n   * the model must call one or more tools. Specifying a particular tool via\n   * `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to\n   * call that tool.\n   *\n   * `none` is the default when no tools are present. `auto` is the default if tools\n   * are present.\n   */\n  tool_choice?: ChatCompletionToolChoiceOption | null;\n\n  /**\n   * A list of tools the model may call. Currently, only functions are supported as a\n   * tool. Use this to provide a list of functions the model may generate JSON inputs\n   * for. A max of 128 functions are supported.\n   */\n  tools?: Array<ChatCompletionTool> | null;\n\n  /**\n   * This is not yet supported by any of our models. An integer between 0 and 20\n   * specifying the number of most likely tokens to return at each token position,\n   * each with an associated log probability. `logprobs` must be set to `true` if\n   * this parameter is used.\n   */\n  top_logprobs?: number | null;\n\n  /**\n   * An alternative to sampling with temperature, called nucleus sampling, where the\n   * model considers the results of the tokens with top_p probability mass. So 0.1\n   * means only the tokens comprising the top 10% probability mass are considered. We\n   * generally recommend altering this or temperature but not both.\n   */\n  top_p?: number | null;\n\n  /**\n   * A unique identifier representing your end-user, which can help us monitor and\n   * detect abuse.\n   */\n  user?: string | null;\n}\n\nexport namespace CompletionCreateParams {\n  /**\n   * @deprecated\n   */\n  export interface Function {\n    /**\n     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain\n     * underscores and dashes, with a maximum length of 64.\n     */\n    name: string;\n\n    /**\n     * A description of what the function does, used by the model to choose when and\n     * how to call the function.\n     */\n    description?: string;\n\n    /**\n     * The parameters the functions accepts, described as a JSON Schema object. See the\n     * docs on [tool use](/docs/tool-use) for examples, and the\n     * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\n     * documentation about the format.\n     *\n     * Omitting `parameters` defines a function with an empty parameter list.\n     */\n    parameters?: Shared.FunctionParameters;\n  }\n\n  /**\n   * An object specifying the format that the model must output.\n   *\n   * Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the\n   * message the model generates is valid JSON.\n   *\n   * **Important:** when using JSON mode, you **must** also instruct the model to\n   * produce JSON yourself via a system or user message.\n   */\n  export interface ResponseFormat {\n    /**\n     * Must be one of `text` or `json_object`.\n     */\n    type?: 'text' | 'json_object';\n  }\n}\n\nexport interface ChatCompletionCreateParamsNonStreaming extends ChatCompletionCreateParamsBase {\n  /**\n   * If set, partial message deltas will be sent. Tokens will be sent as data-only\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\n   * as they become available, with the stream terminated by a `data: [DONE]`\n   * message. [Example code](/docs/text-chat#streaming-a-chat-completion).\n   */\n  stream?: false | null;\n}\n\nexport interface ChatCompletionCreateParamsStreaming extends ChatCompletionCreateParamsBase {\n  /**\n   * If set, partial message deltas will be sent. Tokens will be sent as data-only\n   * [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format)\n   * as they become available, with the stream terminated by a `data: [DONE]`\n   * message. [Example code](/docs/text-chat#streaming-a-chat-completion).\n   */\n  stream: true;\n}\n\nexport declare namespace Completions {\n  export {\n    type ChatCompletion as ChatCompletion,\n    type ChatCompletionAssistantMessageParam as ChatCompletionAssistantMessageParam,\n    type ChatCompletionChunk as ChatCompletionChunk,\n    type ChatCompletionContentPart as ChatCompletionContentPart,\n    type ChatCompletionContentPartImage as ChatCompletionContentPartImage,\n    type ChatCompletionContentPartText as ChatCompletionContentPartText,\n    type ChatCompletionFunctionCallOption as ChatCompletionFunctionCallOption,\n    type ChatCompletionFunctionMessageParam as ChatCompletionFunctionMessageParam,\n    type ChatCompletionMessage as ChatCompletionMessage,\n    type ChatCompletionMessageParam as ChatCompletionMessageParam,\n    type ChatCompletionMessageToolCall as ChatCompletionMessageToolCall,\n    type ChatCompletionNamedToolChoice as ChatCompletionNamedToolChoice,\n    type ChatCompletionRole as ChatCompletionRole,\n    type ChatCompletionSystemMessageParam as ChatCompletionSystemMessageParam,\n    type ChatCompletionTokenLogprob as ChatCompletionTokenLogprob,\n    type ChatCompletionTool as ChatCompletionTool,\n    type ChatCompletionToolChoiceOption as ChatCompletionToolChoiceOption,\n    type ChatCompletionToolMessageParam as ChatCompletionToolMessageParam,\n    type ChatCompletionUserMessageParam as ChatCompletionUserMessageParam,\n    type CompletionCreateParams as CompletionCreateParams,\n  };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../../resource';\nimport * as CompletionsAPI from './completions';\nimport {\n  ChatCompletion,\n  ChatCompletionAssistantMessageParam,\n  ChatCompletionChunk,\n  ChatCompletionContentPart,\n  ChatCompletionContentPartImage,\n  ChatCompletionContentPartText,\n  ChatCompletionFunctionCallOption,\n  ChatCompletionFunctionMessageParam,\n  ChatCompletionMessage,\n  ChatCompletionMessageParam,\n  ChatCompletionMessageToolCall,\n  ChatCompletionNamedToolChoice,\n  ChatCompletionRole,\n  ChatCompletionSystemMessageParam,\n  ChatCompletionTokenLogprob,\n  ChatCompletionTool,\n  ChatCompletionToolChoiceOption,\n  ChatCompletionToolMessageParam,\n  ChatCompletionUserMessageParam,\n  CompletionCreateParams,\n  Completions,\n} from './completions';\n\nexport class Chat extends APIResource {\n  completions: CompletionsAPI.Completions = new CompletionsAPI.Completions(this._client);\n}\n\nChat.Completions = Completions;\n\nexport declare namespace Chat {\n  export {\n    Completions as Completions,\n    type ChatCompletion as ChatCompletion,\n    type ChatCompletionAssistantMessageParam as ChatCompletionAssistantMessageParam,\n    type ChatCompletionChunk as ChatCompletionChunk,\n    type ChatCompletionContentPart as ChatCompletionContentPart,\n    type ChatCompletionContentPartImage as ChatCompletionContentPartImage,\n    type ChatCompletionContentPartText as ChatCompletionContentPartText,\n    type ChatCompletionFunctionCallOption as ChatCompletionFunctionCallOption,\n    type ChatCompletionFunctionMessageParam as ChatCompletionFunctionMessageParam,\n    type ChatCompletionMessage as ChatCompletionMessage,\n    type ChatCompletionMessageParam as ChatCompletionMessageParam,\n    type ChatCompletionMessageToolCall as ChatCompletionMessageToolCall,\n    type ChatCompletionNamedToolChoice as ChatCompletionNamedToolChoice,\n    type ChatCompletionRole as ChatCompletionRole,\n    type ChatCompletionSystemMessageParam as ChatCompletionSystemMessageParam,\n    type ChatCompletionTokenLogprob as ChatCompletionTokenLogprob,\n    type ChatCompletionTool as ChatCompletionTool,\n    type ChatCompletionToolChoiceOption as ChatCompletionToolChoiceOption,\n    type ChatCompletionToolMessageParam as ChatCompletionToolMessageParam,\n    type ChatCompletionUserMessageParam as ChatCompletionUserMessageParam,\n    type CompletionCreateParams as CompletionCreateParams,\n  };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\n\nexport class Completions extends APIResource {}\n\n/**\n * Usage statistics for the completion request.\n */\nexport interface CompletionUsage {\n  /**\n   * Number of tokens in the generated completion.\n   */\n  completion_tokens: number;\n\n  /**\n   * Number of tokens in the prompt.\n   */\n  prompt_tokens: number;\n\n  /**\n   * Total number of tokens used in the request (prompt + completion).\n   */\n  total_tokens: number;\n\n  /**\n   * Time spent generating tokens\n   */\n  completion_time?: number;\n\n  /**\n   * Time spent processing input tokens\n   */\n  prompt_time?: number;\n\n  /**\n   * Time the requests was spent queued\n   */\n  queue_time?: number;\n\n  /**\n   * completion time and prompt time combined\n   */\n  total_time?: number;\n}\n\nexport declare namespace Completions {\n  export { type CompletionUsage as CompletionUsage };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport * as Core from '../core';\n\nexport class Embeddings extends APIResource {\n  /**\n   * Creates an embedding vector representing the input text.\n   */\n  create(\n    body: EmbeddingCreateParams,\n    options?: Core.RequestOptions,\n  ): Core.APIPromise<CreateEmbeddingResponse> {\n    return this._client.post('/openai/v1/embeddings', { body, ...options });\n  }\n}\n\nexport interface CreateEmbeddingResponse {\n  /**\n   * The list of embeddings generated by the model.\n   */\n  data: Array<Embedding>;\n\n  /**\n   * The name of the model used to generate the embedding.\n   */\n  model: string;\n\n  /**\n   * The object type, which is always \"list\".\n   */\n  object: 'list';\n\n  /**\n   * The usage information for the request.\n   */\n  usage: CreateEmbeddingResponse.Usage;\n}\n\nexport namespace CreateEmbeddingResponse {\n  /**\n   * The usage information for the request.\n   */\n  export interface Usage {\n    /**\n     * The number of tokens used by the prompt.\n     */\n    prompt_tokens: number;\n\n    /**\n     * The total number of tokens used by the request.\n     */\n    total_tokens: number;\n  }\n}\n\n/**\n * Represents an embedding vector returned by embedding endpoint.\n */\nexport interface Embedding {\n  /**\n   * The embedding vector, which is a list of floats. The length of vector depends on\n   * the model as listed in the [embedding guide](/docs/guides/embeddings).\n   */\n  embedding: Array<number> | string;\n\n  /**\n   * The index of the embedding in the list of embeddings.\n   */\n  index: number;\n\n  /**\n   * The object type, which is always \"embedding\".\n   */\n  object: 'embedding';\n}\n\nexport interface EmbeddingCreateParams {\n  /**\n   * Input text to embed, encoded as a string or array of tokens. To embed multiple\n   * inputs in a single request, pass an array of strings or array of token arrays.\n   * The input must not exceed the max input tokens for the model, cannot be an empty\n   * string, and any array must be 2048 dimensions or less.\n   */\n  input: string | Array<string>;\n\n  /**\n   * ID of the model to use.\n   */\n  model: (string & {}) | 'nomic-embed-text-v1_5';\n\n  /**\n   * The format to return the embeddings in. Can only be `float` or `base64`.\n   */\n  encoding_format?: 'float' | 'base64';\n\n  /**\n   * A unique identifier representing your end-user, which can help us monitor and\n   * detect abuse.\n   */\n  user?: string | null;\n}\n\nexport declare namespace Embeddings {\n  export {\n    type CreateEmbeddingResponse as CreateEmbeddingResponse,\n    type Embedding as Embedding,\n    type EmbeddingCreateParams as EmbeddingCreateParams,\n  };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport * as Core from '../core';\n\nexport class Files extends APIResource {\n  /**\n   * Upload a file that can be used across various endpoints.\n   *\n   * The Batch API only supports `.jsonl` files up to 100 MB in size. The input also\n   * has a specific required [format](/docs/batch).\n   *\n   * Please contact us if you need to increase these storage limits.\n   */\n  create(body: FileCreateParams, options?: Core.RequestOptions): Core.APIPromise<FileCreateResponse> {\n    return this._client.post('/openai/v1/files', Core.multipartFormRequestOptions({ body, ...options }));\n  }\n\n  /**\n   * Returns a list of files.\n   */\n  list(options?: Core.RequestOptions): Core.APIPromise<FileListResponse> {\n    return this._client.get('/openai/v1/files', options);\n  }\n\n  /**\n   * Delete a file.\n   */\n  delete(fileId: string, options?: Core.RequestOptions): Core.APIPromise<FileDeleteResponse> {\n    return this._client.delete(`/openai/v1/files/${fileId}`, options);\n  }\n\n  /**\n   * Returns the contents of the specified file.\n   */\n  content(fileId: string, options?: Core.RequestOptions): Core.APIPromise<string> {\n    return this._client.get(`/openai/v1/files/${fileId}/content`, options);\n  }\n\n  /**\n   * Returns information about a file.\n   */\n  info(fileId: string, options?: Core.RequestOptions): Core.APIPromise<FileInfoResponse> {\n    return this._client.get(`/openai/v1/files/${fileId}`, options);\n  }\n}\n\n/**\n * The `File` object represents a document that has been uploaded.\n */\nexport interface FileCreateResponse {\n  /**\n   * The file identifier, which can be referenced in the API endpoints.\n   */\n  id?: string;\n\n  /**\n   * The size of the file, in bytes.\n   */\n  bytes?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the file was created.\n   */\n  created_at?: number;\n\n  /**\n   * The name of the file.\n   */\n  filename?: string;\n\n  /**\n   * The object type, which is always `file`.\n   */\n  object?: 'file';\n\n  /**\n   * The intended purpose of the file. Supported values are `batch`, and\n   * `batch_output`.\n   */\n  purpose?: 'batch' | 'batch_output';\n}\n\nexport interface FileListResponse {\n  data: Array<FileListResponse.Data>;\n\n  object: 'list';\n}\n\nexport namespace FileListResponse {\n  /**\n   * The `File` object represents a document that has been uploaded.\n   */\n  export interface Data {\n    /**\n     * The file identifier, which can be referenced in the API endpoints.\n     */\n    id?: string;\n\n    /**\n     * The size of the file, in bytes.\n     */\n    bytes?: number;\n\n    /**\n     * The Unix timestamp (in seconds) for when the file was created.\n     */\n    created_at?: number;\n\n    /**\n     * The name of the file.\n     */\n    filename?: string;\n\n    /**\n     * The object type, which is always `file`.\n     */\n    object?: 'file';\n\n    /**\n     * The intended purpose of the file. Supported values are `batch`, and\n     * `batch_output`.\n     */\n    purpose?: 'batch' | 'batch_output';\n  }\n}\n\nexport interface FileDeleteResponse {\n  id: string;\n\n  deleted: boolean;\n\n  object: 'file';\n}\n\nexport type FileContentResponse = string;\n\n/**\n * The `File` object represents a document that has been uploaded.\n */\nexport interface FileInfoResponse {\n  /**\n   * The file identifier, which can be referenced in the API endpoints.\n   */\n  id?: string;\n\n  /**\n   * The size of the file, in bytes.\n   */\n  bytes?: number;\n\n  /**\n   * The Unix timestamp (in seconds) for when the file was created.\n   */\n  created_at?: number;\n\n  /**\n   * The name of the file.\n   */\n  filename?: string;\n\n  /**\n   * The object type, which is always `file`.\n   */\n  object?: 'file';\n\n  /**\n   * The intended purpose of the file. Supported values are `batch`, and\n   * `batch_output`.\n   */\n  purpose?: 'batch' | 'batch_output';\n}\n\nexport interface FileCreateParams {\n  /**\n   * The File object (not file name) to be uploaded.\n   */\n  file: Core.Uploadable;\n\n  /**\n   * The intended purpose of the uploaded file. Use \"batch\" for\n   * [Batch API](/docs/api-reference#batches).\n   */\n  purpose: 'batch';\n}\n\nexport declare namespace Files {\n  export {\n    type FileCreateResponse as FileCreateResponse,\n    type FileListResponse as FileListResponse,\n    type FileDeleteResponse as FileDeleteResponse,\n    type FileContentResponse as FileContentResponse,\n    type FileInfoResponse as FileInfoResponse,\n    type FileCreateParams as FileCreateParams,\n  };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { APIResource } from '../resource';\nimport * as Core from '../core';\n\nexport class Models extends APIResource {\n  /**\n   * Get a specific model\n   */\n  retrieve(model: string, options?: Core.RequestOptions): Core.APIPromise<Model> {\n    return this._client.get(`/openai/v1/models/${model}`, options);\n  }\n\n  /**\n   * get all available models\n   */\n  list(options?: Core.RequestOptions): Core.APIPromise<ModelListResponse> {\n    return this._client.get('/openai/v1/models', options);\n  }\n\n  /**\n   * Delete a model\n   */\n  delete(model: string, options?: Core.RequestOptions): Core.APIPromise<ModelDeleted> {\n    return this._client.delete(`/openai/v1/models/${model}`, options);\n  }\n}\n\n/**\n * Describes an OpenAI model offering that can be used with the API.\n */\nexport interface Model {\n  /**\n   * The model identifier, which can be referenced in the API endpoints.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) when the model was created.\n   */\n  created: number;\n\n  /**\n   * The object type, which is always \"model\".\n   */\n  object: 'model';\n\n  /**\n   * The organization that owns the model.\n   */\n  owned_by: string;\n}\n\nexport interface ModelDeleted {\n  id: string;\n\n  deleted: boolean;\n\n  object: string;\n}\n\nexport interface ModelListResponse {\n  data: Array<Model>;\n\n  object: 'list';\n}\n\nexport declare namespace Models {\n  export {\n    type Model as Model,\n    type ModelDeleted as ModelDeleted,\n    type ModelListResponse as ModelListResponse,\n  };\n}\n", "// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { type Agent } from './_shims/index';\nimport * as Core from './core';\nimport * as Errors from './error';\nimport * as Uploads from './uploads';\nimport * as API from './resources/index';\nimport {\n  BatchCreateParams,\n  BatchCreateResponse,\n  BatchListResponse,\n  BatchRetrieveResponse,\n  Batches,\n} from './resources/batches';\nimport { CompletionUsage, Completions } from './resources/completions';\nimport {\n  CreateEmbeddingResponse,\n  Embedding,\n  EmbeddingCreateParams,\n  Embeddings,\n} from './resources/embeddings';\nimport {\n  FileContentResponse,\n  FileCreateParams,\n  FileCreateResponse,\n  FileDeleteResponse,\n  FileInfoResponse,\n  FileListResponse,\n  Files,\n} from './resources/files';\nimport { Model, ModelDeleted, ModelListResponse, Models } from './resources/models';\nimport { Audio } from './resources/audio/audio';\nimport { Chat } from './resources/chat/chat';\n\nexport interface ClientOptions {\n  /**\n   * Defaults to process.env['GROQ_API_KEY'].\n   */\n  apiKey?: string | undefined;\n\n  /**\n   * Override the default base URL for the API, e.g., \"https://api.example.com/v2/\"\n   *\n   * Defaults to process.env['GROQ_BASE_URL'].\n   */\n  baseURL?: string | null | undefined;\n\n  /**\n   * The maximum amount of time (in milliseconds) that the client should wait for a response\n   * from the server before timing out a single request.\n   *\n   * Note that request timeouts are retried by default, so in a worst-case scenario you may wait\n   * much longer than this timeout before the promise succeeds or fails.\n   */\n  timeout?: number | undefined;\n\n  /**\n   * An HTTP agent used to manage HTTP(S) connections.\n   *\n   * If not provided, an agent will be constructed by default in the Node.js environment,\n   * otherwise no agent is used.\n   */\n  httpAgent?: Agent | undefined;\n\n  /**\n   * Specify a custom `fetch` function implementation.\n   *\n   * If not provided, we use `node-fetch` on Node.js and otherwise expect that `fetch` is\n   * defined globally.\n   */\n  fetch?: Core.Fetch | undefined;\n\n  /**\n   * The maximum number of times that the client will retry a request in case of a\n   * temporary failure, like a network error or a 5XX error from the server.\n   *\n   * @default 2\n   */\n  maxRetries?: number | undefined;\n\n  /**\n   * Default headers to include with every request to the API.\n   *\n   * These can be removed in individual requests by explicitly setting the\n   * header to `undefined` or `null` in request options.\n   */\n  defaultHeaders?: Core.Headers | undefined;\n\n  /**\n   * Default query parameters to include with every request to the API.\n   *\n   * These can be removed in individual requests by explicitly setting the\n   * param to `undefined` in request options.\n   */\n  defaultQuery?: Core.DefaultQuery | undefined;\n\n  /**\n   * By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n   * Only set this option to `true` if you understand the risks and have appropriate mitigations in place.\n   */\n  dangerouslyAllowBrowser?: boolean | undefined;\n}\n\n/**\n * API Client for interfacing with the Groq API.\n */\nexport class Groq extends Core.APIClient {\n  apiKey: string;\n\n  private _options: ClientOptions;\n\n  /**\n   * API Client for interfacing with the Groq API.\n   *\n   * @param {string | undefined} [opts.apiKey=process.env['GROQ_API_KEY'] ?? undefined]\n   * @param {string} [opts.baseURL=process.env['GROQ_BASE_URL'] ?? https://api.groq.com] - Override the default base URL for the API.\n   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.\n   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.\n   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.\n   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n   */\n  constructor({\n    baseURL = Core.readEnv('GROQ_BASE_URL'),\n    apiKey = Core.readEnv('GROQ_API_KEY'),\n    ...opts\n  }: ClientOptions = {}) {\n    if (apiKey === undefined) {\n      throw new Errors.GroqError(\n        \"The GROQ_API_KEY environment variable is missing or empty; either provide it, or instantiate the Groq client with an apiKey option, like new Groq({ apiKey: 'My API Key' }).\",\n      );\n    }\n\n    const options: ClientOptions = {\n      apiKey,\n      ...opts,\n      baseURL: baseURL || `https://api.groq.com`,\n    };\n\n    if (!options.dangerouslyAllowBrowser && Core.isRunningInBrowser()) {\n      throw new Errors.GroqError(\n        \"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew Groq({ apiKey, dangerouslyAllowBrowser: true })\",\n      );\n    }\n\n    super({\n      baseURL: options.baseURL!,\n      timeout: options.timeout ?? 60000 /* 1 minute */,\n      httpAgent: options.httpAgent,\n      maxRetries: options.maxRetries,\n      fetch: options.fetch,\n    });\n\n    this._options = options;\n\n    this.apiKey = apiKey;\n  }\n\n  completions: API.Completions = new API.Completions(this);\n  chat: API.Chat = new API.Chat(this);\n  embeddings: API.Embeddings = new API.Embeddings(this);\n  audio: API.Audio = new API.Audio(this);\n  models: API.Models = new API.Models(this);\n  batches: API.Batches = new API.Batches(this);\n  files: API.Files = new API.Files(this);\n\n  protected override defaultQuery(): Core.DefaultQuery | undefined {\n    return this._options.defaultQuery;\n  }\n\n  protected override defaultHeaders(opts: Core.FinalRequestOptions): Core.Headers {\n    return {\n      ...super.defaultHeaders(opts),\n      ...this._options.defaultHeaders,\n    };\n  }\n\n  protected override authHeaders(opts: Core.FinalRequestOptions): Core.Headers {\n    return { Authorization: `Bearer ${this.apiKey}` };\n  }\n\n  static Groq = this;\n  static DEFAULT_TIMEOUT = 60000; // 1 minute\n\n  static GroqError = Errors.GroqError;\n  static APIError = Errors.APIError;\n  static APIConnectionError = Errors.APIConnectionError;\n  static APIConnectionTimeoutError = Errors.APIConnectionTimeoutError;\n  static APIUserAbortError = Errors.APIUserAbortError;\n  static NotFoundError = Errors.NotFoundError;\n  static ConflictError = Errors.ConflictError;\n  static RateLimitError = Errors.RateLimitError;\n  static BadRequestError = Errors.BadRequestError;\n  static AuthenticationError = Errors.AuthenticationError;\n  static InternalServerError = Errors.InternalServerError;\n  static PermissionDeniedError = Errors.PermissionDeniedError;\n  static UnprocessableEntityError = Errors.UnprocessableEntityError;\n\n  static toFile = Uploads.toFile;\n  static fileFromPath = Uploads.fileFromPath;\n}\n\nGroq.Completions = Completions;\nGroq.Chat = Chat;\nGroq.Embeddings = Embeddings;\nGroq.Audio = Audio;\nGroq.Models = Models;\nGroq.Batches = Batches;\nGroq.Files = Files;\nexport declare namespace Groq {\n  export type RequestOptions = Core.RequestOptions;\n\n  export { Completions as Completions, type CompletionUsage as CompletionUsage };\n\n  export { Chat as Chat };\n\n  export {\n    Embeddings as Embeddings,\n    type CreateEmbeddingResponse as CreateEmbeddingResponse,\n    type Embedding as Embedding,\n    type EmbeddingCreateParams as EmbeddingCreateParams,\n  };\n\n  export { Audio as Audio };\n\n  export {\n    Models as Models,\n    type Model as Model,\n    type ModelDeleted as ModelDeleted,\n    type ModelListResponse as ModelListResponse,\n  };\n\n  export {\n    Batches as Batches,\n    type BatchCreateResponse as BatchCreateResponse,\n    type BatchRetrieveResponse as BatchRetrieveResponse,\n    type BatchListResponse as BatchListResponse,\n    type BatchCreateParams as BatchCreateParams,\n  };\n\n  export {\n    Files as Files,\n    type FileCreateResponse as FileCreateResponse,\n    type FileListResponse as FileListResponse,\n    type FileDeleteResponse as FileDeleteResponse,\n    type FileContentResponse as FileContentResponse,\n    type FileInfoResponse as FileInfoResponse,\n    type FileCreateParams as FileCreateParams,\n  };\n\n  export type ErrorObject = API.ErrorObject;\n  export type FunctionDefinition = API.FunctionDefinition;\n  export type FunctionParameters = API.FunctionParameters;\n}\n\nexport { toFile, fileFromPath } from './uploads';\nexport {\n  GroqError,\n  APIError,\n  APIConnectionError,\n  APIConnectionTimeoutError,\n  APIUserAbortError,\n  NotFoundError,\n  ConflictError,\n  RateLimitError,\n  BadRequestError,\n  AuthenticationError,\n  InternalServerError,\n  PermissionDeniedError,\n  UnprocessableEntityError,\n} from './error';\n\nexport default Groq;\n", "import { Runnable, type RunnableBatchOptions } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\nexport type RouterInput = {\n  key: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any;\n};\n\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nexport class RouterRunnable<\n  RunInput extends RouterInput,\n  RunnableInput,\n  RunOutput,\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n\n  constructor(fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }) {\n    super(fields);\n    this.runnables = fields.runnables;\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.invoke(actualInput, ensureConfig(options));\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const keys = inputs.map((input) => input.key);\n    const actualInputs = inputs.map((input) => input.input);\n    const missingKey = keys.find((key) => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(`One or more keys do not have a corresponding runnable.`);\n    }\n    const runnables = keys.map((key) => this.runnables[key]);\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency =\n      optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const batchSize =\n      maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs\n        .slice(i, i + batchSize)\n        .map((actualInput, i) =>\n          runnables[i].invoke(actualInput, optionsList[i])\n        );\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.stream(actualInput, options);\n  }\n}\n", "import {\n  Runnable,\n  RunnableLike,\n  _coerceToDict,\n  _coerceToRunnable,\n} from \"./base.js\";\nimport {\n  RunnableConfig,\n  getCallbackManagerForConfig,\n  patchConfig,\n} from \"./config.js\";\nimport { CallbackManagerForChainRun } from \"../callbacks/manager.js\";\nimport { concat } from \"../utils/stream.js\";\n\n/**\n * Type for a branch in the RunnableBranch. It consists of a condition\n * runnable and a branch runnable. The condition runnable is used to\n * determine whether the branch should be executed, and the branch runnable\n * is executed if the condition is true.\n */\nexport type Branch<RunInput, RunOutput> = [\n  Runnable<RunInput, boolean>,\n  Runnable<RunInput, RunOutput>,\n];\n\nexport type BranchLike<RunInput, RunOutput> = [\n  RunnableLike<RunInput, boolean>,\n  RunnableLike<RunInput, RunOutput>,\n];\n\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch<RunInput = any, RunOutput = any> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  static lc_name() {\n    return \"RunnableBranch\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  default: Runnable<RunInput, RunOutput>;\n\n  branches: Branch<RunInput, RunOutput>[];\n\n  constructor(fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }) {\n    super(fields);\n    this.branches = fields.branches;\n    this.default = fields.default;\n  }\n\n  /**\n   * Convenience method for instantiating a RunnableBranch from\n   * RunnableLikes (objects, functions, or Runnables).\n   *\n   * Each item in the input except for the last one should be a\n   * tuple with two items. The first is a \"condition\" RunnableLike that\n   * returns \"true\" if the second RunnableLike in the tuple should run.\n   *\n   * The final item in the input should be a RunnableLike that acts as a\n   * default branch if no other branches match.\n   *\n   * @example\n   * ```ts\n   * import { RunnableBranch } from \"@langchain/core/runnables\";\n   *\n   * const branch = RunnableBranch.from([\n   *   [(x: number) => x > 0, (x: number) => x + 1],\n   *   [(x: number) => x < 0, (x: number) => x - 1],\n   *   (x: number) => x\n   * ]);\n   * ```\n   * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n   *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n   * @returns A new RunnableBranch.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from<RunInput = any, RunOutput = any>(\n    branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>,\n    ]\n  ) {\n    if (branches.length < 1) {\n      throw new Error(\"RunnableBranch requires at least one branch\");\n    }\n    const branchLikes = branches.slice(0, -1) as BranchLike<\n      RunInput,\n      RunOutput\n    >[];\n    const coercedBranches: Branch<RunInput, RunOutput>[] = branchLikes.map(\n      ([condition, runnable]) => [\n        _coerceToRunnable(condition),\n        _coerceToRunnable(runnable),\n      ]\n    );\n    const defaultBranch = _coerceToRunnable(\n      branches[branches.length - 1] as RunnableLike<RunInput, RunOutput>\n    );\n    return new this({\n      branches: coercedBranches,\n      default: defaultBranch,\n    });\n  }\n\n  async _invoke(\n    input: RunInput,\n    config?: Partial<RunnableConfig>,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutput> {\n    let result;\n    for (let i = 0; i < this.branches.length; i += 1) {\n      const [condition, branchRunnable] = this.branches[i];\n      const conditionValue = await condition.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(`condition:${i + 1}`),\n        })\n      );\n      if (conditionValue) {\n        result = await branchRunnable.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`branch:${i + 1}`),\n          })\n        );\n        break;\n      }\n    }\n    if (!result) {\n      result = await this.default.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(\"branch:default\"),\n        })\n      );\n    }\n    return result;\n  }\n\n  async invoke(\n    input: RunInput,\n    config: RunnableConfig = {}\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n\n  async *_streamIterator(input: RunInput, config?: Partial<RunnableConfig>) {\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config?.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    let finalOutput;\n    let finalOutputSupported = true;\n    let stream;\n    try {\n      for (let i = 0; i < this.branches.length; i += 1) {\n        const [condition, branchRunnable] = this.branches[i];\n        const conditionValue = await condition.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`condition:${i + 1}`),\n          })\n        );\n        if (conditionValue) {\n          stream = await branchRunnable.stream(\n            input,\n            patchConfig(config, {\n              callbacks: runManager?.getChild(`branch:${i + 1}`),\n            })\n          );\n          for await (const chunk of stream) {\n            yield chunk;\n            if (finalOutputSupported) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                try {\n                  finalOutput = concat(finalOutput, chunk);\n                } catch {\n                  finalOutput = undefined;\n                  finalOutputSupported = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (stream === undefined) {\n        stream = await this.default.stream(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(\"branch:default\"),\n          })\n        );\n        for await (const chunk of stream) {\n          yield chunk;\n          if (finalOutputSupported) {\n            if (finalOutput === undefined) {\n              finalOutput = chunk;\n            } else {\n              try {\n                finalOutput = concat(finalOutput, chunk as RunOutput);\n              } catch {\n                finalOutput = undefined;\n                finalOutputSupported = false;\n              }\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {});\n  }\n}\n", "import {\n  BaseChatMessageHistory,\n  BaseListChatMessageHistory,\n} from \"../chat_history.js\";\nimport {\n  AIMessage,\n  BaseMessage,\n  HumanMessage,\n  isBaseMessage,\n} from \"../messages/index.js\";\nimport { Run } from \"../tracers/base.js\";\nimport {\n  Runnable,\n  RunnableBinding,\n  type RunnableBindingArgs,\n  RunnableLambda,\n} from \"./base.js\";\nimport { RunnableConfig } from \"./config.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n\ntype GetSessionHistoryCallable = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: Array<any>\n) =>\n  | Promise<BaseChatMessageHistory | BaseListChatMessageHistory>\n  | BaseChatMessageHistory\n  | BaseListChatMessageHistory;\n\nexport interface RunnableWithMessageHistoryInputs<RunInput, RunOutput>\n  extends Omit<RunnableBindingArgs<RunInput, RunOutput>, \"bound\" | \"config\"> {\n  runnable: Runnable<RunInput, RunOutput>;\n  getMessageHistory: GetSessionHistoryCallable;\n  inputMessagesKey?: string;\n  outputMessagesKey?: string;\n  historyMessagesKey?: string;\n  config?: RunnableConfig;\n}\n\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // pnpm install @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"@langchain/classic/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory<\n  RunInput,\n  RunOutput,\n> extends RunnableBinding<RunInput, RunOutput> {\n  runnable: Runnable<RunInput, RunOutput>;\n\n  inputMessagesKey?: string;\n\n  outputMessagesKey?: string;\n\n  historyMessagesKey?: string;\n\n  getMessageHistory: GetSessionHistoryCallable;\n\n  constructor(fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>) {\n    let historyChain: Runnable = RunnableLambda.from((input, options) =>\n      this._enterHistory(input, options ?? {})\n    ).withConfig({ runName: \"loadHistory\" });\n\n    const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n    if (messagesKey) {\n      historyChain = RunnablePassthrough.assign({\n        [messagesKey]: historyChain,\n      }).withConfig({ runName: \"insertHistory\" });\n    }\n\n    const bound = historyChain\n      .pipe(\n        fields.runnable.withListeners({\n          onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        })\n      )\n      .withConfig({ runName: \"RunnableWithMessageHistory\" });\n\n    const config = fields.config ?? {};\n\n    super({\n      ...fields,\n      config,\n      bound,\n    });\n    this.runnable = fields.runnable;\n    this.getMessageHistory = fields.getMessageHistory;\n    this.inputMessagesKey = fields.inputMessagesKey;\n    this.outputMessagesKey = fields.outputMessagesKey;\n    this.historyMessagesKey = fields.historyMessagesKey;\n  }\n\n  _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedInputValue;\n    if (\n      typeof inputValue === \"object\" &&\n      !Array.isArray(inputValue) &&\n      !isBaseMessage(inputValue)\n    ) {\n      let key;\n      if (this.inputMessagesKey) {\n        key = this.inputMessagesKey;\n      } else if (Object.keys(inputValue).length === 1) {\n        key = Object.keys(inputValue)[0];\n      } else {\n        key = \"input\";\n      }\n      if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n        parsedInputValue = inputValue[key][0];\n      } else {\n        parsedInputValue = inputValue[key];\n      }\n    } else {\n      parsedInputValue = inputValue;\n    }\n    if (typeof parsedInputValue === \"string\") {\n      return [new HumanMessage(parsedInputValue)];\n    } else if (Array.isArray(parsedInputValue)) {\n      return parsedInputValue;\n    } else if (isBaseMessage(parsedInputValue)) {\n      return [parsedInputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(\n          parsedInputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedOutputValue;\n    if (\n      !Array.isArray(outputValue) &&\n      !isBaseMessage(outputValue) &&\n      typeof outputValue !== \"string\"\n    ) {\n      let key;\n      if (this.outputMessagesKey !== undefined) {\n        key = this.outputMessagesKey;\n      } else if (Object.keys(outputValue).length === 1) {\n        key = Object.keys(outputValue)[0];\n      } else {\n        key = \"output\";\n      }\n      // If you are wrapping a chat model directly\n      // The output is actually this weird generations object\n      if (outputValue.generations !== undefined) {\n        parsedOutputValue = outputValue.generations[0][0].message;\n      } else {\n        parsedOutputValue = outputValue[key];\n      }\n    } else {\n      parsedOutputValue = outputValue;\n    }\n\n    if (typeof parsedOutputValue === \"string\") {\n      return [new AIMessage(parsedOutputValue)];\n    } else if (Array.isArray(parsedOutputValue)) {\n      return parsedOutputValue;\n    } else if (isBaseMessage(parsedOutputValue)) {\n      return [parsedOutputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(\n          parsedOutputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: any,\n    kwargs?: RunnableConfig\n  ): Promise<BaseMessage[]> {\n    const history = kwargs?.configurable?.messageHistory;\n    const messages = await history.getMessages();\n    if (this.historyMessagesKey === undefined) {\n      return messages.concat(this._getInputMessages(input));\n    }\n    return messages;\n  }\n\n  async _exitHistory(run: Run, config: RunnableConfig): Promise<void> {\n    const history = config.configurable?.messageHistory;\n\n    // Get input messages\n    let inputs;\n    // Chat model inputs are nested arrays\n    if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n      inputs = run.inputs[0];\n    } else {\n      inputs = run.inputs;\n    }\n    let inputMessages = this._getInputMessages(inputs);\n    // If historic messages were prepended to the input messages, remove them to\n    // avoid adding duplicate messages to history.\n    if (this.historyMessagesKey === undefined) {\n      const existingMessages = await history.getMessages();\n      inputMessages = inputMessages.slice(existingMessages.length);\n    }\n    // Get output messages\n    const outputValue = run.outputs;\n    if (!outputValue) {\n      throw new Error(\n        `Output values from 'Run' undefined. Run: ${JSON.stringify(\n          run,\n          null,\n          2\n        )}`\n      );\n    }\n    const outputMessages = this._getOutputMessages(outputValue);\n    await history.addMessages([...inputMessages, ...outputMessages]);\n  }\n\n  async _mergeConfig(...configs: Array<RunnableConfig | undefined>) {\n    const config = await super._mergeConfig(...configs);\n    // Extract sessionId\n    if (!config.configurable || !config.configurable.sessionId) {\n      const exampleInput = {\n        [this.inputMessagesKey ?? \"input\"]: \"foo\",\n      };\n      const exampleConfig = { configurable: { sessionId: \"123\" } };\n      throw new Error(\n        `sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n          `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(\n            exampleConfig\n          )})`\n      );\n    }\n    // attach messageHistory\n    const { sessionId } = config.configurable;\n    config.configurable.messageHistory =\n      await this.getMessageHistory(sessionId);\n    return config;\n  }\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys } from \"./config.js\";\nimport { raceWithSignal } from \"../utils/signal.js\";\nimport { Runnable, RunnableAssign, RunnableBinding, RunnableEach, RunnableLambda, RunnableMap, RunnableParallel, RunnablePick, RunnableRetry, RunnableSequence, RunnableToolLike, RunnableWithFallbacks, _coerceToRunnable } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\nimport { RouterRunnable } from \"./router.js\";\nimport { RunnableBranch } from \"./branch.js\";\nimport { RunnableWithMessageHistory } from \"./history.js\";\n\n//#region src/runnables/index.ts\nvar runnables_exports = {};\n__export(runnables_exports, {\n\tRouterRunnable: () => RouterRunnable,\n\tRunnable: () => Runnable,\n\tRunnableAssign: () => RunnableAssign,\n\tRunnableBinding: () => RunnableBinding,\n\tRunnableBranch: () => RunnableBranch,\n\tRunnableEach: () => RunnableEach,\n\tRunnableLambda: () => RunnableLambda,\n\tRunnableMap: () => RunnableMap,\n\tRunnableParallel: () => RunnableParallel,\n\tRunnablePassthrough: () => RunnablePassthrough,\n\tRunnablePick: () => RunnablePick,\n\tRunnableRetry: () => RunnableRetry,\n\tRunnableSequence: () => RunnableSequence,\n\tRunnableToolLike: () => RunnableToolLike,\n\tRunnableWithFallbacks: () => RunnableWithFallbacks,\n\tRunnableWithMessageHistory: () => RunnableWithMessageHistory,\n\t_coerceToRunnable: () => _coerceToRunnable,\n\tensureConfig: () => ensureConfig,\n\tgetCallbackManagerForConfig: () => getCallbackManagerForConfig,\n\tmergeConfigs: () => mergeConfigs,\n\tpatchConfig: () => patchConfig,\n\tpickRunnableConfigKeys: () => pickRunnableConfigKeys,\n\traceWithSignal: () => raceWithSignal\n});\n\n//#endregion\nexport { RouterRunnable, Runnable, RunnableAssign, RunnableBinding, RunnableBranch, RunnableEach, RunnableLambda, RunnableMap, RunnableParallel, RunnablePassthrough, RunnablePick, RunnableRetry, RunnableSequence, RunnableToolLike, RunnableWithFallbacks, RunnableWithMessageHistory, _coerceToRunnable, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys, raceWithSignal, runnables_exports };\n//# sourceMappingURL=index.js.map", "import { Runnable } from \"../runnables/index.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport type { BaseMessage, ContentBlock } from \"../messages/index.js\";\nimport type { Callbacks } from \"../callbacks/manager.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n\n/**\n * Options for formatting instructions.\n */\nexport interface FormatInstructionsOptions {}\n\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport abstract class BaseLLMOutputParser<T = unknown> extends Runnable<\n  string | BaseMessage,\n  T\n> {\n  /**\n   * Parses the result of an LLM call. This method is meant to be\n   * implemented by subclasses to define how the output from the LLM should\n   * be parsed.\n   * @param generations The generations from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  abstract parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T>;\n\n  /**\n   * Parses the result of an LLM call with a given prompt. By default, it\n   * simply calls `parseResult`.\n   * @param generations The generations from an LLM call.\n   * @param _prompt The prompt used in the LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parseResultWithPrompt(\n    generations: Generation[] | ChatGeneration[],\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parseResult(generations, callbacks);\n  }\n\n  protected _baseMessageToString(message: BaseMessage): string {\n    return typeof message.content === \"string\"\n      ? message.content\n      : this._baseMessageContentToString(message.content);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return JSON.stringify(content);\n  }\n\n  /**\n   * Calls the parser with a given input and optional configuration options.\n   * If the input is a string, it creates a generation with the input as\n   * text and calls `parseResult`. If the input is a `BaseMessage`, it\n   * creates a generation with the input as a message and the content of the\n   * input as text, and then calls `parseResult`.\n   * @param input The input to the parser, which can be a string or a `BaseMessage`.\n   * @param options Optional configuration options.\n   * @returns A promise of the parsed output.\n   */\n  async invoke(\n    input: string | BaseMessage,\n    options?: RunnableConfig\n  ): Promise<T> {\n    if (typeof input === \"string\") {\n      return this._callWithConfig(\n        async (input: string, options): Promise<T> =>\n          this.parseResult([{ text: input }], options?.callbacks),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    } else {\n      return this._callWithConfig(\n        async (input: BaseMessage, options): Promise<T> =>\n          this.parseResult(\n            [\n              {\n                message: input,\n                text: this._baseMessageToString(input),\n              },\n            ],\n            options?.callbacks\n          ),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call.\n */\nexport abstract class BaseOutputParser<\n  T = unknown,\n> extends BaseLLMOutputParser<T> {\n  parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(generations[0].text, callbacks);\n  }\n\n  /**\n   * Parse the output of an LLM call.\n   *\n   * @param text - LLM output to parse.\n   * @returns Parsed output.\n   */\n  abstract parse(text: string, callbacks?: Callbacks): Promise<T>;\n\n  async parseWithPrompt(\n    text: string,\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(text, callbacks);\n  }\n\n  /**\n   * Return a string describing the format of the output.\n   * @returns Format instructions.\n   * @param options - Options for formatting instructions.\n   * @example\n   * ```json\n   * {\n   *  \"foo\": \"bar\"\n   * }\n   * ```\n   */\n  abstract getFormatInstructions(options?: FormatInstructionsOptions): string;\n\n  /**\n   * Return the string type key uniquely identifying this class of parser\n   */\n  _type(): string {\n    throw new Error(\"_type not implemented\");\n  }\n}\n\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nexport class OutputParserException extends Error {\n  llmOutput?: string;\n\n  observation?: string;\n\n  sendToLLM: boolean;\n\n  constructor(\n    message: string,\n    llmOutput?: string,\n    observation?: string,\n    sendToLLM = false\n  ) {\n    super(message);\n    this.llmOutput = llmOutput;\n    this.observation = observation;\n    this.sendToLLM = sendToLLM;\n\n    if (sendToLLM) {\n      if (observation === undefined || llmOutput === undefined) {\n        throw new Error(\n          \"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\"\n        );\n      }\n    }\n\n    addLangChainErrorFields(this, \"OUTPUT_PARSING_FAILURE\");\n  }\n}\n", "import { deepCompareStrict } from \"@cfworker/json-schema\";\nimport { BaseOutputParser } from \"./base.js\";\nimport {\n  type BaseMessage,\n  isBaseMessage,\n  isBaseMessageChunk,\n} from \"../messages/base.js\";\nimport { convertToChunk } from \"../messages/utils.js\";\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  type Generation,\n  type ChatGeneration,\n  GenerationChunk,\n  ChatGenerationChunk,\n} from \"../outputs.js\";\n\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport abstract class BaseTransformOutputParser<\n  T = unknown,\n> extends BaseOutputParser<T> {\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{ text: chunk }]);\n      } else {\n        yield this.parseResult([\n          {\n            message: chunk,\n            text: this._baseMessageToString(chunk),\n          },\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>,\n    options: BaseCallbackConfig\n  ): AsyncGenerator<T> {\n    yield* this._transformStreamWithConfig(\n      inputGenerator,\n      this._transform.bind(this),\n      {\n        ...options,\n        runType: \"parser\",\n      }\n    );\n  }\n}\n\nexport type BaseCumulativeTransformOutputParserInput = { diff?: boolean };\n\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport abstract class BaseCumulativeTransformOutputParser<\n  T = unknown,\n> extends BaseTransformOutputParser<T> {\n  protected diff = false;\n\n  constructor(fields?: BaseCumulativeTransformOutputParserInput) {\n    super(fields);\n    this.diff = fields?.diff ?? this.diff;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected abstract _diff(prev: any | undefined, next: any): any;\n\n  abstract parsePartialResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<T | undefined>;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    let prevParsed: T | undefined;\n    let accGen: GenerationChunk | undefined;\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n        throw new Error(\"Cannot handle non-string output.\");\n      }\n      let chunkGen: GenerationChunk;\n      if (isBaseMessageChunk(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk,\n          text: chunk.content,\n        });\n      } else if (isBaseMessage(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: convertToChunk(chunk),\n          text: chunk.content,\n        });\n      } else {\n        chunkGen = new GenerationChunk({ text: chunk });\n      }\n\n      if (accGen === undefined) {\n        accGen = chunkGen;\n      } else {\n        accGen = accGen.concat(chunkGen);\n      }\n\n      const parsed = await this.parsePartialResult([accGen]);\n      if (\n        parsed !== undefined &&\n        parsed !== null &&\n        !deepCompareStrict(parsed, prevParsed)\n      ) {\n        if (this.diff) {\n          yield this._diff(prevParsed, parsed);\n        } else {\n          yield parsed;\n        }\n        prevParsed = parsed;\n      }\n    }\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n", "import { BaseTransformOutputParser } from \"./transform.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string and\n * encodes it into bytes.\n */\nexport class BytesOutputParser extends BaseTransformOutputParser<Uint8Array> {\n  static lc_name() {\n    return \"BytesOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"bytes\"];\n\n  lc_serializable = true;\n\n  protected textEncoder: InstanceType<typeof TextEncoder> = new TextEncoder();\n\n  parse(text: string): Promise<Uint8Array> {\n    return Promise.resolve(this.textEncoder.encode(text));\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n", "import { BaseMessage } from \"../messages/index.js\";\nimport { OutputParserException } from \"./base.js\";\nimport { BaseTransformOutputParser } from \"./transform.js\";\n\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nexport abstract class ListOutputParser extends BaseTransformOutputParser<\n  string[]\n> {\n  re?: RegExp;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<string[]> {\n    let buffer = \"\";\n    for await (const input of inputGenerator) {\n      if (typeof input === \"string\") {\n        // add current chunk to buffer\n        buffer += input;\n      } else {\n        // extract message content and add to buffer\n        buffer += input.content;\n      }\n      // get parts in buffer\n      if (!this.re) {\n        const parts = await this.parse(buffer);\n        if (parts.length > 1) {\n          // if there are multiple parts, yield all but the last one\n          for (const part of parts.slice(0, -1)) {\n            yield [part];\n          }\n          // keep the last part in the buffer\n          buffer = parts[parts.length - 1];\n        }\n      } else {\n        // if there is a regex, get all matches\n        const matches = [...buffer.matchAll(this.re)];\n        if (matches.length > 1) {\n          let doneIdx = 0;\n          // if there are multiple matches, yield all but the last one\n          for (const match of matches.slice(0, -1)) {\n            yield [match[1]];\n            doneIdx += (match.index ?? 0) + match[0].length;\n          }\n          // keep the last match in the buffer\n          buffer = buffer.slice(doneIdx);\n        }\n      }\n    }\n\n    // yield the last part\n    for (const part of await this.parse(buffer)) {\n      yield [part];\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nexport class CommaSeparatedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"CommaSeparatedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses the given text into an array of strings, using a comma as the\n   * separator. If the parsing fails, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each comma.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      return text\n        .trim()\n        .split(\",\")\n        .map((s) => s.trim());\n    } catch {\n      throw new OutputParserException(`Could not parse output: ${text}`, text);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CommaSeparatedListOutputParser.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n  }\n}\n\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nexport class CustomListOutputParser extends ListOutputParser {\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  private length: number | undefined;\n\n  private separator: string;\n\n  constructor({ length, separator }: { length?: number; separator?: string }) {\n    super(...arguments);\n    this.length = length;\n    this.separator = separator || \",\";\n  }\n\n  /**\n   * Parses the given text into an array of strings, using the specified\n   * separator. If the parsing fails or the number of items in the list\n   * doesn't match the expected length, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      const items = text\n        .trim()\n        .split(this.separator)\n        .map((s) => s.trim());\n      if (this.length !== undefined && items.length !== this.length) {\n        throw new OutputParserException(\n          `Incorrect number of items. Expected ${this.length}, got ${items.length}.`\n        );\n      }\n      return items;\n    } catch (e) {\n      if (Object.getPrototypeOf(e) === OutputParserException.prototype) {\n        throw e;\n      }\n      throw new OutputParserException(`Could not parse output: ${text}`);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CustomListOutputParser, including the number of items and the\n   * separator.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of ${\n      this.length === undefined ? \"\" : `${this.length} `\n    }items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${\n      this.separator\n    } baz\\`)`;\n  }\n}\n\nexport class NumberedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /\\d+\\.\\s([^\\n]+)/g;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n\nexport class MarkdownListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /^\\s*[-*]\\s([^\\n]+)$/gm;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n", "import { BaseTransformOutputParser } from \"./transform.js\";\nimport { ContentBlock } from \"../messages/index.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nexport class StringOutputParser extends BaseTransformOutputParser<string> {\n  static lc_name() {\n    return \"StrOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"string\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses a string output from an LLM call. This method is meant to be\n   * implemented by subclasses to define how a string output from an LLM\n   * should be parsed.\n   * @param text The string output from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parse(text: string): Promise<string> {\n    return Promise.resolve(text);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n\n  protected _textContentToString(content: ContentBlock.Text): string {\n    return content.text;\n  }\n\n  protected _imageUrlContentToString(\n    _content: ContentBlock.Data.URLContentBlock\n  ): string {\n    throw new Error(\n      `Cannot coerce a multimodal \"image_url\" message part into a string.`\n    );\n  }\n\n  protected _messageContentToString(content: ContentBlock): string {\n    switch (content.type) {\n      case \"text\":\n      case \"text_delta\":\n        if (\"text\" in content) {\n          // Type guard for MessageContentText\n          return this._textContentToString(content as ContentBlock.Text);\n        }\n        break;\n      case \"image_url\":\n        if (\"image_url\" in content) {\n          // Type guard for MessageContentImageUrl\n          return this._imageUrlContentToString(\n            content as ContentBlock.Data.URLContentBlock\n          );\n        }\n        break;\n      default:\n        throw new Error(\n          `Cannot coerce \"${content.type}\" message part into a string.`\n        );\n    }\n    throw new Error(`Invalid content type: ${content.type}`);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return content.reduce(\n      (acc: string, item: ContentBlock) =>\n        acc + this._messageContentToString(item),\n      \"\"\n    );\n  }\n}\n", "import { z } from \"zod/v3\";\nimport {\n  BaseOutputParser,\n  FormatInstructionsOptions,\n  OutputParserException,\n} from \"./base.js\";\nimport {\n  type InteropZodType,\n  type InferInteropZodOutput,\n  interopParseAsync,\n} from \"../utils/types/zod.js\";\nimport {\n  toJsonSchema,\n  type JsonSchema7Type,\n  type JsonSchema7ArrayType,\n  type JsonSchema7ObjectType,\n  type JsonSchema7StringType,\n  type JsonSchema7NumberType,\n  type JsonSchema7NullableType,\n} from \"../utils/json_schema.js\";\n\nexport type JsonMarkdownStructuredOutputParserInput = {\n  interpolationDepth?: number;\n};\n\nexport interface JsonMarkdownFormatInstructionsOptions\n  extends FormatInstructionsOptions {\n  interpolationDepth?: number;\n}\n\nexport class StructuredOutputParser<\n  T extends InteropZodType,\n> extends BaseOutputParser<InferInteropZodOutput<T>> {\n  static lc_name() {\n    return \"StructuredOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"structured\"];\n\n  toJSON() {\n    return this.toJSONNotImplemented();\n  }\n\n  constructor(public schema: T) {\n    super(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a Zod schema.\n   * @param schema The Zod schema which the output should match\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a set of names and\n   * descriptions.\n   * @param schemas An object where each key is a name and each value is a description\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this(zodSchema);\n  }\n\n  /**\n   * Returns a markdown code snippet with a JSON object formatted according\n   * to the schema.\n   * @param options Optional. The options for formatting the instructions\n   * @returns A markdown code snippet with a JSON object formatted according to the schema.\n   */\n  getFormatInstructions(): string {\n    return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(toJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n  }\n\n  /**\n   * Parses the given text according to the schema.\n   * @param text The text to parse\n   * @returns The parsed output.\n   */\n  async parse(text: string): Promise<InferInteropZodOutput<T>> {\n    try {\n      const trimmedText = text.trim();\n\n      const json =\n        // first case: if back ticks appear at the start of the text\n        trimmedText.match(/^```(?:json)?\\s*([\\s\\S]*?)```/)?.[1] ||\n        // second case: if back ticks with `json` appear anywhere in the text\n        trimmedText.match(/```json\\s*([\\s\\S]*?)```/)?.[1] ||\n        // otherwise, return the trimmed text\n        trimmedText;\n\n      const escapedJson = json\n        .replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n          const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n          return `\"${escapedInsideQuotes}\"`;\n        })\n        .replace(/\\n/g, \"\");\n\n      return await interopParseAsync(this.schema, JSON.parse(escapedJson));\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n  }\n}\n\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser<\n  T extends InteropZodType,\n> extends StructuredOutputParser<T> {\n  static lc_name() {\n    return \"JsonMarkdownStructuredOutputParser\";\n  }\n\n  getFormatInstructions(\n    options?: JsonMarkdownFormatInstructionsOptions\n  ): string {\n    const interpolationDepth = options?.interpolationDepth ?? 1;\n    if (interpolationDepth < 1) {\n      throw new Error(\"f string interpolation depth must be at least 1\");\n    }\n\n    return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(\n      toJsonSchema(this.schema)\n    )\n      .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n      .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n  }\n\n  private _schemaToInstruction(\n    schemaInput: JsonSchema7Type,\n    indent = 2\n  ): string {\n    const schema = schemaInput as Extract<\n      JsonSchema7Type,\n      | JsonSchema7ObjectType\n      | JsonSchema7ArrayType\n      | JsonSchema7StringType\n      | JsonSchema7NumberType\n      | JsonSchema7NullableType\n    >;\n\n    if (\"type\" in schema) {\n      let nullable = false;\n      let type: string;\n      if (Array.isArray(schema.type)) {\n        const nullIdx = schema.type.findIndex((type) => type === \"null\");\n        if (nullIdx !== -1) {\n          nullable = true;\n          schema.type.splice(nullIdx, 1);\n        }\n        type = schema.type.join(\" | \") as string;\n      } else {\n        type = schema.type;\n      }\n\n      if (schema.type === \"object\" && schema.properties) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        const properties = Object.entries(schema.properties)\n          .map(([key, value]) => {\n            const isOptional = schema.required?.includes(key)\n              ? \"\"\n              : \" (optional)\";\n            return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(\n              value,\n              indent + 2\n            )}${isOptional}`;\n          })\n          .join(\"\\n\");\n        return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n      }\n      if (schema.type === \"array\" && schema.items) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(\n          schema.items,\n          indent + 2\n        )}\\n${\" \".repeat(indent - 2)}] ${description}`;\n      }\n      const isNullable = nullable ? \" (nullable)\" : \"\";\n      const description = schema.description ? ` // ${schema.description}` : \"\";\n      return `${type}${description}${isNullable}`;\n    }\n\n    if (\"anyOf\" in schema) {\n      return schema.anyOf\n        .map((s) => this._schemaToInstruction(s, indent))\n        .join(`\\n${\" \".repeat(indent - 2)}`);\n    }\n\n    throw new Error(\"unsupported schema type\");\n  }\n\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this<T>(schema);\n  }\n\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this<typeof zodSchema>(zodSchema);\n  }\n}\n\nexport interface AsymmetricStructuredOutputParserFields<\n  T extends InteropZodType,\n> {\n  inputSchema: T;\n}\n\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport abstract class AsymmetricStructuredOutputParser<\n  T extends InteropZodType,\n  Y = unknown,\n> extends BaseOutputParser<Y> {\n  private structuredInputParser: JsonMarkdownStructuredOutputParser<T>;\n\n  constructor({ inputSchema }: AsymmetricStructuredOutputParserFields<T>) {\n    super(...arguments);\n    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(\n      inputSchema\n    );\n  }\n\n  /**\n   * Processes the parsed input into the desired output format. Must be\n   * implemented by subclasses.\n   * @param input The parsed input\n   * @returns The processed output.\n   */\n  abstract outputProcessor(input: InferInteropZodOutput<T>): Promise<Y>;\n\n  async parse(text: string): Promise<Y> {\n    let parsedInput;\n    try {\n      parsedInput = await this.structuredInputParser.parse(text);\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n\n    return this.outputProcessor(parsedInput);\n  }\n\n  getFormatInstructions(): string {\n    return this.structuredInputParser.getFormatInstructions();\n  }\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { applyPatch } from \"./fast-json-patch/src/core.js\";\nimport { compare } from \"./fast-json-patch/src/duplex.js\";\nimport \"./fast-json-patch/index.js\";\n\n//#region src/utils/json_patch.ts\nvar json_patch_exports = {};\n__export(json_patch_exports, {\n\tapplyPatch: () => applyPatch,\n\tcompare: () => compare\n});\n\n//#endregion\nexport { applyPatch, compare, json_patch_exports };\n//# sourceMappingURL=json_patch.js.map", "import { BaseCumulativeTransformOutputParser } from \"./transform.js\";\nimport { Operation, compare } from \"../utils/json_patch.js\";\nimport { ChatGeneration, Generation } from \"../outputs.js\";\nimport { parseJsonMarkdown, parsePartialJson } from \"../utils/json.js\";\nimport type { BaseMessage } from \"../messages/index.js\";\n\n/**\n * Class for parsing the output of an LLM into a JSON object.\n */\nexport class JsonOutputParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  /** @internal */\n  override _concatOutputChunks<T>(first: T, second: T): T {\n    if (this.diff) {\n      return super._concatOutputChunks(first, second);\n    }\n    return second;\n  }\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): Operation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{ op: \"replace\", path: \"\", value: next }];\n    }\n    return compare(prev, next);\n  }\n\n  // This should actually return Partial<T>, but there's no way\n  // to specify emitted chunks as instances separate from the main output type.\n  async parsePartialResult(\n    generations: ChatGeneration[] | Generation[]\n  ): Promise<T | undefined> {\n    return parseJsonMarkdown(generations[0].text) as T | undefined;\n  }\n\n  async parse(text: string): Promise<T> {\n    return parseJsonMarkdown(text, JSON.parse) as T;\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n\n  /**\n   * Extracts text content from a message for JSON parsing.\n   * Uses the message's `.text` accessor which properly handles both\n   * string content and ContentBlock[] arrays (extracting text from text blocks).\n   * @param message The message to extract text from\n   * @returns The text content of the message\n   */\n  protected _baseMessageToString(message: BaseMessage): string {\n    return message.text;\n  }\n}\n\nexport { parsePartialJson, parseJsonMarkdown };\n", "// @ts-nocheck\n\n// Inlined to deal with portability issues\n// Originally from: https://github.com/isaacs/sax-js\n\nconst initializeSax = function () {\n  const sax: any = {};\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream;\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n\n  const buffers = [\n    \"comment\",\n    \"sgmlDecl\",\n    \"textNode\",\n    \"tagName\",\n    \"doctype\",\n    \"procInstName\",\n    \"procInstBody\",\n    \"entity\",\n    \"attribName\",\n    \"attribValue\",\n    \"cdata\",\n    \"script\",\n  ];\n\n  sax.EVENTS = [\n    \"text\",\n    \"processinginstruction\",\n    \"sgmldeclaration\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"opencdata\",\n    \"cdata\",\n    \"closecdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n    \"script\",\n    \"opennamespace\",\n    \"closenamespace\",\n  ];\n\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt);\n    }\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.strictEntities = parser.opt.strictEntities;\n    parser.ENTITIES = parser.strictEntities\n      ? Object.create(sax.XML_ENTITIES)\n      : Object.create(sax.ENTITIES);\n    parser.attribList = [];\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS);\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false;\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0;\n    }\n    emit(parser, \"onready\");\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F() {}\n      F.prototype = o;\n      var newf = new F();\n      return newf;\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n    var maxActual = 0;\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case \"textNode\":\n            closeText(parser);\n            break;\n\n          case \"cdata\":\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n            break;\n\n          case \"script\":\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n            break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n    parser.bufferCheckPosition = m + parser.position;\n  }\n\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = \"\";\n    }\n  }\n\n  function flushBuffers(parser) {\n    closeText(parser);\n    if (parser.cdata !== \"\") {\n      emitNode(parser, \"oncdata\", parser.cdata);\n      parser.cdata = \"\";\n    }\n    if (parser.script !== \"\") {\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () {\n      end(this);\n    },\n    write: write,\n    resume: function () {\n      this.error = null;\n      return this;\n    },\n    close: function () {\n      return this.write(null);\n    },\n    flush: function () {\n      flushBuffers(this);\n    },\n  };\n\n  var Stream = ReadableStream;\n  if (!Stream) Stream = function () {};\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== \"error\" && ev !== \"end\";\n  });\n\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt);\n    }\n\n    Stream.apply(this);\n\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n\n    var me = this;\n\n    this._parser.onend = function () {\n      me.emit(\"end\");\n    };\n\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null;\n    };\n\n    this._decoder = null;\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev, {\n        get: function () {\n          return me._parser[\"on\" + ev];\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            me._parser[\"on\" + ev] = h;\n            return h;\n          }\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false,\n      });\n    });\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream,\n    },\n  });\n\n  SAXStream.prototype.write = function (data) {\n    this._parser.write(data.toString());\n    this.emit(\"data\", data);\n    return true;\n  };\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk);\n    }\n    this._parser.end();\n    return true;\n  };\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\" + ev] = function () {\n        var args =\n          arguments.length === 1\n            ? [arguments[0]]\n            : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = \"[CDATA[\";\n  var DOCTYPE = \"DOCTYPE\";\n  var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n  var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n\n  var nameBody =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n  var entityStart =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var entityBody =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n  function isWhitespace(c) {\n    return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n  }\n\n  function isQuote(c) {\n    return c === '\"' || c === \"'\";\n  }\n\n  function isAttribEnd(c) {\n    return c === \">\" || isWhitespace(c);\n  }\n\n  function isMatch(regex, c) {\n    return regex.test(c);\n  }\n\n  function notMatch(regex, c) {\n    return !isMatch(regex, c);\n  }\n\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++, // <script> ... <\n  };\n\n  sax.XML_ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\",\n  };\n\n  sax.ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\",\n    AElig: 198,\n    Aacute: 193,\n    Acirc: 194,\n    Agrave: 192,\n    Aring: 197,\n    Atilde: 195,\n    Auml: 196,\n    Ccedil: 199,\n    ETH: 208,\n    Eacute: 201,\n    Ecirc: 202,\n    Egrave: 200,\n    Euml: 203,\n    Iacute: 205,\n    Icirc: 206,\n    Igrave: 204,\n    Iuml: 207,\n    Ntilde: 209,\n    Oacute: 211,\n    Ocirc: 212,\n    Ograve: 210,\n    Oslash: 216,\n    Otilde: 213,\n    Ouml: 214,\n    THORN: 222,\n    Uacute: 218,\n    Ucirc: 219,\n    Ugrave: 217,\n    Uuml: 220,\n    Yacute: 221,\n    aacute: 225,\n    acirc: 226,\n    aelig: 230,\n    agrave: 224,\n    aring: 229,\n    atilde: 227,\n    auml: 228,\n    ccedil: 231,\n    eacute: 233,\n    ecirc: 234,\n    egrave: 232,\n    eth: 240,\n    euml: 235,\n    iacute: 237,\n    icirc: 238,\n    igrave: 236,\n    iuml: 239,\n    ntilde: 241,\n    oacute: 243,\n    ocirc: 244,\n    ograve: 242,\n    oslash: 248,\n    otilde: 245,\n    ouml: 246,\n    szlig: 223,\n    thorn: 254,\n    uacute: 250,\n    ucirc: 251,\n    ugrave: 249,\n    uuml: 252,\n    yacute: 253,\n    yuml: 255,\n    copy: 169,\n    reg: 174,\n    nbsp: 160,\n    iexcl: 161,\n    cent: 162,\n    pound: 163,\n    curren: 164,\n    yen: 165,\n    brvbar: 166,\n    sect: 167,\n    uml: 168,\n    ordf: 170,\n    laquo: 171,\n    not: 172,\n    shy: 173,\n    macr: 175,\n    deg: 176,\n    plusmn: 177,\n    sup1: 185,\n    sup2: 178,\n    sup3: 179,\n    acute: 180,\n    micro: 181,\n    para: 182,\n    middot: 183,\n    cedil: 184,\n    ordm: 186,\n    raquo: 187,\n    frac14: 188,\n    frac12: 189,\n    frac34: 190,\n    iquest: 191,\n    times: 215,\n    divide: 247,\n    OElig: 338,\n    oelig: 339,\n    Scaron: 352,\n    scaron: 353,\n    Yuml: 376,\n    fnof: 402,\n    circ: 710,\n    tilde: 732,\n    Alpha: 913,\n    Beta: 914,\n    Gamma: 915,\n    Delta: 916,\n    Epsilon: 917,\n    Zeta: 918,\n    Eta: 919,\n    Theta: 920,\n    Iota: 921,\n    Kappa: 922,\n    Lambda: 923,\n    Mu: 924,\n    Nu: 925,\n    Xi: 926,\n    Omicron: 927,\n    Pi: 928,\n    Rho: 929,\n    Sigma: 931,\n    Tau: 932,\n    Upsilon: 933,\n    Phi: 934,\n    Chi: 935,\n    Psi: 936,\n    Omega: 937,\n    alpha: 945,\n    beta: 946,\n    gamma: 947,\n    delta: 948,\n    epsilon: 949,\n    zeta: 950,\n    eta: 951,\n    theta: 952,\n    iota: 953,\n    kappa: 954,\n    lambda: 955,\n    mu: 956,\n    nu: 957,\n    xi: 958,\n    omicron: 959,\n    pi: 960,\n    rho: 961,\n    sigmaf: 962,\n    sigma: 963,\n    tau: 964,\n    upsilon: 965,\n    phi: 966,\n    chi: 967,\n    psi: 968,\n    omega: 969,\n    thetasym: 977,\n    upsih: 978,\n    piv: 982,\n    ensp: 8194,\n    emsp: 8195,\n    thinsp: 8201,\n    zwnj: 8204,\n    zwj: 8205,\n    lrm: 8206,\n    rlm: 8207,\n    ndash: 8211,\n    mdash: 8212,\n    lsquo: 8216,\n    rsquo: 8217,\n    sbquo: 8218,\n    ldquo: 8220,\n    rdquo: 8221,\n    bdquo: 8222,\n    dagger: 8224,\n    Dagger: 8225,\n    bull: 8226,\n    hellip: 8230,\n    permil: 8240,\n    prime: 8242,\n    Prime: 8243,\n    lsaquo: 8249,\n    rsaquo: 8250,\n    oline: 8254,\n    frasl: 8260,\n    euro: 8364,\n    image: 8465,\n    weierp: 8472,\n    real: 8476,\n    trade: 8482,\n    alefsym: 8501,\n    larr: 8592,\n    uarr: 8593,\n    rarr: 8594,\n    darr: 8595,\n    harr: 8596,\n    crarr: 8629,\n    lArr: 8656,\n    uArr: 8657,\n    rArr: 8658,\n    dArr: 8659,\n    hArr: 8660,\n    forall: 8704,\n    part: 8706,\n    exist: 8707,\n    empty: 8709,\n    nabla: 8711,\n    isin: 8712,\n    notin: 8713,\n    ni: 8715,\n    prod: 8719,\n    sum: 8721,\n    minus: 8722,\n    lowast: 8727,\n    radic: 8730,\n    prop: 8733,\n    infin: 8734,\n    ang: 8736,\n    and: 8743,\n    or: 8744,\n    cap: 8745,\n    cup: 8746,\n    int: 8747,\n    there4: 8756,\n    sim: 8764,\n    cong: 8773,\n    asymp: 8776,\n    ne: 8800,\n    equiv: 8801,\n    le: 8804,\n    ge: 8805,\n    sub: 8834,\n    sup: 8835,\n    nsub: 8836,\n    sube: 8838,\n    supe: 8839,\n    oplus: 8853,\n    otimes: 8855,\n    perp: 8869,\n    sdot: 8901,\n    lceil: 8968,\n    rceil: 8969,\n    lfloor: 8970,\n    rfloor: 8971,\n    lang: 9001,\n    rang: 9002,\n    loz: 9674,\n    spades: 9824,\n    clubs: 9827,\n    hearts: 9829,\n    diams: 9830,\n  };\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key];\n    var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n    sax.ENTITIES[key] = s;\n  });\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s;\n  }\n\n  // shorthand\n  S = sax.STATE;\n\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n    parser.textNode = \"\";\n  }\n\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error(parser, er) {\n    closeText(parser);\n    if (parser.trackPosition) {\n      er +=\n        \"\\nLine: \" +\n        parser.line +\n        \"\\nColumn: \" +\n        parser.column +\n        \"\\nChar: \" +\n        parser.c;\n    }\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.sawRoot && !parser.closedRoot)\n      strictFail(parser, \"Unclosed root tag\");\n    if (\n      parser.state !== S.BEGIN &&\n      parser.state !== S.BEGIN_WHITESPACE &&\n      parser.state !== S.TEXT\n    ) {\n      error(parser, \"Unexpected end\");\n    }\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n\n  function strictFail(parser, message) {\n    if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n      throw new Error(\"bad call to strictFail\");\n    }\n    if (parser.strict) {\n      error(parser, message);\n    }\n  }\n\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser;\n    var tag = (parser.tag = { name: parser.tagName, attributes: {} });\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns;\n    }\n    parser.attribList.length = 0;\n    emitNode(parser, \"onopentagstart\", tag);\n  }\n\n  function qname(name, attribute) {\n    var i = name.indexOf(\":\");\n    var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n    var prefix = qualName[0];\n    var local = qualName[1];\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === \"xmlns\") {\n      prefix = \"xmlns\";\n      local = \"\";\n    }\n\n    return { prefix: prefix, local: local };\n  }\n\n  function attrib(parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]();\n    }\n\n    if (\n      parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)\n    ) {\n      parser.attribName = parser.attribValue = \"\";\n      return;\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true);\n      var prefix = qn.prefix;\n      var local = qn.local;\n\n      if (prefix === \"xmlns\") {\n        // namespace binding attribute. push the binding into scope\n        if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(\n            parser,\n            \"xml: prefix must be bound to \" +\n              XML_NAMESPACE +\n              \"\\n\" +\n              \"Actual: \" +\n              parser.attribValue\n          );\n        } else if (\n          local === \"xmlns\" &&\n          parser.attribValue !== XMLNS_NAMESPACE\n        ) {\n          strictFail(\n            parser,\n            \"xmlns: prefix must be bound to \" +\n              XMLNS_NAMESPACE +\n              \"\\n\" +\n              \"Actual: \" +\n              parser.attribValue\n          );\n        } else {\n          var tag = parser.tag;\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n          tag.ns[local] = parser.attribValue;\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, \"onattribute\", {\n        name: parser.attribName,\n        value: parser.attribValue,\n      });\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n  }\n\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag;\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || \"\";\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(\n          parser,\n          \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName)\n        );\n        tag.uri = qn.prefix;\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, \"onopennamespace\", {\n            prefix: p,\n            uri: tag.ns[p],\n          });\n        });\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0];\n        var value = nv[1];\n        var qualName = qname(name, true);\n        var prefix = qualName.prefix;\n        var local = qualName.local;\n        var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri,\n        };\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== \"xmlns\" && !uri) {\n          strictFail(\n            parser,\n            \"Unbound namespace prefix: \" + JSON.stringify(prefix)\n          );\n          a.uri = prefix;\n        }\n        parser.tag.attributes[name] = a;\n        emitNode(parser, \"onattribute\", a);\n      }\n      parser.attribList.length = 0;\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing;\n\n    // process the tag\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n      parser.tag = null;\n      parser.tagName = \"\";\n    }\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n  }\n\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, \"Weird empty close tag.\");\n      parser.textNode += \"</>\";\n      parser.state = S.TEXT;\n      return;\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== \"script\") {\n        parser.script += \"</\" + parser.tagName + \">\";\n        parser.tagName = \"\";\n        parser.state = S.SCRIPT;\n        return;\n      }\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]();\n    }\n    var closeTo = tagName;\n    while (t--) {\n      var close = parser.tags[t];\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, \"Unexpected close tag\");\n      } else {\n        break;\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n      parser.textNode += \"</\" + parser.tagName + \">\";\n      parser.state = S.TEXT;\n      return;\n    }\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n    while (s-- > t) {\n      var tag = (parser.tag = parser.tags.pop());\n      parser.tagName = parser.tag.name;\n      emitNode(parser, \"onclosetag\", parser.tagName);\n\n      var x = {};\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i];\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n        });\n      }\n    }\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n\n  function parseEntity(parser) {\n    var entity = parser.entity;\n    var entityLC = entity.toLowerCase();\n    var num;\n    var numStr = \"\";\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity];\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC];\n    }\n    entity = entityLC;\n    if (entity.charAt(0) === \"#\") {\n      if (entity.charAt(1) === \"x\") {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n    entity = entity.replace(/^0+/, \"\");\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, \"Invalid character entity\");\n      return \"&\" + parser.entity + \";\";\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n  function beginWhiteSpace(parser, c) {\n    if (c === \"<\") {\n      parser.state = S.OPEN_WAKA;\n      parser.startTagPosition = parser.position;\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, \"Non-whitespace before first tag.\");\n      parser.textNode = c;\n      parser.state = S.TEXT;\n    }\n  }\n\n  function charAt(chunk, i) {\n    var result = \"\";\n    if (i < chunk.length) {\n      result = chunk.charAt(i);\n    }\n    return result;\n  }\n\n  function write(chunk) {\n    var parser = this;\n    if (this.error) {\n      throw this.error;\n    }\n    if (parser.closed) {\n      return error(\n        parser,\n        \"Cannot write after close. Assign an onready handler.\"\n      );\n    }\n    if (chunk === null) {\n      return end(parser);\n    }\n    if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    }\n    var i = 0;\n    var c = \"\";\n    while (true) {\n      c = charAt(chunk, i++);\n      parser.c = c;\n\n      if (!c) {\n        break;\n      }\n\n      if (parser.trackPosition) {\n        parser.position++;\n        if (c === \"\\n\") {\n          parser.line++;\n          parser.column = 0;\n        } else {\n          parser.column++;\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE;\n          if (c === \"\\uFEFF\") {\n            continue;\n          }\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n            while (c && c !== \"<\" && c !== \"&\") {\n              c = charAt(chunk, i++);\n              if (c && parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                  parser.line++;\n                  parser.column = 0;\n                } else {\n                  parser.column++;\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n          if (\n            c === \"<\" &&\n            !(parser.sawRoot && parser.closedRoot && !parser.strict)\n          ) {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, \"Text data outside of root node.\");\n            }\n            if (c === \"&\") {\n              parser.state = S.TEXT_ENTITY;\n            } else {\n              parser.textNode += c;\n            }\n          }\n          continue;\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === \"<\") {\n            parser.state = S.SCRIPT_ENDING;\n          } else {\n            parser.script += c;\n          }\n          continue;\n\n        case S.SCRIPT_ENDING:\n          if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n          } else {\n            parser.script += \"<\" + c;\n            parser.state = S.SCRIPT;\n          }\n          continue;\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === \"!\") {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = \"\";\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = \"\";\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = \"\";\n          } else {\n            strictFail(parser, \"Unencoded <\");\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition;\n              c = new Array(pad).join(\" \") + c;\n            }\n            parser.textNode += \"<\" + c;\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, \"onopencdata\");\n            parser.state = S.CDATA;\n            parser.sgmlDecl = \"\";\n            parser.cdata = \"\";\n          } else if (parser.sgmlDecl + c === \"--\") {\n            parser.state = S.COMMENT;\n            parser.comment = \"\";\n            parser.sgmlDecl = \"\";\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser, \"Inappropriately located doctype declaration\");\n            }\n            parser.doctype = \"\";\n            parser.sgmlDecl = \"\";\n          } else if (c === \">\") {\n            emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n            parser.sgmlDecl = \"\";\n            parser.state = S.TEXT;\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else {\n            parser.sgmlDecl += c;\n          }\n          continue;\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = \"\";\n          }\n          parser.sgmlDecl += c;\n          continue;\n\n        case S.DOCTYPE:\n          if (c === \">\") {\n            parser.state = S.TEXT;\n            emitNode(parser, \"ondoctype\", parser.doctype);\n            parser.doctype = true; // just remember that we saw it.\n          } else {\n            parser.doctype += c;\n            if (c === \"[\") {\n              parser.state = S.DOCTYPE_DTD;\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n          continue;\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.q = \"\";\n            parser.state = S.DOCTYPE;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n          if (c === \"]\") {\n            parser.state = S.DOCTYPE;\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = \"\";\n          }\n          continue;\n\n        case S.COMMENT:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDING;\n          } else {\n            parser.comment += c;\n          }\n          continue;\n\n        case S.COMMENT_ENDING:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n            if (parser.comment) {\n              emitNode(parser, \"oncomment\", parser.comment);\n            }\n            parser.comment = \"\";\n          } else {\n            parser.comment += \"-\" + c;\n            parser.state = S.COMMENT;\n          }\n          continue;\n\n        case S.COMMENT_ENDED:\n          if (c !== \">\") {\n            strictFail(parser, \"Malformed comment\");\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += \"--\" + c;\n            parser.state = S.COMMENT;\n          } else {\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.CDATA:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING;\n          } else {\n            parser.cdata += c;\n          }\n          continue;\n\n        case S.CDATA_ENDING:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING_2;\n          } else {\n            parser.cdata += \"]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.CDATA_ENDING_2:\n          if (c === \">\") {\n            if (parser.cdata) {\n              emitNode(parser, \"oncdata\", parser.cdata);\n            }\n            emitNode(parser, \"onclosecdata\");\n            parser.cdata = \"\";\n            parser.state = S.TEXT;\n          } else if (c === \"]\") {\n            parser.cdata += \"]\";\n          } else {\n            parser.cdata += \"]]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.PROC_INST:\n          if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY;\n          } else {\n            parser.procInstName += c;\n          }\n          continue;\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue;\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else {\n            parser.procInstBody += c;\n          }\n          continue;\n\n        case S.PROC_INST_ENDING:\n          if (c === \">\") {\n            emitNode(parser, \"onprocessinginstruction\", {\n              name: parser.procInstName,\n              body: parser.procInstBody,\n            });\n            parser.procInstName = parser.procInstBody = \"\";\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += \"?\" + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n          continue;\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else {\n            newTag(parser);\n            if (c === \">\") {\n              openTag(parser);\n            } else if (c === \"/\") {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, \"Invalid character in tag name\");\n              }\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.OPEN_TAG_SLASH:\n          if (c === \">\") {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(\n              parser,\n              \"Forward-slash in opening tag not followed by >\"\n            );\n            parser.state = S.ATTRIB;\n          }\n          continue;\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_NAME:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (c === \">\") {\n            strictFail(parser, \"Attribute without value\");\n            parser.attribValue = parser.attribName;\n            attrib(parser);\n            openTag(parser);\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE;\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (isWhitespace(c)) {\n            continue;\n          } else {\n            strictFail(parser, \"Attribute without value\");\n            parser.tag.attributes[parser.attribName] = \"\";\n            parser.attribValue = \"\";\n            emitNode(parser, \"onattribute\", {\n              name: parser.attribName,\n              value: \"\",\n            });\n            parser.attribName = \"\";\n            if (c === \">\") {\n              openTag(parser);\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, \"Invalid attribute name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue;\n          } else if (isQuote(c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, \"Unquoted attribute value\");\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          parser.q = \"\";\n          parser.state = S.ATTRIB_VALUE_CLOSED;\n          continue;\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, \"No whitespace between attributes\");\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          if (c === \">\") {\n            openTag(parser);\n          } else {\n            parser.state = S.ATTRIB;\n          }\n          continue;\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue;\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += \"</\" + c;\n                parser.state = S.SCRIPT;\n              } else {\n                strictFail(parser, \"Invalid tagname in closing tag.\");\n              }\n            } else {\n              parser.tagName = c;\n            }\n          } else if (c === \">\") {\n            closeTag(parser);\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else if (parser.script) {\n            parser.script += \"</\" + parser.tagName;\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, \"Invalid tagname in closing tag\");\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n          continue;\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue;\n          }\n          if (c === \">\") {\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Invalid characters in closing tag\");\n          }\n          continue;\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState;\n          var buffer;\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT;\n              buffer = \"textNode\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED;\n              buffer = \"attribValue\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED;\n              buffer = \"attribValue\";\n              break;\n          }\n\n          if (c === \";\") {\n            if (parser.opt.unparsedEntities) {\n              var parsedEntity = parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n              parser.write(parsedEntity);\n            } else {\n              parser[buffer] += parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n            }\n          } else if (\n            isMatch(parser.entity.length ? entityBody : entityStart, c)\n          ) {\n            parser.entity += c;\n          } else {\n            strictFail(parser, \"Invalid character in entity name\");\n            parser[buffer] += \"&\" + parser.entity + c;\n            parser.entity = \"\";\n            parser.state = returnState;\n          }\n\n          continue;\n\n        default: /* istanbul ignore next */ {\n          throw new Error(parser, \"Unknown state: \" + parser.state);\n        }\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser);\n    }\n    return parser;\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode;\n      var floor = Math.floor;\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = arguments.length;\n        if (!length) {\n          return \"\";\n        }\n        var result = \"\";\n        while (++index < length) {\n          var codePoint = Number(arguments[index]);\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10ffff || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError(\"Invalid code point: \" + codePoint);\n          }\n          if (codePoint <= 0xffff) {\n            // BMP code point\n            codeUnits.push(codePoint);\n          } else {\n            // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000;\n            highSurrogate = (codePoint >> 10) + 0xd800;\n            lowSurrogate = (codePoint % 0x400) + 0xdc00;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n        return result;\n      };\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, \"fromCodePoint\", {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true,\n        });\n      } else {\n        String.fromCodePoint = fromCodePoint;\n      }\n    })();\n  }\n  return sax;\n};\n\nconst sax = /** #__PURE__ */ initializeSax();\n\nexport { sax };\n", "import {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"./transform.js\";\nimport { Operation, compare } from \"../utils/json_patch.js\";\nimport { sax } from \"../utils/sax-js/sax.js\";\nimport { ChatGeneration, Generation } from \"../outputs.js\";\n\nexport const XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\n\nexport interface XMLOutputParserFields\n  extends BaseCumulativeTransformOutputParserInput {\n  /**\n   * Optional list of tags that the output should conform to.\n   * Only used in formatting of the prompt.\n   */\n  tags?: string[];\n}\n\nexport type Content = string | undefined | Array<{ [key: string]: Content }>;\n\nexport type XMLResult = {\n  [key: string]: Content;\n};\n\nexport class XMLOutputParser extends BaseCumulativeTransformOutputParser<XMLResult> {\n  tags?: string[];\n\n  constructor(fields?: XMLOutputParserFields) {\n    super(fields);\n\n    this.tags = fields?.tags;\n  }\n\n  static lc_name() {\n    return \"XMLOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): Operation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{ op: \"replace\", path: \"\", value: next }];\n    }\n    return compare(prev, next);\n  }\n\n  async parsePartialResult(\n    generations: ChatGeneration[] | Generation[]\n  ): Promise<XMLResult | undefined> {\n    return parseXMLMarkdown(generations[0].text);\n  }\n\n  async parse(text: string): Promise<XMLResult> {\n    return parseXMLMarkdown(text);\n  }\n\n  getFormatInstructions(): string {\n    const withTags = !!(this.tags && this.tags.length > 0);\n    return withTags\n      ? XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n      : XML_FORMAT_INSTRUCTIONS;\n  }\n}\n\nconst strip = (text: string) =>\n  text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\n\ntype ParsedResult = {\n  name: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  attributes: Record<string, any>;\n  children: Array<ParsedResult>;\n  text?: string;\n  isSelfClosing: boolean;\n};\n\nconst parseParsedResult = (input: ParsedResult): XMLResult => {\n  if (Object.keys(input).length === 0) {\n    return {};\n  }\n  const result: XMLResult = {};\n  if (input.children.length > 0) {\n    result[input.name] = input.children.map(parseParsedResult);\n    return result;\n  } else {\n    result[input.name] = input.text ?? undefined;\n    return result;\n  }\n};\n\nexport function parseXMLMarkdown(s: string): XMLResult {\n  const cleanedString = strip(s);\n  const parser = sax.parser(true);\n  let parsedResult: ParsedResult = {} as ParsedResult;\n  const elementStack: ParsedResult[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onopentag = (node: any) => {\n    const element = {\n      name: node.name,\n      attributes: node.attributes,\n      children: [],\n      text: \"\",\n      isSelfClosing: node.isSelfClosing,\n    };\n\n    if (elementStack.length > 0) {\n      const parentElement = elementStack[elementStack.length - 1];\n      parentElement.children.push(element);\n    } else {\n      parsedResult = element as ParsedResult;\n    }\n\n    if (!node.isSelfClosing) {\n      elementStack.push(element);\n    }\n  };\n\n  parser.onclosetag = () => {\n    if (elementStack.length > 0) {\n      const lastElement = elementStack.pop();\n      if (elementStack.length === 0 && lastElement) {\n        parsedResult = lastElement as ParsedResult;\n      }\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.ontext = (text: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.text += text;\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onattribute = (attr: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.attributes[attr.name] = attr.value;\n    }\n  };\n\n  // Try to find XML string within triple backticks.\n  const match = /```(xml)?(.*)```/s.exec(cleanedString);\n  const xmlString = match ? match[2] : cleanedString;\n  parser.write(xmlString).close();\n\n  // Remove the XML declaration if present\n  if (parsedResult && parsedResult.name === \"?xml\") {\n    parsedResult = parsedResult.children[0] as ParsedResult;\n  }\n\n  return parseParsedResult(parsedResult);\n}\n", "import { __export } from \"../_virtual/rolldown_runtime.js\";\nimport { parseJsonMarkdown, parsePartialJson } from \"../utils/json.js\";\nimport { BaseLLMOutputParser, BaseOutputParser, OutputParserException } from \"./base.js\";\nimport { BaseCumulativeTransformOutputParser, BaseTransformOutputParser } from \"./transform.js\";\nimport { BytesOutputParser } from \"./bytes.js\";\nimport { CommaSeparatedListOutputParser, CustomListOutputParser, ListOutputParser, MarkdownListOutputParser, NumberedListOutputParser } from \"./list.js\";\nimport { StringOutputParser } from \"./string.js\";\nimport { AsymmetricStructuredOutputParser, JsonMarkdownStructuredOutputParser, StructuredOutputParser } from \"./structured.js\";\nimport { JsonOutputParser } from \"./json.js\";\nimport { XMLOutputParser, XML_FORMAT_INSTRUCTIONS, parseXMLMarkdown } from \"./xml.js\";\n\n//#region src/output_parsers/index.ts\nvar output_parsers_exports = {};\n__export(output_parsers_exports, {\n\tAsymmetricStructuredOutputParser: () => AsymmetricStructuredOutputParser,\n\tBaseCumulativeTransformOutputParser: () => BaseCumulativeTransformOutputParser,\n\tBaseLLMOutputParser: () => BaseLLMOutputParser,\n\tBaseOutputParser: () => BaseOutputParser,\n\tBaseTransformOutputParser: () => BaseTransformOutputParser,\n\tBytesOutputParser: () => BytesOutputParser,\n\tCommaSeparatedListOutputParser: () => CommaSeparatedListOutputParser,\n\tCustomListOutputParser: () => CustomListOutputParser,\n\tJsonMarkdownStructuredOutputParser: () => JsonMarkdownStructuredOutputParser,\n\tJsonOutputParser: () => JsonOutputParser,\n\tListOutputParser: () => ListOutputParser,\n\tMarkdownListOutputParser: () => MarkdownListOutputParser,\n\tNumberedListOutputParser: () => NumberedListOutputParser,\n\tOutputParserException: () => OutputParserException,\n\tStringOutputParser: () => StringOutputParser,\n\tStructuredOutputParser: () => StructuredOutputParser,\n\tXMLOutputParser: () => XMLOutputParser,\n\tXML_FORMAT_INSTRUCTIONS: () => XML_FORMAT_INSTRUCTIONS,\n\tparseJsonMarkdown: () => parseJsonMarkdown,\n\tparsePartialJson: () => parsePartialJson,\n\tparseXMLMarkdown: () => parseXMLMarkdown\n});\n\n//#endregion\nexport { AsymmetricStructuredOutputParser, BaseCumulativeTransformOutputParser, BaseLLMOutputParser, BaseOutputParser, BaseTransformOutputParser, BytesOutputParser, CommaSeparatedListOutputParser, CustomListOutputParser, JsonMarkdownStructuredOutputParser, JsonOutputParser, ListOutputParser, MarkdownListOutputParser, NumberedListOutputParser, OutputParserException, StringOutputParser, StructuredOutputParser, XMLOutputParser, XML_FORMAT_INSTRUCTIONS, output_parsers_exports, parseJsonMarkdown, parsePartialJson, parseXMLMarkdown };\n//# sourceMappingURL=index.js.map", "import type * as z3 from \"zod/v3\";\nimport type * as z4 from \"zod/v4/core\";\nimport { ChatGeneration, ChatGenerationChunk } from \"../../outputs.js\";\nimport { OutputParserException } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport { InvalidToolCall, ToolCall } from \"../../messages/tool.js\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"../transform.js\";\nimport { isAIMessage } from \"../../messages/ai.js\";\nimport {\n  type InteropZodType,\n  interopSafeParseAsync,\n} from \"../../utils/types/zod.js\";\n\nexport type ParsedToolCall = {\n  id?: string;\n\n  type: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: Record<string, any>;\n};\n\nexport type JsonOutputToolsParserParams = {\n  /** Whether to return the tool call id. */\n  returnId?: boolean;\n} & BaseCumulativeTransformOutputParserInput;\n\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options: { returnId?: boolean; partial: true }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: false }\n): ToolCall;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined {\n  if (rawToolCall.function === undefined) {\n    return undefined;\n  }\n  let functionArgs;\n  if (options?.partial) {\n    try {\n      functionArgs = parsePartialJson(rawToolCall.function.arguments ?? \"{}\");\n    } catch {\n      return undefined;\n    }\n  } else {\n    try {\n      functionArgs = JSON.parse(rawToolCall.function.arguments);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new OutputParserException(\n        [\n          `Function \"${rawToolCall.function.name}\" arguments:`,\n          ``,\n          rawToolCall.function.arguments,\n          ``,\n          `are not valid JSON.`,\n          `Error: ${e.message}`,\n        ].join(\"\\n\")\n      );\n    }\n  }\n\n  const parsedToolCall: ToolCall = {\n    name: rawToolCall.function.name,\n    args: functionArgs,\n    type: \"tool_call\",\n  };\n\n  if (options?.returnId) {\n    parsedToolCall.id = rawToolCall.id;\n  }\n\n  return parsedToolCall;\n}\n\nexport function convertLangChainToolCallToOpenAI(toolCall: ToolCall) {\n  if (toolCall.id === undefined) {\n    throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n  }\n  return {\n    id: toolCall.id,\n    type: \"function\",\n    function: {\n      name: toolCall.name,\n      arguments: JSON.stringify(toolCall.args),\n    },\n  };\n}\n\nexport function makeInvalidToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  errorMsg?: string\n): InvalidToolCall {\n  return {\n    name: rawToolCall.function?.name,\n    args: rawToolCall.function?.arguments,\n    id: rawToolCall.id,\n    error: errorMsg,\n    type: \"invalid_tool_call\",\n  };\n}\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser<\n  T,\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n\n  returnId = false;\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  constructor(fields?: JsonOutputToolsParserParams) {\n    super(fields);\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n\n  protected _diff() {\n    throw new Error(\"Not supported.\");\n  }\n\n  async parse(): Promise<T> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async parseResult(generations: ChatGeneration[]): Promise<T> {\n    const result = await this.parsePartialResult(generations, false);\n    return result;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parsePartialResult(\n    generations: ChatGenerationChunk[] | ChatGeneration[],\n    partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const message = generations[0].message;\n    let toolCalls;\n    if (isAIMessage(message) && message.tool_calls?.length) {\n      toolCalls = message.tool_calls.map((toolCall) => {\n        const { id, ...rest } = toolCall;\n        if (!this.returnId) {\n          return rest;\n        }\n        return {\n          id,\n          ...rest,\n        };\n      });\n    } else if (message.additional_kwargs.tool_calls !== undefined) {\n      const rawToolCalls = JSON.parse(\n        JSON.stringify(message.additional_kwargs.tool_calls)\n      );\n      toolCalls = rawToolCalls.map((rawToolCall: Record<string, unknown>) => {\n        return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n      });\n    }\n    if (!toolCalls) {\n      return [];\n    }\n    const parsedToolCalls = [];\n    for (const toolCall of toolCalls) {\n      if (toolCall !== undefined) {\n        const backwardsCompatibleToolCall: ParsedToolCall = {\n          type: toolCall.name,\n          args: toolCall.args,\n          id: toolCall.id,\n        };\n        parsedToolCalls.push(backwardsCompatibleToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n\ntype JsonOutputKeyToolsParserParamsBase = {\n  keyName: string;\n  returnSingle?: boolean;\n} & JsonOutputToolsParserParams;\n\ntype JsonOutputKeyToolsParserParamsV3<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: z3.ZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\ntype JsonOutputKeyToolsParserParamsV4<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: z4.$ZodType<T, T> } & JsonOutputKeyToolsParserParamsBase;\n\nexport type JsonOutputKeyToolsParserParamsInterop<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: InteropZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\n// Use Zod 3 for backwards compatibility\nexport type JsonOutputKeyToolsParserParams<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = JsonOutputKeyToolsParserParamsV3<T>;\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> extends JsonOutputToolsParser<T> {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  zodSchema?: InteropZodType<T>;\n\n  constructor(params: JsonOutputKeyToolsParserParamsV3<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsV4<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsInterop<T>);\n\n  constructor(\n    params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>\n  ) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n\n  protected async _validateResult(result: unknown): Promise<T> {\n    if (this.zodSchema === undefined) {\n      return result as T;\n    }\n    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${JSON.stringify(\n          result,\n          null,\n          2\n        )}\". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`,\n        JSON.stringify(result, null, 2)\n      );\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parsePartialResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return returnedValues[0];\n    }\n    return returnedValues;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations, false);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return this._validateResult(returnedValues[0]);\n    }\n    const toolCallResults = await Promise.all(\n      returnedValues.map((value) => this._validateResult(value))\n    );\n    return toolCallResults;\n  }\n}\n", "import { __export } from \"../../_virtual/rolldown_runtime.js\";\nimport { JsonOutputKeyToolsParser, JsonOutputToolsParser, convertLangChainToolCallToOpenAI, makeInvalidToolCall, parseToolCall } from \"./json_output_tools_parsers.js\";\n\n//#region src/output_parsers/openai_tools/index.ts\nvar openai_tools_exports = {};\n__export(openai_tools_exports, {\n\tJsonOutputKeyToolsParser: () => JsonOutputKeyToolsParser,\n\tJsonOutputToolsParser: () => JsonOutputToolsParser,\n\tconvertLangChainToolCallToOpenAI: () => convertLangChainToolCallToOpenAI,\n\tmakeInvalidToolCall: () => makeInvalidToolCall,\n\tparseToolCall: () => parseToolCall\n});\n\n//#endregion\nexport { JsonOutputKeyToolsParser, JsonOutputToolsParser, convertLangChainToolCallToOpenAI, makeInvalidToolCall, openai_tools_exports, parseToolCall };\n//# sourceMappingURL=index.js.map", "import type { z as z3 } from \"zod/v3\";\nimport { CallbackManagerForToolRun } from \"../callbacks/manager.js\";\nimport type {\n  BaseLangChainParams,\n  ToolDefinition,\n} from \"../language_models/base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport {\n  Runnable,\n  RunnableToolLike,\n  type RunnableInterface,\n} from \"../runnables/base.js\";\nimport {\n  type DirectToolOutput,\n  type ToolCall,\n  type ToolMessage,\n} from \"../messages/tool.js\";\nimport type { MessageContent } from \"../messages/base.js\";\nimport {\n  type InferInteropZodInput,\n  type InferInteropZodOutput,\n  type InteropZodType,\n  isInteropZodSchema,\n  type InteropZodObject,\n} from \"../utils/types/zod.js\";\n\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport type { BaseStore } from \"../stores.js\";\n\nexport type ResponseFormat = \"content\" | \"content_and_artifact\" | string;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolOutputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ContentAndArtifact = [MessageContent, any];\n\n/**\n * Conditional type that determines the return type of the {@link StructuredTool.invoke} method.\n * - If the input is a ToolCall, it returns a ToolMessage\n * - If the config is a runnable config and contains a toolCall property, it returns a ToolMessage\n * - Otherwise, it returns the original output type\n */\nexport type ToolReturnType<TInput, TConfig, TOutput> =\n  TOutput extends DirectToolOutput\n    ? TOutput\n    : TConfig extends { toolCall: { id: string } }\n      ? ToolMessage\n      : TConfig extends { toolCall: { id: undefined } }\n        ? TOutput\n        : TConfig extends { toolCall: { id?: string } }\n          ? TOutput | ToolMessage\n          : TInput extends ToolCall\n            ? ToolMessage\n            : TOutput;\n\n/**\n * Base type that establishes the types of input schemas that can be used for LangChain tool\n * definitions.\n */\nexport type ToolInputSchemaBase = z3.ZodTypeAny | JSONSchema;\n\n/**\n * Parameters for the Tool classes.\n */\nexport interface ToolParams extends BaseLangChainParams {\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n  /**\n   * Whether to show full details in the thrown parsing errors.\n   *\n   * @default false\n   */\n  verboseParsingErrors?: boolean;\n  /**\n   * Metadata for the tool.\n   */\n  metadata?: Record<string, unknown>;\n  /**\n   * Optional provider-specific extra fields for the tool.\n   *\n   * This is used to pass provider-specific configuration that doesn't fit into\n   * standard tool fields.\n   */\n  extras?: Record<string, unknown>;\n}\n\nexport type ToolRunnableConfig<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ConfigurableFieldType extends Record<string, any> = Record<string, any>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextSchema = any,\n> = RunnableConfig<ConfigurableFieldType> & {\n  toolCall?: ToolCall;\n  context?: ContextSchema;\n};\n\n/**\n * Schema for defining tools.\n *\n * @version 0.2.19\n */\nexport interface StructuredToolParams\n  extends Pick<StructuredToolInterface, \"name\" | \"schema\" | \"extras\"> {\n  /**\n   * An optional description of the tool to pass to the model.\n   */\n  description?: string;\n}\n\n/**\n * Utility type that resolves the output type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaOutputType<T> = T extends InteropZodType\n  ? InferInteropZodOutput<T>\n  : T extends JSONSchema\n    ? unknown\n    : never;\n\n/**\n * Utility type that resolves the input type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaInputType<T> = T extends InteropZodType\n  ? InferInteropZodInput<T>\n  : T extends JSONSchema\n    ? unknown\n    : never;\n\n/**\n * Defines the type that will be passed into a tool handler function as a result of a tool call.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport type StructuredToolCallInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n> =\n  | (ToolInputSchemaOutputType<SchemaT> extends string ? string : never)\n  | SchemaInputT\n  | ToolCall;\n\n/**\n * An input schema type for tools that accept a single string input.\n *\n * This schema defines a tool that takes an optional string parameter named \"input\".\n * It uses Zod's effects to transform the input and strip any extra properties.\n *\n * This is primarily used for creating simple string-based tools where the LLM\n * only needs to provide a single text value as input to the tool.\n */\nexport type StringInputToolSchema = z3.ZodType<\n  string | undefined,\n  z3.ZodTypeDef,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  any\n>;\n\n/**\n * Defines the type for input to a tool's call method.\n *\n * This type is a convenience alias for StructuredToolCallInput with the input type\n * derived from the schema. It represents the possible inputs that can be passed to a tool,\n * which can be either:\n * - A string (if the tool accepts string input)\n * - A structured input matching the tool's schema\n * - A ToolCall object (typically from an LLM)\n *\n * @param SchemaT - The schema type for the tool input, defaults to StringInputToolSchema\n */\nexport type ToolCallInput<SchemaT = StringInputToolSchema> =\n  StructuredToolCallInput<SchemaT, ToolInputSchemaInputType<SchemaT>>;\n\n/**\n * Interface that defines the shape of a LangChain structured tool.\n *\n * A structured tool is a tool that uses a schema to define the structure of the arguments that the\n * LLM generates as part of its {@link ToolCall}.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface StructuredToolInterface<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n> extends RunnableInterface<\n    StructuredToolCallInput<SchemaT, SchemaInputT>,\n    ToolOutputT | ToolMessage\n  > {\n  lc_namespace: string[];\n\n  /**\n   * A Zod schema representing the parameters of the tool.\n   */\n  schema: SchemaT;\n\n  /**\n   * Invokes the tool with the provided argument and configuration.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration for the tool call.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  invoke<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    arg: TArg,\n    configArg?: TConfig\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * The name of the tool.\n   */\n  name: string;\n\n  /**\n   * A description of the tool.\n   */\n  description: string;\n\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect: boolean;\n\n  /**\n   * Optional provider-specific extra fields for the tool.\n   *\n   * This is used to pass provider-specific configuration that doesn't fit into\n   * standard tool fields.\n   */\n  extras?: Record<string, unknown>;\n}\n\n/**\n * A special interface for tools that accept a string input, usually defined with the {@link Tool} class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface ToolInterface<\n  SchemaT = StringInputToolSchema,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n> extends StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT> {\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined,\n  >(\n    // TODO: shouldn't this be narrowed based on SchemaT?\n    arg: TArg,\n    callbacks?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>>;\n}\n\n/**\n * Base interface for the input parameters of the {@link DynamicTool} and\n * {@link DynamicStructuredTool} classes.\n */\nexport interface BaseDynamicToolInput extends ToolParams {\n  name: string;\n  description: string;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n\n/**\n * Interface for the input parameters of the DynamicTool class.\n */\nexport interface DynamicToolInput<ToolOutputT = ToolOutputType>\n  extends BaseDynamicToolInput {\n  func: (\n    input: string,\n    runManager?: CallbackManagerForToolRun,\n    config?: ToolRunnableConfig\n  ) => Promise<ToolOutputT>;\n}\n\n/**\n * Interface for the input parameters of the DynamicStructuredTool class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaOutputT - The TypeScript type representing the result of applying the schema to the tool arguments. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface DynamicStructuredToolInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n> extends BaseDynamicToolInput {\n  /**\n   * Tool handler function - the function that will be called when the tool is invoked.\n   *\n   * @param input - The input to the tool.\n   * @param runManager - The run manager for the tool.\n   * @param config - The configuration for the tool.\n   * @returns The result of the tool.\n   */\n  func: (\n    input: SchemaOutputT,\n    runManager?: CallbackManagerForToolRun,\n    config?: RunnableConfig\n  ) => Promise<ToolOutputT>;\n  schema: SchemaT;\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nexport function isStructuredTool(\n  tool?: StructuredToolInterface | ToolDefinition | JSONSchema\n): tool is StructuredToolInterface {\n  return (\n    tool !== undefined &&\n    Array.isArray((tool as StructuredToolInterface).lc_namespace)\n  );\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nexport function isRunnableToolLike(tool?: unknown): tool is RunnableToolLike {\n  return (\n    tool !== undefined &&\n    Runnable.isRunnable(tool) &&\n    \"lc_name\" in tool.constructor &&\n    typeof tool.constructor.lc_name === \"function\" &&\n    tool.constructor.lc_name() === \"RunnableToolLike\"\n  );\n}\n\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nexport function isStructuredToolParams(\n  tool?: unknown\n): tool is StructuredToolParams {\n  return (\n    !!tool &&\n    typeof tool === \"object\" &&\n    \"name\" in tool &&\n    \"schema\" in tool &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (isInteropZodSchema(tool.schema as Record<string, any>) ||\n      (tool.schema != null &&\n        typeof tool.schema === \"object\" &&\n        \"type\" in tool.schema &&\n        typeof tool.schema.type === \"string\" &&\n        [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"].includes(\n          tool.schema.type\n        )))\n  );\n}\n\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nexport function isLangChainTool(tool?: unknown): tool is StructuredToolParams {\n  return (\n    isStructuredToolParams(tool) ||\n    isRunnableToolLike(tool) ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isStructuredTool(tool as any)\n  );\n}\n\n/**\n * Runtime context automatically injected into tools.\n *\n * When a tool function has a parameter named `tool_runtime` with type hint\n * `ToolRuntime`, the tool execution system will automatically inject an instance\n * containing:\n *\n * - `state`: The current graph state\n * - `toolCallId`: The ID of the current tool call\n * - `config`: `RunnableConfig` for the current execution\n * - `context`: Runtime context\n * - `store`: `BaseStore` instance for persistent storage\n * - `writer`: Stream writer for streaming output\n *\n * No `Annotated` wrapper is needed - just use `runtime: ToolRuntime`\n * as a parameter.\n *\n * @example\n * ```typescript\n * import { tool, type ToolRuntime } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const stateSchema = z.object({\n *   messages: z.array(z.any()),\n *   userId: z.string().optional(),\n * });\n *\n * const greet = tool(\n *   async ({ name }, runtime: ToolRuntime<typeof stateSchema>) => {\n *     // Access state\n *     const messages = runtime.state.messages;\n *\n *     // Access tool_call_id\n *     console.log(`Tool call ID: ${runtime.toolCallId}`);\n *\n *     // Access config\n *     console.log(`Run ID: ${runtime.config.runId}`);\n *\n *     // Access runtime context\n *     const userId = runtime.context?.userId;\n *\n *     // Access store\n *     await runtime.store?.mset([[\"key\", \"value\"]]);\n *\n *     // Stream output\n *     runtime.writer?.(\"Processing...\");\n *\n *     return `Hello! User ID: ${runtime.state.userId || \"unknown\"} ${name}`;\n *   },\n *   {\n *     name: \"greet\",\n *     description: \"Use this to greet the user once you found their info.\",\n *     schema: z.object({ name: z.string() }),\n *     stateSchema,\n *   }\n * );\n *\n * const agent = createAgent({\n *   model,\n *   tools: [greet],\n *   stateSchema,\n *   contextSchema,\n * });\n * ```\n *\n * @template StateT - The type of the state schema (inferred from stateSchema)\n * @template ContextT - The type of the context schema (inferred from contextSchema)\n */\nexport type ToolRuntime<\n  TState = unknown,\n  TContext = unknown,\n> = RunnableConfig & {\n  /**\n   * The current graph state.\n   */\n  state: TState extends InteropZodObject\n    ? InferInteropZodOutput<TState>\n    : TState extends Record<string, unknown>\n      ? TState\n      : unknown;\n  /**\n   * The ID of the current tool call.\n   */\n  toolCallId: string;\n  /**\n   * The current tool call.\n   */\n  toolCall?: ToolCall;\n  /**\n   * RunnableConfig for the current execution.\n   */\n  config: ToolRunnableConfig;\n  /**\n   * Runtime context (from langgraph `Runtime`).\n   */\n  context: TContext extends InteropZodObject\n    ? InferInteropZodOutput<TContext>\n    : TContext extends Record<string, unknown>\n      ? TContext\n      : unknown;\n  /**\n   * BaseStore instance for persistent storage (from langgraph `Runtime`).\n   */\n  store: BaseStore<string, unknown> | null;\n  /**\n   * Stream writer for streaming output (from langgraph `Runtime`).\n   */\n  writer: ((chunk: unknown) => void) | null;\n};\n", "import {\n  StructuredToolInterface,\n  StructuredToolParams,\n  isLangChainTool,\n} from \"../tools/types.js\";\nimport { FunctionDefinition, ToolDefinition } from \"../language_models/base.js\";\nimport { RunnableToolLike } from \"../runnables/base.js\";\nimport { toJsonSchema } from \"./json_schema.js\";\n\n// These utility functions were moved to a more appropriate location,\n// but we still export them here for backwards compatibility.\nexport {\n  isStructuredTool,\n  isStructuredToolParams,\n  isRunnableToolLike,\n  isLangChainTool,\n} from \"../tools/types.js\";\n\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a format\n * that is compatible with OpenAI function calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | RunnableToolLike} tool The tool to convert to an OpenAI function.\n * @returns {FunctionDefinition} The inputted tool in OpenAI function format.\n */\nexport function convertToOpenAIFunction(\n  tool: StructuredToolInterface | RunnableToolLike | StructuredToolParams,\n  fields?:\n    | {\n        /**\n         * If `true`, model output is guaranteed to exactly match the JSON Schema\n         * provided in the function definition.\n         */\n        strict?: boolean;\n      }\n    | number\n): FunctionDefinition {\n  // @TODO 0.3.0 Remove the `number` typing\n  const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n\n  return {\n    name: tool.name,\n    description: tool.description,\n    parameters: toJsonSchema(tool.schema),\n    // Do not include the `strict` field if it is `undefined`.\n    ...(fieldsCopy?.strict !== undefined ? { strict: fieldsCopy.strict } : {}),\n  };\n}\n\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a\n * format that is compatible with OpenAI tool calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | Record<string, any> | RunnableToolLike} tool The tool to convert to an OpenAI tool.\n * @returns {ToolDefinition} The inputted tool in OpenAI tool format.\n */\nexport function convertToOpenAITool(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tool: StructuredToolInterface | Record<string, any> | RunnableToolLike,\n  fields?:\n    | {\n        /**\n         * If `true`, model output is guaranteed to exactly match the JSON Schema\n         * provided in the function definition.\n         */\n        strict?: boolean;\n      }\n    | number\n): ToolDefinition {\n  // @TODO 0.3.0 Remove the `number` typing\n  const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n\n  let toolDef: ToolDefinition | undefined;\n  if (isLangChainTool(tool)) {\n    toolDef = {\n      type: \"function\",\n      function: convertToOpenAIFunction(tool),\n    };\n  } else {\n    toolDef = tool as ToolDefinition;\n  }\n\n  if (fieldsCopy?.strict !== undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (toolDef.function as any).strict = fieldsCopy.strict;\n  }\n\n  return toolDef;\n}\n", "import {\n  JsonSchema7Type,\n  toJsonSchema,\n} from \"@langchain/core/utils/json_schema\";\nimport { NewTokenIndices } from \"@langchain/core/callbacks/base\";\nimport { CallbackManagerForLLMRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  BaseChatModel,\n  BaseChatModelCallOptions,\n  BindToolsInput,\n  LangSmithParams,\n  type BaseChatModelParams,\n} from \"@langchain/core/language_models/chat_models\";\nimport * as ChatCompletionsAPI from \"groq-sdk/resources/chat/completions\";\nimport * as CompletionsAPI from \"groq-sdk/resources/completions\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  ChatMessage,\n  ChatMessageChunk,\n  HumanMessageChunk,\n  SystemMessageChunk,\n  ToolMessage,\n  OpenAIToolCall,\n  isAIMessage,\n  BaseMessageChunk,\n  UsageMetadata,\n  FunctionMessageChunk,\n  ToolMessageChunk,\n} from \"@langchain/core/messages\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  ChatResult,\n} from \"@langchain/core/outputs\";\nimport { getEnvironmentVariable } from \"@langchain/core/utils/env\";\nimport {\n  InteropZodType,\n  isInteropZodSchema,\n} from \"@langchain/core/utils/types\";\nimport Groq from \"groq-sdk\";\nimport type {\n  ChatCompletion,\n  ChatCompletionCreateParams,\n  ChatCompletionCreateParamsNonStreaming,\n  ChatCompletionCreateParamsStreaming,\n  ChatCompletionTool,\n} from \"groq-sdk/resources/chat/completions\";\nimport type { RequestOptions } from \"groq-sdk/core\";\nimport {\n  Runnable,\n  RunnablePassthrough,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport {\n  BaseLanguageModelInput,\n  FunctionDefinition,\n  StructuredOutputMethodOptions,\n} from \"@langchain/core/language_models/base\";\nimport { ModelProfile } from \"@langchain/core/language_models/profile\";\nimport {\n  BaseLLMOutputParser,\n  JsonOutputParser,\n  StructuredOutputParser,\n} from \"@langchain/core/output_parsers\";\nimport {\n  JsonOutputKeyToolsParser,\n  parseToolCall,\n  makeInvalidToolCall,\n  convertLangChainToolCallToOpenAI,\n} from \"@langchain/core/output_parsers/openai_tools\";\nimport { convertToOpenAITool } from \"@langchain/core/utils/function_calling\";\nimport { ToolCallChunk } from \"@langchain/core/messages/tool\";\n\nimport PROFILES from \"./profiles.js\";\n\ntype ChatGroqToolType = BindToolsInput | ChatCompletionTool;\n\n/**\n * Const list of fields that we'll pick from the `ChatCompletionCreateParams` interface\n * to use as the options allowed to be passed to invocation methods.\n *\n * @internal\n */\nconst CREATE_PARAMS_BASE_CALL_KEYS = [\n  // \"messages\", // passed as input arg to invocation methods\n  // \"model\", // don't allow override on invoke\n  \"frequency_penalty\",\n  \"function_call\",\n  \"functions\",\n  \"logit_bias\", // not supported, but left in for forward compatibility\n  \"logprobs\", // not supported, but left in for forward compatibility\n  \"max_completion_tokens\",\n  \"max_tokens\",\n  \"n\", // not supported, but left in for forward compatibility\n  \"parallel_tool_calls\",\n  \"presence_penalty\",\n  \"reasoning_format\",\n  \"response_format\",\n  \"seed\",\n  // TODO: also pass as constructor arg\n  \"service_tier\",\n  \"stop\",\n  // \"stream\", // determined by invocation method\n  // other models only specify temperature as a constructor arg, but I don't see the harm in\n  // allowing overrides on invocation\n  \"temperature\",\n  \"tool_choice\",\n  // \"tools\", // need to allow users to specify langchain style tools, so we use a different type\n  \"top_logprobs\",\n  \"top_p\",\n  // \"user\", // don't allow override on invoke\n] as const;\n\nconst ADDED_CALL_KEYS = [\n  \"headers\",\n  \"promptIndex\",\n  \"stream_options\",\n  \"tools\",\n] as const;\n\nexport type ChatGroqCallOptions = Pick<\n  ChatCompletionsAPI.ChatCompletionCreateParamsBase,\n  (typeof CREATE_PARAMS_BASE_CALL_KEYS)[number]\n> &\n  BaseChatModelCallOptions & {\n    /**\n     * Additional headers to pass to the API.\n     */\n    headers?: Record<string, string | null | undefined>;\n    /**\n     * The index of the prompt in the list of prompts.\n     */\n    promptIndex?: number;\n    /**\n     * Additional options to pass to streamed completions.\n     * If provided takes precedence over \"streamUsage\" set at initialization time.\n     */\n    stream_options?: {\n      /**\n       * Whether or not to include token usage in the stream.\n       * If set to `true`, this will include an additional\n       * chunk at the end of the stream with the token usage.\n       *\n       * Defaults to `true` when streaming, `false` otherwise.\n       */\n      include_usage: boolean;\n    };\n\n    tools?: ChatGroqToolType[];\n\n    // IMPORTANT: If you add a new key here you MUST add it to the `ADDED_CALL_KEYS`\n    // list above. Keep this comment at the bottom so people see it when they go to\n    // make additions.\n  };\n\nconst ALL_CALL_KEYS: readonly (keyof ChatGroqCallOptions)[] = [\n  ...CREATE_PARAMS_BASE_CALL_KEYS,\n  ...ADDED_CALL_KEYS,\n] as const;\n\n/**\n * Timing details about the request, useful for collecting performance metrics.\n */\ninterface TimingMetadata {\n  /**\n   * Time spent generating tokens\n   */\n  completion_time?: number;\n\n  /**\n   * Time spent processing input tokens\n   */\n  prompt_time?: number;\n\n  /**\n   * Time the requests was spent queued\n   */\n  queue_time?: number;\n\n  /**\n   * completion time and prompt time combined\n   */\n  total_time?: number;\n}\nexport interface ChatGroqInput extends BaseChatModelParams {\n  /**\n   * The temperature to use for sampling.\n   * @default 0.7\n   */\n  temperature?: number;\n\n  /**\n   * The maximum number of tokens that the model can process in a single response.\n   * This limits ensures computational efficiency and resource management.\n   */\n  maxTokens?: number;\n\n  /** Total probability mass of tokens to consider at each step */\n  topP?: number;\n\n  /** Penalizes repeated tokens according to frequency */\n  frequencyPenalty?: number;\n\n  /** Penalizes repeated tokens */\n  presencePenalty?: number;\n\n  /** Number of completions to generate for each prompt */\n  n?: number;\n\n  /** Dictionary used to adjust the probability of specific tokens being generated */\n  logitBias?: Record<string, number>;\n\n  /** Unique string identifier representing your end-user, which can help OpenAI to monitor and detect abuse. */\n  user?: string;\n\n  /**\n   * Whether or not to include token usage data in streamed chunks.\n   * @default true\n   */\n  streamUsage?: boolean;\n\n  /**\n   * Whether to return log probabilities of the output tokens or not.\n   * If true, returns the log probabilities of each output token returned in the content of message.\n   */\n  logprobs?: boolean;\n\n  /**\n   * An integer between 0 and 5 specifying the number of most likely tokens to return at each token position,\n   * each with an associated log probability. logprobs must be set to true if this parameter is used.\n   */\n  topLogprobs?: number;\n\n  /**\n   * The Groq API key to use for requests.\n   * @default process.env.GROQ_API_KEY\n   */\n  apiKey?: string;\n  /**\n   * The name of the model to use.\n   */\n  model: string;\n  /**\n   * Up to 4 sequences where the API will stop generating further tokens. The\n   * returned text will not contain the stop sequence.\n   * Alias for `stopSequences`\n   */\n  stop?: string | null | Array<string>;\n  /**\n   * Up to 4 sequences where the API will stop generating further tokens. The\n   * returned text will not contain the stop sequence.\n   */\n  stopSequences?: Array<string>;\n  /**\n   * Whether or not to stream responses.\n   */\n  streaming?: boolean;\n  /**\n   * Override the default base URL for the API\n   */\n  baseUrl?: string;\n  /**\n   * The maximum amount of time (in milliseconds) the client will wait for a response\n   */\n  timeout?: number;\n  /**\n   * HTTP agent used to manage connections\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  httpAgent?: any;\n  /**\n   * Custom fetch function implementation\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  fetch?: (...args: any) => any;\n\n  /**\n   * Default headers included with every request\n   */\n  defaultHeaders?: Record<string, string>;\n\n  /**\n   * Default query parameters included with every request\n   */\n  defaultQuery?: Record<string, string>;\n}\n\ntype GroqRoleEnum = \"system\" | \"assistant\" | \"user\" | \"function\";\n\ninterface TokenUsage {\n  completionTokens?: number;\n  promptTokens?: number;\n  totalTokens?: number;\n}\n\n/**\n * Extract the custom role from a message.\n * @param message - The message to extract the custom role from.\n * @returns The custom role of the message.\n */\nfunction extractGenericMessageCustomRole(message: ChatMessage): GroqRoleEnum {\n  if (\n    message.role !== \"system\" &&\n    message.role !== \"assistant\" &&\n    message.role !== \"user\" &&\n    message.role !== \"function\"\n  ) {\n    throw new Error(\n      `Unsupported message role: ${message.role}. Expected \"system\", \"assistant\", \"user\", or \"function\"`\n    );\n  }\n  return message.role as GroqRoleEnum;\n}\n\n/**\n * Extract the role from a message.\n * @param message - The message to extract the role from.\n * @returns The role of the message.\n */\nexport function messageToGroqRole(message: BaseMessage): GroqRoleEnum {\n  switch (message.type) {\n    case \"system\":\n      return \"system\";\n    case \"ai\":\n      return \"assistant\";\n    case \"human\":\n      return \"user\";\n    case \"function\":\n      return \"function\";\n    case \"tool\":\n      // Not yet supported as a type\n      return \"tool\" as GroqRoleEnum;\n    case \"generic\": {\n      if (!ChatMessage.isInstance(message))\n        throw new Error(\"Invalid generic chat message\");\n      return extractGenericMessageCustomRole(message);\n    }\n    default:\n      throw new Error(`Unknown message type: ${message.type}`);\n  }\n}\n\nfunction convertMessagesToGroqParams(\n  messages: BaseMessage[]\n): Array<ChatCompletionsAPI.ChatCompletionMessage> {\n  return messages.map((message): ChatCompletionsAPI.ChatCompletionMessage => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const completionParam: Record<string, any> = {\n      role: messageToGroqRole(message),\n      content: message.content,\n      name: message.name,\n      function_call: message.additional_kwargs.function_call,\n      tool_calls: message.additional_kwargs.tool_calls,\n      tool_call_id: (message as ToolMessage).tool_call_id,\n    };\n    if (isAIMessage(message) && !!message.tool_calls?.length) {\n      completionParam.tool_calls = message.tool_calls.map(\n        convertLangChainToolCallToOpenAI\n      );\n    } else {\n      if (message.additional_kwargs.tool_calls != null) {\n        completionParam.tool_calls = message.additional_kwargs.tool_calls;\n      }\n      if ((message as ToolMessage).tool_call_id != null) {\n        completionParam.tool_call_id = (message as ToolMessage).tool_call_id;\n      }\n    }\n    return completionParam as ChatCompletionsAPI.ChatCompletionMessage;\n  });\n}\n\nfunction groqResponseToChatMessage(\n  message: ChatCompletionsAPI.ChatCompletionMessage,\n  usageMetadata?: UsageMetadata,\n  responseMetadata?: Record<string, unknown>\n): BaseMessage {\n  const rawToolCalls: OpenAIToolCall[] | undefined = message.tool_calls as\n    | OpenAIToolCall[]\n    | undefined;\n  // Add model_provider for block translator lookup\n  const enrichedMetadata = { ...responseMetadata, model_provider: \"groq\" };\n  switch (message.role) {\n    case \"assistant\": {\n      const toolCalls = [];\n      const invalidToolCalls = [];\n      for (const rawToolCall of rawToolCalls ?? []) {\n        try {\n          toolCalls.push(parseToolCall(rawToolCall, { returnId: true }));\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          invalidToolCalls.push(makeInvalidToolCall(rawToolCall, e.message));\n        }\n      }\n      return new AIMessage({\n        content: message.content || \"\",\n        additional_kwargs: { tool_calls: rawToolCalls },\n        tool_calls: toolCalls,\n        invalid_tool_calls: invalidToolCalls,\n        usage_metadata: usageMetadata,\n        response_metadata: enrichedMetadata,\n      });\n    }\n    default:\n      return new ChatMessage(message.content || \"\", message.role ?? \"unknown\");\n  }\n}\n\nfunction _convertDeltaToMessageChunk(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  delta: Record<string, any>,\n  defaultRole: GroqRoleEnum | undefined,\n  rawResponse: ChatCompletionsAPI.ChatCompletionChunk,\n  lastMessageId: string | undefined\n): BaseMessageChunk {\n  const role = delta.role ?? defaultRole;\n  const content = delta.content ?? \"\";\n  let additional_kwargs: Record<string, unknown>;\n  if (delta.function_call) {\n    additional_kwargs = {\n      function_call: delta.function_call,\n    };\n  } else if (delta.tool_calls) {\n    additional_kwargs = {\n      tool_calls: delta.tool_calls,\n    };\n  } else {\n    additional_kwargs = {};\n  }\n  if (delta.audio) {\n    additional_kwargs.audio = {\n      ...delta.audio,\n      index: rawResponse.choices[0].index,\n    };\n  }\n\n  let usage: UsageMetadata | undefined;\n  let groqMessageId: string | undefined = lastMessageId;\n  let timing: TimingMetadata | undefined;\n\n  const xGroq = rawResponse.x_groq;\n  if (xGroq?.usage) {\n    usage = {\n      input_tokens: xGroq.usage.prompt_tokens,\n      output_tokens: xGroq.usage.completion_tokens,\n      total_tokens: xGroq.usage.total_tokens,\n    };\n    timing = {\n      completion_time: xGroq.usage.completion_time,\n      prompt_time: xGroq.usage.prompt_time,\n      queue_time: xGroq.usage.queue_time,\n      total_time: xGroq.usage.total_time,\n    };\n  }\n\n  if (xGroq?.id) {\n    groqMessageId = xGroq.id;\n  }\n\n  const response_metadata = { usage, timing, model_provider: \"groq\" };\n  if (role === \"user\") {\n    return new HumanMessageChunk({ content, response_metadata });\n  } else if (role === \"assistant\") {\n    const toolCallChunks: ToolCallChunk[] = [];\n    if (Array.isArray(delta.tool_calls)) {\n      for (const rawToolCall of delta.tool_calls) {\n        toolCallChunks.push({\n          name: rawToolCall.function?.name,\n          args: rawToolCall.function?.arguments,\n          id: rawToolCall.id,\n          index: rawToolCall.index,\n          type: \"tool_call_chunk\",\n        });\n      }\n    }\n    return new AIMessageChunk({\n      content,\n      tool_call_chunks: toolCallChunks,\n      additional_kwargs,\n      id: groqMessageId,\n      response_metadata,\n    });\n  } else if (role === \"system\") {\n    return new SystemMessageChunk({ content, response_metadata });\n  } else if (role === \"developer\") {\n    return new SystemMessageChunk({\n      content,\n      response_metadata,\n      additional_kwargs: {\n        __openai_role__: \"developer\",\n      },\n    });\n  } else if (role === \"function\") {\n    return new FunctionMessageChunk({\n      content,\n      additional_kwargs,\n      name: delta.name,\n      response_metadata,\n    });\n  } else if (role === \"tool\") {\n    return new ToolMessageChunk({\n      content,\n      additional_kwargs,\n      tool_call_id: delta.tool_call_id,\n      response_metadata,\n    });\n  } else {\n    return new ChatMessageChunk({ content, role, response_metadata });\n  }\n}\n\n/*\nfunction _oldConvertDeltaToMessageChunk(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  delta: Record<string, any>,\n  rawResponse: ChatCompletionsAPI.ChatCompletionChunk,\n  index: number,\n  defaultRole: GroqRoleEnum | undefined,\n  xGroq?: ChatCompletionsAPI.ChatCompletionChunk.XGroq\n): {\n  message: BaseMessageChunk;\n  toolCallData?: {\n    id: string;\n    name: string;\n    index: number;\n    type: \"tool_call_chunk\";\n  }[];\n} {\n  const { role } = delta;\n  const content = delta.content ?? \"\";\n  let additional_kwargs;\n  if (delta.function_call) {\n    additional_kwargs = {\n      function_call: delta.function_call,\n    };\n  } else if (delta.tool_calls) {\n    additional_kwargs = {\n      tool_calls: delta.tool_calls,\n    };\n  } else {\n    additional_kwargs = {};\n  }\n\n  let usageMetadata: UsageMetadata | undefined;\n  let groqMessageId: string | undefined;\n  if (xGroq?.usage) {\n    usageMetadata = {\n      input_tokens: xGroq.usage.prompt_tokens,\n      output_tokens: xGroq.usage.completion_tokens,\n      total_tokens: xGroq.usage.total_tokens,\n    };\n    groqMessageId = xGroq.id;\n  }\n\n  if (role === \"user\") {\n    return {\n      message: new HumanMessageChunk({ content }),\n    };\n  } else if (role === \"assistant\") {\n    const toolCallChunks = _convertDeltaToolCallToToolCallChunk(\n      delta.tool_calls,\n      index\n    );\n    return {\n      message: new AIMessageChunk({\n        content,\n        additional_kwargs,\n        tool_call_chunks: toolCallChunks\n          ? toolCallChunks.map((tc) => ({\n              type: tc.type,\n              args: tc.args,\n              index: tc.index,\n            }))\n          : undefined,\n        usage_metadata: usageMetadata,\n        id: groqMessageId,\n      }),\n      toolCallData: toolCallChunks\n        ? toolCallChunks.map((tc) => ({\n            id: tc.id ?? \"\",\n            name: tc.name ?? \"\",\n            index: tc.index ?? index,\n            type: \"tool_call_chunk\",\n          }))\n        : undefined,\n    };\n  } else if (role === \"system\") {\n    return {\n      message: new SystemMessageChunk({ content }),\n    };\n  } else {\n    return {\n      message: new ChatMessageChunk({ content, role }),\n    };\n  }\n}\n*/\n\n/**\n * Groq chat model integration.\n *\n * The Groq API is compatible to the OpenAI API with some limitations. View the\n * full API ref at:\n * @link {https://docs.api.groq.com/md/openai.oas.html}\n *\n * Setup:\n * Install `@langchain/groq` and set an environment variable named `GROQ_API_KEY`.\n *\n * ```bash\n * npm install @langchain/groq\n * export GROQ_API_KEY=\"your-api-key\"\n * ```\n *\n * ## [Constructor args](https://api.js.langchain.com/classes/langchain_groq.ChatGroq.html#constructor)\n *\n * ## [Runtime args](https://api.js.langchain.com/interfaces/langchain_groq.ChatGroqCallOptions.html)\n *\n * Runtime args can be passed as the second argument to any of the base runnable methods `.invoke`. `.stream`, `.batch`, etc.\n * They can also be passed via `.withConfig`, or the second arg in `.bindTools`, like shown in the examples below:\n *\n * ```typescript\n * // When calling `.withConfig`, call options should be passed via the first argument\n * const llmWithArgsBound = llm.withConfig({\n *   stop: [\"\\n\"],\n * });\n *\n * // When calling `.bindTools`, call options should be passed via the second argument\n * const llmWithTools = llm.bindTools(\n *   [...],\n *   {\n *     tool_choice: \"auto\",\n *   }\n * );\n * ```\n *\n * ## Examples\n *\n * <details open>\n * <summary><strong>Instantiate</strong></summary>\n *\n * ```typescript\n * import { ChatGroq } from '@langchain/groq';\n *\n * const llm = new ChatGroq({\n *   model: \"llama-3.3-70b-versatile\",\n *   temperature: 0,\n *   // other params...\n * });\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Invoking</strong></summary>\n *\n * ```typescript\n * const input = `Translate \"I love programming\" into French.`;\n *\n * // Models also accept a list of chat messages or a formatted prompt\n * const result = await llm.invoke(input);\n * console.log(result);\n * ```\n *\n * ```txt\n * AIMessage {\n *   \"content\": \"The French translation of \\\"I love programming\\\" is \\\"J'aime programmer\\\". In this sentence, \\\"J'aime\\\" is the first person singular conjugation of the French verb \\\"aimer\\\" which means \\\"to love\\\", and \\\"programmer\\\" is the French infinitive for \\\"to program\\\". I hope this helps! Let me know if you have any other questions.\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"tokenUsage\": {\n *       \"completionTokens\": 82,\n *       \"promptTokens\": 20,\n *       \"totalTokens\": 102\n *     },\n *     \"finish_reason\": \"stop\"\n *   },\n *   \"tool_calls\": [],\n *   \"invalid_tool_calls\": []\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Streaming Chunks</strong></summary>\n *\n * ```typescript\n * for await (const chunk of await llm.stream(input)) {\n *   console.log(chunk);\n * }\n * ```\n *\n * ```txt\n * AIMessageChunk {\n *   \"content\": \"\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": null\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * AIMessageChunk {\n *   \"content\": \"The\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": null\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * AIMessageChunk {\n *   \"content\": \" French\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": null\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * AIMessageChunk {\n *   \"content\": \" translation\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": null\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * AIMessageChunk {\n *   \"content\": \" of\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": null\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * AIMessageChunk {\n *   \"content\": \" \\\"\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": null\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * AIMessageChunk {\n *   \"content\": \"I\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": null\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * AIMessageChunk {\n *   \"content\": \" love\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": null\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * ...\n * AIMessageChunk {\n *   \"content\": \".\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": null\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * AIMessageChunk {\n *   \"content\": \"\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": \"stop\"\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Aggregate Streamed Chunks</strong></summary>\n *\n * ```typescript\n * import { AIMessageChunk } from '@langchain/core/messages';\n * import { concat } from '@langchain/core/utils/stream';\n *\n * const stream = await llm.stream(input);\n * let full: AIMessageChunk | undefined;\n * for await (const chunk of stream) {\n *   full = !full ? chunk : concat(full, chunk);\n * }\n * console.log(full);\n * ```\n *\n * ```txt\n * AIMessageChunk {\n *   \"content\": \"The French translation of \\\"I love programming\\\" is \\\"J'aime programmer\\\". In this sentence, \\\"J'aime\\\" is the first person singular conjugation of the French verb \\\"aimer\\\" which means \\\"to love\\\", and \\\"programmer\\\" is the French infinitive for \\\"to program\\\". I hope this helps! Let me know if you have any other questions.\",\n *   \"additional_kwargs\": {},\n *   \"response_metadata\": {\n *     \"finishReason\": \"stop\"\n *   },\n *   \"tool_calls\": [],\n *   \"tool_call_chunks\": [],\n *   \"invalid_tool_calls\": []\n * }\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Bind tools</strong></summary>\n *\n * ```typescript\n * import { z } from 'zod';\n *\n * const llmForToolCalling = new ChatGroq({\n *   model: \"llama3-groq-70b-8192-tool-use-preview\",\n *   temperature: 0,\n *   // other params...\n * });\n *\n * const GetWeather = {\n *   name: \"GetWeather\",\n *   description: \"Get the current weather in a given location\",\n *   schema: z.object({\n *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n *   }),\n * }\n *\n * const GetPopulation = {\n *   name: \"GetPopulation\",\n *   description: \"Get the current population in a given location\",\n *   schema: z.object({\n *     location: z.string().describe(\"The city and state, e.g. San Francisco, CA\")\n *   }),\n * }\n *\n * const llmWithTools = llmForToolCalling.bindTools([GetWeather, GetPopulation]);\n * const aiMsg = await llmWithTools.invoke(\n *   \"Which city is hotter today and which is bigger: LA or NY?\"\n * );\n * console.log(aiMsg.tool_calls);\n * ```\n *\n * ```txt\n * [\n *   {\n *     name: 'GetWeather',\n *     args: { location: 'Los Angeles, CA' },\n *     type: 'tool_call',\n *     id: 'call_cd34'\n *   },\n *   {\n *     name: 'GetWeather',\n *     args: { location: 'New York, NY' },\n *     type: 'tool_call',\n *     id: 'call_68rf'\n *   },\n *   {\n *     name: 'GetPopulation',\n *     args: { location: 'Los Angeles, CA' },\n *     type: 'tool_call',\n *     id: 'call_f81z'\n *   },\n *   {\n *     name: 'GetPopulation',\n *     args: { location: 'New York, NY' },\n *     type: 'tool_call',\n *     id: 'call_8byt'\n *   }\n * ]\n * ```\n * </details>\n *\n * <br />\n *\n * <details>\n * <summary><strong>Structured Output</strong></summary>\n *\n * ```typescript\n * import { z } from 'zod';\n *\n * const Joke = z.object({\n *   setup: z.string().describe(\"The setup of the joke\"),\n *   punchline: z.string().describe(\"The punchline to the joke\"),\n *   rating: z.number().optional().describe(\"How funny the joke is, from 1 to 10\")\n * }).describe('Joke to tell user.');\n *\n * const structuredLlm = llmForToolCalling.withStructuredOutput(Joke, { name: \"Joke\" });\n * const jokeResult = await structuredLlm.invoke(\"Tell me a joke about cats\");\n * console.log(jokeResult);\n * ```\n *\n * ```txt\n * {\n *   setup: \"Why don't cats play poker in the wild?\",\n *   punchline: 'Because there are too many cheetahs.'\n * }\n * ```\n * </details>\n *\n * <br />\n */\nexport class ChatGroq extends BaseChatModel<\n  ChatGroqCallOptions,\n  AIMessageChunk\n> {\n  lc_namespace = [\"langchain\", \"chat_models\", \"groq\"];\n\n  client: Groq;\n\n  model: string;\n\n  temperature = 0.7;\n\n  stop?: string[];\n\n  stopSequences?: string[];\n\n  maxTokens?: number;\n\n  streaming = false;\n\n  apiKey?: string;\n\n  streamUsage: boolean = true;\n\n  topP: number | null | undefined;\n\n  frequencyPenalty: number | null | undefined;\n\n  presencePenalty: number | null | undefined;\n\n  logprobs: boolean | null | undefined;\n\n  n: number | null | undefined;\n\n  logitBias: Record<string, number> | null | undefined;\n\n  user: string | null | undefined;\n\n  reasoningFormat: ChatCompletionsAPI.ChatCompletionCreateParamsBase[\"reasoning_format\"];\n\n  serviceTier: ChatCompletionsAPI.ChatCompletionCreateParamsBase[\"service_tier\"];\n\n  topLogprobs: number | null | undefined;\n\n  lc_serializable = true;\n\n  get lc_serialized_keys(): string[] {\n    return [\n      \"client\",\n      \"model\",\n      \"temperature\",\n      \"stop\",\n      \"stopSequences\",\n      \"maxTokens\",\n      \"streaming\",\n      \"apiKey\",\n      \"streamUsage\",\n      \"topP\",\n      \"frequencyPenalty\",\n      \"presencePenalty\",\n      \"logprobs\",\n      \"n\",\n      \"logitBias\",\n      \"user\",\n      \"reasoningFormat\",\n      \"serviceTier\",\n      \"topLogprobs\",\n    ];\n  }\n\n  static lc_name() {\n    return \"ChatGroq\";\n  }\n\n  _llmType() {\n    return \"groq\";\n  }\n\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return {\n      apiKey: \"GROQ_API_KEY\",\n    };\n  }\n\n  get callKeys() {\n    return [...super.callKeys, ...ALL_CALL_KEYS];\n  }\n\n  constructor(fields: ChatGroqInput) {\n    super(fields);\n\n    const apiKey = fields.apiKey || getEnvironmentVariable(\"GROQ_API_KEY\");\n    if (!apiKey) {\n      throw new Error(\n        `Groq API key not found. Please set the GROQ_API_KEY environment variable or provide the key into \"apiKey\"`\n      );\n    }\n    const defaultHeaders = {\n      \"User-Agent\": \"langchainjs\",\n      ...(fields.defaultHeaders ?? {}),\n    };\n\n    this.client = new Groq({\n      apiKey,\n      dangerouslyAllowBrowser: true,\n      baseURL: fields.baseUrl,\n      timeout: fields.timeout,\n      httpAgent: fields.httpAgent,\n      fetch: fields.fetch,\n      maxRetries: 0,\n      defaultHeaders,\n      defaultQuery: fields.defaultQuery,\n    });\n    this.apiKey = apiKey;\n    this.temperature = fields.temperature ?? this.temperature;\n    this.model = fields.model;\n    this.streaming = fields.streaming ?? this.streaming;\n    this.stop =\n      fields.stopSequences ??\n      (typeof fields.stop === \"string\" ? [fields.stop] : fields.stop) ??\n      [];\n    this.stopSequences = this.stop;\n    this.maxTokens = fields.maxTokens;\n    this.topP = fields.topP;\n    this.frequencyPenalty = fields.frequencyPenalty;\n    this.presencePenalty = fields.presencePenalty;\n    this.logprobs = fields.logprobs;\n    this.n = fields.n;\n    this.logitBias = fields.logitBias;\n    this.user = fields.user;\n  }\n\n  getLsParams(options: this[\"ParsedCallOptions\"]): LangSmithParams {\n    const params = this.invocationParams(options);\n    return {\n      ls_provider: \"groq\",\n      ls_model_name: this.model,\n      ls_model_type: \"chat\",\n      ls_temperature: params.temperature ?? this.temperature,\n      ls_max_tokens: params.max_tokens ?? this.maxTokens,\n      ls_stop: options.stop,\n    };\n  }\n\n  async completionWithRetry(\n    request: ChatCompletionCreateParamsStreaming,\n    options?: RequestOptions\n  ): Promise<AsyncIterable<ChatCompletionsAPI.ChatCompletionChunk>>;\n\n  async completionWithRetry(\n    request: ChatCompletionCreateParamsNonStreaming,\n    options?: RequestOptions\n  ): Promise<ChatCompletion>;\n\n  async completionWithRetry(\n    request: ChatCompletionCreateParams,\n    options?: RequestOptions\n  ): Promise<\n    AsyncIterable<ChatCompletionsAPI.ChatCompletionChunk> | ChatCompletion\n  > {\n    return this.caller.call(async () =>\n      this.client.chat.completions.create(request, options)\n    );\n  }\n\n  invocationParams(\n    options: this[\"ParsedCallOptions\"],\n    extra?: { streaming?: boolean }\n  ): Omit<ChatCompletionCreateParams, \"messages\"> {\n    const params = super.invocationParams(options);\n\n    let streamOptionsConfig = {};\n\n    if (options?.stream_options !== undefined) {\n      streamOptionsConfig = { stream_options: options.stream_options };\n    } else if ((this.streamUsage && this.streaming) || extra?.streaming) {\n      streamOptionsConfig = { stream_options: { include_usage: true } };\n    }\n\n    const toReturn: Omit<ChatCompletionCreateParams, \"messages\"> = {\n      model: this.model,\n      frequency_penalty: this.frequencyPenalty,\n      function_call: options?.function_call,\n      functions: options?.functions,\n      logit_bias: this.logitBias,\n      logprobs: this.logprobs,\n      // max_completion_tokens\n      // max_tokens\n      n: this.n,\n      parallel_tool_calls: options?.parallel_tool_calls,\n      presence_penalty: this.presencePenalty,\n      reasoning_format: this.reasoningFormat,\n      response_format: options?.response_format,\n      seed: options?.seed,\n      service_tier: this.serviceTier,\n      stop: options?.stop ?? this.stopSequences,\n      temperature: options?.temperature ?? this.temperature,\n      tool_choice: _formatToGroqToolChoice(options?.tool_choice),\n      tools: options?.tools?.length\n        ? options.tools.map((tool) => convertToOpenAITool(tool))\n        : undefined,\n      top_logprobs: this.topLogprobs,\n      top_p: this.topP,\n      user: this.user,\n      // if include_usage is set or streamUsage then stream must be set to true.\n      stream: this.streaming,\n      ...params,\n      ...streamOptionsConfig,\n    };\n\n    toReturn.max_completion_tokens =\n      options?.max_completion_tokens ?? options?.max_tokens ?? this.maxTokens;\n    if (toReturn.max_completion_tokens === -1) {\n      delete toReturn.max_completion_tokens;\n    }\n\n    return toReturn;\n  }\n\n  override bindTools(\n    tools: ChatGroqToolType[],\n    kwargs?: Partial<ChatGroqCallOptions>\n  ): Runnable<BaseLanguageModelInput, AIMessageChunk, ChatGroqCallOptions> {\n    return this.withConfig({\n      tools: tools.map((tool) => convertToOpenAITool(tool)),\n      ...kwargs,\n    });\n  }\n\n  override async *_streamResponseChunks(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const params = this.invocationParams(options, { streaming: true });\n    const messagesMapped = convertMessagesToGroqParams(messages);\n    const response = await this.completionWithRetry(\n      {\n        ...params,\n        messages: messagesMapped,\n        stream: true,\n      },\n      {\n        signal: options?.signal,\n        headers: options?.headers,\n      }\n    );\n    let role: GroqRoleEnum | undefined;\n    let lastMessageId: string | undefined;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let responseMetadata: Record<string, any> | undefined;\n\n    for await (const data of response) {\n      responseMetadata = data;\n      const choice = data?.choices[0];\n      if (!choice) {\n        continue;\n      }\n      // The `role` field is populated in the first delta of the response\n      // but is not present in subsequent deltas. Extract it when available.\n      if (choice.delta?.role) {\n        role = choice.delta.role as GroqRoleEnum;\n      }\n\n      const chunk = _convertDeltaToMessageChunk(\n        choice.delta,\n        role,\n        data,\n        lastMessageId\n      );\n      const newTokenIndices = {\n        prompt: options.promptIndex ?? 0,\n        completion: choice.index ?? 0,\n      };\n      if (typeof chunk.content !== \"string\") {\n        console.log(\n          \"[WARNING]: Received non-string content from OpenAI. This is currently not supported.\"\n        );\n        continue;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const generationInfo: Record<string, any> = { ...newTokenIndices };\n      if (choice.finish_reason != null) {\n        generationInfo.finish_reason = choice.finish_reason;\n        // Only include system fingerprint in the last chunk for now\n        // to avoid concatenation issues\n        generationInfo.system_fingerprint = data.system_fingerprint;\n        generationInfo.model_name = data.model;\n      }\n      const generationChunk = new ChatGenerationChunk({\n        message: chunk,\n        text: chunk.content,\n        generationInfo,\n      });\n      yield generationChunk;\n      await runManager?.handleLLMNewToken(\n        generationChunk.text ?? \"\",\n        newTokenIndices,\n        undefined,\n        undefined,\n        undefined,\n        { chunk: generationChunk }\n      );\n    }\n\n    if (responseMetadata) {\n      if (\"choices\" in responseMetadata) {\n        delete responseMetadata.choices;\n      }\n      yield new ChatGenerationChunk({\n        message: new AIMessageChunk({\n          content: \"\",\n          response_metadata: responseMetadata,\n        }),\n        text: \"\",\n      });\n    }\n\n    if (options.signal?.aborted) {\n      throw new Error(\"AbortError\");\n    }\n  }\n\n  override async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    if (this.streaming) {\n      const tokenUsage: TokenUsage = {};\n      const stream = this._streamResponseChunks(messages, options, runManager);\n      const finalChunks: Record<number, ChatGenerationChunk> = {};\n      for await (const chunk of stream) {\n        const index =\n          (chunk.generationInfo as NewTokenIndices)?.completion ?? 0;\n        if (finalChunks[index] === undefined) {\n          finalChunks[index] = chunk;\n        } else {\n          finalChunks[index] = finalChunks[index].concat(chunk);\n        }\n      }\n      const generations = Object.entries(finalChunks)\n        .sort(([aKey], [bKey]) => parseInt(aKey, 10) - parseInt(bKey, 10))\n        .map(([_, value]) => value);\n\n      return { generations, llmOutput: { estimatedTokenUsage: tokenUsage } };\n    } else {\n      return this._generateNonStreaming(messages, options, runManager);\n    }\n  }\n\n  async _generateNonStreaming(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const tokenUsage: TokenUsage = {};\n    const params = this.invocationParams(options);\n    const messagesMapped = convertMessagesToGroqParams(messages);\n\n    const data = await this.completionWithRetry(\n      {\n        ...params,\n        stream: false,\n        messages: messagesMapped,\n      },\n      {\n        signal: options?.signal,\n        headers: options?.headers,\n      }\n    );\n\n    if (\"usage\" in data && data.usage) {\n      const {\n        completion_tokens: completionTokens,\n        prompt_tokens: promptTokens,\n        total_tokens: totalTokens,\n      } = data.usage as CompletionsAPI.CompletionUsage;\n\n      if (completionTokens) {\n        tokenUsage.completionTokens =\n          (tokenUsage.completionTokens ?? 0) + completionTokens;\n      }\n\n      if (promptTokens) {\n        tokenUsage.promptTokens = (tokenUsage.promptTokens ?? 0) + promptTokens;\n      }\n\n      if (totalTokens) {\n        tokenUsage.totalTokens = (tokenUsage.totalTokens ?? 0) + totalTokens;\n      }\n    }\n\n    const generations: ChatGeneration[] = [];\n\n    if (\"choices\" in data && data.choices) {\n      for (const part of (data as ChatCompletion).choices) {\n        const text = part.message?.content ?? \"\";\n        let usageMetadata: UsageMetadata | undefined;\n        if (tokenUsage.totalTokens !== undefined) {\n          usageMetadata = {\n            input_tokens: tokenUsage.promptTokens ?? 0,\n            output_tokens: tokenUsage.completionTokens ?? 0,\n            total_tokens: tokenUsage.totalTokens,\n          };\n        }\n        // extract all fields from the response object except\n        // choices to be included as response metadata\n        const { choices: _choices, ...metadata } = data;\n\n        const generation: ChatGeneration = {\n          text,\n          message: groqResponseToChatMessage(\n            part.message ?? { role: \"assistant\" },\n            usageMetadata,\n            metadata\n          ),\n        };\n        generation.generationInfo = {\n          ...(part.finish_reason ? { finish_reason: part.finish_reason } : {}),\n          ...(part.logprobs ? { logprobs: part.logprobs } : {}),\n        };\n        generations.push(generation);\n      }\n    }\n\n    return {\n      generations,\n      llmOutput: { tokenUsage },\n    };\n  }\n\n  /**\n   * Return profiling information for the model.\n   *\n   * Provides information about the model's capabilities and constraints,\n   * including token limits, multimodal support, and advanced features like\n   * tool calling and structured output.\n   *\n   * @returns {ModelProfile} An object describing the model's capabilities and constraints\n   *\n   * @example\n   * ```typescript\n   * const model = new ChatGroq({ model: \"llama-3.1-8b-instant\" });\n   * const profile = model.profile;\n   * console.log(profile.maxInputTokens); // 128000\n   * console.log(profile.imageInputs); // true\n   * ```\n   */\n  get profile(): ModelProfile {\n    return PROFILES[this.model] ?? {};\n  }\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        { raw: BaseMessage; parsed: RunOutput }\n      > {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const schema: InteropZodType<RunOutput> | Record<string, any> =\n      outputSchema;\n    const name = config?.name;\n    const method = config?.method;\n    const includeRaw = config?.includeRaw;\n\n    let functionName = name ?? \"extract\";\n    let outputParser: BaseLLMOutputParser<RunOutput>;\n    let llm: Runnable<BaseLanguageModelInput>;\n\n    if (method === \"jsonMode\") {\n      let outputSchema: JsonSchema7Type | undefined;\n      if (isInteropZodSchema(schema)) {\n        outputParser = StructuredOutputParser.fromZodSchema(schema);\n        outputSchema = toJsonSchema(schema);\n      } else {\n        outputParser = new JsonOutputParser<RunOutput>();\n      }\n      llm = this.withConfig({\n        response_format: { type: \"json_object\" },\n        ls_structured_output_format: {\n          kwargs: { method: \"jsonMode\" },\n          schema: outputSchema,\n        },\n      });\n    } else {\n      if (isInteropZodSchema(schema)) {\n        const asJsonSchema = toJsonSchema(schema);\n        llm = this.bindTools([\n          {\n            type: \"function\" as const,\n            function: {\n              name: functionName,\n              description: asJsonSchema.description,\n              parameters: asJsonSchema,\n            },\n          },\n        ]).withConfig({\n          tool_choice: {\n            type: \"function\" as const,\n            function: {\n              name: functionName,\n            },\n          },\n          ls_structured_output_format: {\n            kwargs: { method: \"functionCalling\" },\n            schema: asJsonSchema,\n          },\n        });\n        outputParser = new JsonOutputKeyToolsParser({\n          returnSingle: true,\n          keyName: functionName,\n          zodSchema: schema,\n        });\n      } else {\n        let openAIFunctionDefinition: FunctionDefinition;\n        if (\n          typeof schema.name === \"string\" &&\n          typeof schema.parameters === \"object\" &&\n          schema.parameters != null\n        ) {\n          openAIFunctionDefinition = schema as FunctionDefinition;\n          functionName = schema.name;\n        } else {\n          functionName = schema.title ?? functionName;\n          openAIFunctionDefinition = {\n            name: functionName,\n            description: schema.description ?? \"\",\n            parameters: schema,\n          };\n        }\n        llm = this.bindTools([\n          {\n            type: \"function\" as const,\n            function: openAIFunctionDefinition,\n          },\n        ]).withConfig({\n          tool_choice: {\n            type: \"function\" as const,\n            function: {\n              name: functionName,\n            },\n          },\n          ls_structured_output_format: {\n            kwargs: { method: \"functionCalling\" },\n            schema,\n          },\n        });\n        outputParser = new JsonOutputKeyToolsParser<RunOutput>({\n          returnSingle: true,\n          keyName: functionName,\n        });\n      }\n    }\n\n    if (!includeRaw) {\n      return llm.pipe(outputParser).withConfig({\n        runName: \"ChatGroqStructuredOutput\",\n      });\n    }\n\n    const parserAssign = RunnablePassthrough.assign({\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parsed: (input: any, config) => outputParser.invoke(input.raw, config),\n    });\n    const parserNone = RunnablePassthrough.assign({\n      parsed: () => null,\n    });\n    const parsedWithFallback = parserAssign.withFallbacks({\n      fallbacks: [parserNone],\n    });\n    return RunnableSequence.from<\n      BaseLanguageModelInput,\n      { raw: BaseMessage; parsed: RunOutput }\n    >([\n      {\n        raw: llm,\n      },\n      parsedWithFallback,\n    ]).withConfig({\n      runName: \"ChatGroqStructuredOutput\",\n    });\n  }\n}\n\nfunction _formatToGroqToolChoice(\n  toolChoice?: string | ChatCompletionsAPI.ChatCompletionNamedToolChoice\n):\n  | ChatCompletionsAPI.ChatCompletionToolChoiceOption\n  | Record<string, unknown>\n  | null\n  | undefined {\n  if (!toolChoice) {\n    return undefined;\n  } else if (toolChoice === \"any\" || toolChoice === \"required\") {\n    return \"required\";\n  } else if (toolChoice === \"auto\") {\n    return \"auto\";\n  } else if (toolChoice === \"none\") {\n    return \"none\";\n  } else if (typeof toolChoice === \"string\") {\n    return {\n      type: \"function\",\n      function: {\n        name: toolChoice,\n      },\n    };\n  } else {\n    return toolChoice;\n  }\n}\n"],
  "mappings": "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",
  "names": ["len", "i", "len2", "PROFILES: Record<string, ModelProfile>", "value: string", "fields: BaseMessage[] | ChatPromptValueFields", "fields: ImageContent | ImagePromptValueFields", "blocks", "defaultHashKeyEncoder: HashKeyEncoder", "storedGeneration: StoredGeneration", "generation: Generation", "serializedValue: StoredGeneration", "keyEncoderFn: HashKeyEncoder", "InMemoryCache", "map?: Map<string, T>", "prompt: string", "llmKey: string", "value: T", "__publicField", "base64", "__publicField", "cache: Record<string, Promise<Tiktoken>>", "encoding: TiktokenEncoding", "model: TiktokenModel", "modelName: string", "modelName?: string", "tool: unknown", "params: BaseLangChainParams", "cache", "content: MessageContent", "textContent: string", "input: BaseLanguageModelInput", "params: Record<string, any>", "_data: SerializedLLM", "fields?: { func?: RunnablePassthroughFunc<RunInput> }", "input: RunInput", "options?: Partial<RunnableConfig>", "input", "generator: AsyncGenerator<RunInput>", "options: Partial<RunnableConfig>", "finalOutput: RunInput | undefined", "input: AsyncGenerator<RunInput>", "mapping: RunnableMapLike<RunInput, RunOutput>", "fn: () => T", "message: T", "messages: BaseMessage[]", "messagesToTrace: BaseMessage[]", "BaseChatModel", "fields: BaseChatModelParams", "options?: Partial<CallOptions>", "input: BaseLanguageModelInput", "options?: CallOptions", "_messages: BaseMessage[]", "_options: this[\"ParsedCallOptions\"]", "_runManager?: CallbackManagerForLLMRun", "generationChunk: ChatGenerationChunk | undefined", "llmOutput: Record<string, any> | undefined", "_a", "options: this[\"ParsedCallOptions\"]", "messages: BaseMessageLike[][]", "parsedOptions: this[\"ParsedCallOptions\"]", "handledOptions: RunnableConfig", "startedRunManagers?: CallbackManagerForLLMRun[]", "runManagers: CallbackManagerForLLMRun[] | undefined", "generations: ChatGeneration[][]", "llmOutputs: LLMResult[\"llmOutput\"][]", "_b", "output: LLMResult", "cache", "missingPromptIndices: number[]", "generations: Generation[][]", "result", "options?: string[] | CallOptions", "callbacks?: Callbacks", "parsedOptions: CallOptions | undefined", "_options?: this[\"ParsedCallOptions\"]", "promptValues: BasePromptValueInterface[]", "promptMessages: BaseMessage[][]", "outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>", "config?: StructuredOutputMethodOptions<boolean>", "schema: Record<string, any> | InteropZodType<RunOutput>", "tools: ToolDefinition[]", "input: BaseMessageChunk", "input: any", "config", "runManager?: CallbackManagerForLLMRun", "fetch", "Request", "Response", "Headers", "FormData", "Blob", "File", "ReadableStream", "ReadableStream", "_a", "File", "_a", "FormData", "_a", "fetch", "opts", "retryMessage", "init", "_a", "_a", "_a", "_a", "Completions", "Completions", "fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }", "input: RunInput", "options?: Partial<RunnableConfig>", "inputs: RunInput[]", "options?: Partial<RunnableConfig> | Partial<RunnableConfig>[]", "batchOptions?: RunnableBatchOptions", "_a", "i", "fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }", "branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>,\n    ]", "coercedBranches: Branch<RunInput, RunOutput>[]", "input: RunInput", "config?: Partial<RunnableConfig>", "runManager?: CallbackManagerForChainRun", "config: RunnableConfig", "fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>", "historyChain: Runnable", "config", "inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>", "outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>", "input: any", "kwargs?: RunnableConfig", "_a", "run: Run", "config: RunnableConfig", "generations: Generation[] | ChatGeneration[]", "_prompt: BasePromptValueInterface", "callbacks?: Callbacks", "message: BaseMessage", "content: ContentBlock[]", "input: string | BaseMessage", "options?: RunnableConfig", "input: string", "options", "input", "input: BaseMessage", "text: string", "message: string", "llmOutput?: string", "observation?: string", "inputGenerator: AsyncGenerator<string | BaseMessage>", "options: BaseCallbackConfig", "fields?: BaseCumulativeTransformOutputParserInput", "prevParsed: T | undefined", "accGen: GenerationChunk | undefined", "chunkGen: GenerationChunk", "text: string", "inputGenerator: AsyncGenerator<string | BaseMessage>", "text: string", "text: string", "content: ContentBlock.Text", "_content: ContentBlock.Data.URLContentBlock", "content: ContentBlock", "content: ContentBlock[]", "acc: string", "item: ContentBlock", "schema: T", "schemas: S", "text: string", "_a", "options?: JsonMarkdownFormatInstructionsOptions", "schemaInput: JsonSchema7Type", "type: string", "type", "description", "first: T", "second: T", "prev: unknown | undefined", "next: unknown", "generations: ChatGeneration[] | Generation[]", "text: string", "message: BaseMessage", "sax: any", "sax", "Stream", "s", "fields?: XMLOutputParserFields", "prev: unknown | undefined", "next: unknown", "generations: ChatGeneration[] | Generation[]", "text: string", "_a", "input: ParsedResult", "result: XMLResult", "s: string", "parsedResult: ParsedResult", "elementStack: ParsedResult[]", "node: any", "text: any", "attr: any", "rawToolCall: Record<string, any>", "options?: { returnId?: boolean; partial?: boolean }", "e: any", "parsedToolCall: ToolCall", "toolCall: ToolCall", "errorMsg?: string", "_a", "fields?: JsonOutputToolsParserParams", "generations: ChatGeneration[]", "generations: ChatGenerationChunk[] | ChatGeneration[]", "rawToolCall: Record<string, unknown>", "backwardsCompatibleToolCall: ParsedToolCall", "params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>", "result: unknown", "result: ParsedToolCall", "returnedValues: ParsedToolCall[] | Record<string, any>[]", "tool?: StructuredToolInterface | ToolDefinition | JSONSchema", "tool?: unknown", "tool: StructuredToolInterface | RunnableToolLike | StructuredToolParams", "fields?:\n    | {\n        /**\n         * If `true`, model output is guaranteed to exactly match the JSON Schema\n         * provided in the function definition.\n         */\n        strict?: boolean;\n      }\n    | number", "tool: StructuredToolInterface | Record<string, any> | RunnableToolLike", "toolDef: ToolDefinition | undefined", "ALL_CALL_KEYS: readonly (keyof ChatGroqCallOptions)[]", "message: ChatMessage", "message: BaseMessage", "messages: BaseMessage[]", "completionParam: Record<string, any>", "_a", "message: ChatCompletionsAPI.ChatCompletionMessage", "usageMetadata?: UsageMetadata", "responseMetadata?: Record<string, unknown>", "rawToolCalls: OpenAIToolCall[] | undefined", "e: any", "delta: Record<string, any>", "defaultRole: GroqRoleEnum | undefined", "rawResponse: ChatCompletionsAPI.ChatCompletionChunk", "lastMessageId: string | undefined", "additional_kwargs: Record<string, unknown>", "usage: UsageMetadata | undefined", "groqMessageId: string | undefined", "timing: TimingMetadata | undefined", "toolCallChunks: ToolCallChunk[]", "fields: ChatGroqInput", "options: this[\"ParsedCallOptions\"]", "request: ChatCompletionCreateParams", "options?: RequestOptions", "extra?: { streaming?: boolean }", "toReturn: Omit<ChatCompletionCreateParams, \"messages\">", "tools: ChatGroqToolType[]", "kwargs?: Partial<ChatGroqCallOptions>", "runManager?: CallbackManagerForLLMRun", "role: GroqRoleEnum | undefined", "responseMetadata: Record<string, any> | undefined", "generationInfo: Record<string, any>", "tokenUsage: TokenUsage", "finalChunks: Record<number, ChatGenerationChunk>", "_runManager?: CallbackManagerForLLMRun", "generations: ChatGeneration[]", "usageMetadata: UsageMetadata | undefined", "generation: ChatGeneration", "PROFILES", "outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>", "config?: StructuredOutputMethodOptions<boolean>", "schema: InteropZodType<RunOutput> | Record<string, any>", "outputParser: BaseLLMOutputParser<RunOutput>", "llm: Runnable<BaseLanguageModelInput>", "outputSchema: JsonSchema7Type | undefined", "outputSchema", "openAIFunctionDefinition: FunctionDefinition", "input: any", "config", "toolChoice?: string | ChatCompletionsAPI.ChatCompletionNamedToolChoice"]
}
